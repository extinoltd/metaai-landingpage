(function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) a(r); new MutationObserver(r => { for (const d of r) if (d.type === "childList") for (const m of d.addedNodes) m.tagName === "LINK" && m.rel === "modulepreload" && a(m) }).observe(document, { childList: !0, subtree: !0 }); function l(r) { const d = {}; return r.integrity && (d.integrity = r.integrity), r.referrerPolicy && (d.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? d.credentials = "include" : r.crossOrigin === "anonymous" ? d.credentials = "omit" : d.credentials = "same-origin", d } function a(r) { if (r.ep) return; r.ep = !0; const d = l(r); fetch(r.href, d) } })(); function Fp(i) { return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i } var fu = { exports: {} }, tl = {};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Xm; function xv() { if (Xm) return tl; Xm = 1; var i = Symbol.for("react.transitional.element"), t = Symbol.for("react.fragment"); function l(a, r, d) { var m = null; if (d !== void 0 && (m = "" + d), r.key !== void 0 && (m = "" + r.key), "key" in r) { d = {}; for (var g in r) g !== "key" && (d[g] = r[g]) } else d = r; return r = d.ref, { $$typeof: i, type: a, key: m, ref: r !== void 0 ? r : null, props: d } } return tl.Fragment = t, tl.jsx = l, tl.jsxs = l, tl } var Qm; function Sv() { return Qm || (Qm = 1, fu.exports = xv()), fu.exports } var y = Sv(), mu = { exports: {} }, ae = {};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var jm; function Tv() { if (jm) return ae; jm = 1; var i = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), l = Symbol.for("react.fragment"), a = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), d = Symbol.for("react.consumer"), m = Symbol.for("react.context"), g = Symbol.for("react.forward_ref"), v = Symbol.for("react.suspense"), p = Symbol.for("react.memo"), x = Symbol.for("react.lazy"), T = Symbol.for("react.activity"), _ = Symbol.iterator; function A(N) { return N === null || typeof N != "object" ? null : (N = _ && N[_] || N["@@iterator"], typeof N == "function" ? N : null) } var k = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, G = Object.assign, U = {}; function V(N, P, Y) { this.props = N, this.context = P, this.refs = U, this.updater = Y || k } V.prototype.isReactComponent = {}, V.prototype.setState = function (N, P) { if (typeof N != "object" && typeof N != "function" && N != null) throw Error("takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, N, P, "setState") }, V.prototype.forceUpdate = function (N) { this.updater.enqueueForceUpdate(this, N, "forceUpdate") }; function W() { } W.prototype = V.prototype; function B(N, P, Y) { this.props = N, this.context = P, this.refs = U, this.updater = Y || k } var K = B.prototype = new W; K.constructor = B, G(K, V.prototype), K.isPureReactComponent = !0; var ee = Array.isArray; function te() { } var F = { H: null, A: null, T: null, S: null }, ge = Object.prototype.hasOwnProperty; function Z(N, P, Y) { var Q = Y.ref; return { $$typeof: i, type: N, key: P, ref: Q !== void 0 ? Q : null, props: Y } } function me(N, P) { return Z(N.type, P, N.props) } function Ae(N) { return typeof N == "object" && N !== null && N.$$typeof === i } function Le(N) { var P = { "=": "=0", ":": "=2" }; return "$" + N.replace(/[=:]/g, function (Y) { return P[Y] }) } var _e = /\/+/g; function Oe(N, P) { return typeof N == "object" && N !== null && N.key != null ? Le("" + N.key) : P.toString(36) } function ut(N) { switch (N.status) { case "fulfilled": return N.value; case "rejected": throw N.reason; default: switch (typeof N.status == "string" ? N.then(te, te) : (N.status = "pending", N.then(function (P) { N.status === "pending" && (N.status = "fulfilled", N.value = P) }, function (P) { N.status === "pending" && (N.status = "rejected", N.reason = P) })), N.status) { case "fulfilled": return N.value; case "rejected": throw N.reason } }throw N } function L(N, P, Y, Q, se) { var ce = typeof N; (ce === "undefined" || ce === "boolean") && (N = null); var Ee = !1; if (N === null) Ee = !0; else switch (ce) { case "bigint": case "string": case "number": Ee = !0; break; case "object": switch (N.$$typeof) { case i: case t: Ee = !0; break; case x: return Ee = N._init, L(Ee(N._payload), P, Y, Q, se) } }if (Ee) return se = se(N), Ee = Q === "" ? "." + Oe(N, 0) : Q, ee(se) ? (Y = "", Ee != null && (Y = Ee.replace(_e, "$&/") + "/"), L(se, P, Y, "", function (so) { return so })) : se != null && (Ae(se) && (se = me(se, Y + (se.key == null || N && N.key === se.key ? "" : ("" + se.key).replace(_e, "$&/") + "/") + Ee)), P.push(se)), 1; Ee = 0; var lt = Q === "" ? "." : Q + ":"; if (ee(N)) for (var Pe = 0; Pe < N.length; Pe++)Q = N[Pe], ce = lt + Oe(Q, Pe), Ee += L(Q, P, Y, ce, se); else if (Pe = A(N), typeof Pe == "function") for (N = Pe.call(N), Pe = 0; !(Q = N.next()).done;)Q = Q.value, ce = lt + Oe(Q, Pe++), Ee += L(Q, P, Y, ce, se); else if (ce === "object") { if (typeof N.then == "function") return L(ut(N), P, Y, Q, se); throw P = String(N), Error("Objects are not valid as a React child (found: " + (P === "[object Object]" ? "object with keys {" + Object.keys(N).join(", ") + "}" : P) + "). If you meant to render a collection of children, use an array instead.") } return Ee } function O(N, P, Y) { if (N == null) return N; var Q = [], se = 0; return L(N, Q, "", "", function (ce) { return P.call(Y, ce, se++) }), Q } function ie(N) { if (N._status === -1) { var P = N._result; P = P(), P.then(function (Y) { (N._status === 0 || N._status === -1) && (N._status = 1, N._result = Y) }, function (Y) { (N._status === 0 || N._status === -1) && (N._status = 2, N._result = Y) }), N._status === -1 && (N._status = 0, N._result = P) } if (N._status === 1) return N._result.default; throw N._result } var Ne = typeof reportError == "function" ? reportError : function (N) { if (typeof window == "object" && typeof window.ErrorEvent == "function") { var P = new window.ErrorEvent("error", { bubbles: !0, cancelable: !0, message: typeof N == "object" && N !== null && typeof N.message == "string" ? String(N.message) : String(N), error: N }); if (!window.dispatchEvent(P)) return } else if (typeof process == "object" && typeof process.emit == "function") { process.emit("uncaughtException", N); return } console.error(N) }, Ie = { map: O, forEach: function (N, P, Y) { O(N, function () { P.apply(this, arguments) }, Y) }, count: function (N) { var P = 0; return O(N, function () { P++ }), P }, toArray: function (N) { return O(N, function (P) { return P }) || [] }, only: function (N) { if (!Ae(N)) throw Error("React.Children.only expected to receive a single React element child."); return N } }; return ae.Activity = T, ae.Children = Ie, ae.Component = V, ae.Fragment = l, ae.Profiler = r, ae.PureComponent = B, ae.StrictMode = a, ae.Suspense = v, ae.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = F, ae.__COMPILER_RUNTIME = { __proto__: null, c: function (N) { return F.H.useMemoCache(N) } }, ae.cache = function (N) { return function () { return N.apply(null, arguments) } }, ae.cacheSignal = function () { return null }, ae.cloneElement = function (N, P, Y) { if (N == null) throw Error("The argument must be a React element, but you passed " + N + "."); var Q = G({}, N.props), se = N.key; if (P != null) for (ce in P.key !== void 0 && (se = "" + P.key), P) !ge.call(P, ce) || ce === "key" || ce === "__self" || ce === "__source" || ce === "ref" && P.ref === void 0 || (Q[ce] = P[ce]); var ce = arguments.length - 2; if (ce === 1) Q.children = Y; else if (1 < ce) { for (var Ee = Array(ce), lt = 0; lt < ce; lt++)Ee[lt] = arguments[lt + 2]; Q.children = Ee } return Z(N.type, se, Q) }, ae.createContext = function (N) { return N = { $$typeof: m, _currentValue: N, _currentValue2: N, _threadCount: 0, Provider: null, Consumer: null }, N.Provider = N, N.Consumer = { $$typeof: d, _context: N }, N }, ae.createElement = function (N, P, Y) { var Q, se = {}, ce = null; if (P != null) for (Q in P.key !== void 0 && (ce = "" + P.key), P) ge.call(P, Q) && Q !== "key" && Q !== "__self" && Q !== "__source" && (se[Q] = P[Q]); var Ee = arguments.length - 2; if (Ee === 1) se.children = Y; else if (1 < Ee) { for (var lt = Array(Ee), Pe = 0; Pe < Ee; Pe++)lt[Pe] = arguments[Pe + 2]; se.children = lt } if (N && N.defaultProps) for (Q in Ee = N.defaultProps, Ee) se[Q] === void 0 && (se[Q] = Ee[Q]); return Z(N, ce, se) }, ae.createRef = function () { return { current: null } }, ae.forwardRef = function (N) { return { $$typeof: g, render: N } }, ae.isValidElement = Ae, ae.lazy = function (N) { return { $$typeof: x, _payload: { _status: -1, _result: N }, _init: ie } }, ae.memo = function (N, P) { return { $$typeof: p, type: N, compare: P === void 0 ? null : P } }, ae.startTransition = function (N) { var P = F.T, Y = {}; F.T = Y; try { var Q = N(), se = F.S; se !== null && se(Y, Q), typeof Q == "object" && Q !== null && typeof Q.then == "function" && Q.then(te, Ne) } catch (ce) { Ne(ce) } finally { P !== null && Y.types !== null && (P.types = Y.types), F.T = P } }, ae.unstable_useCacheRefresh = function () { return F.H.useCacheRefresh() }, ae.use = function (N) { return F.H.use(N) }, ae.useActionState = function (N, P, Y) { return F.H.useActionState(N, P, Y) }, ae.useCallback = function (N, P) { return F.H.useCallback(N, P) }, ae.useContext = function (N) { return F.H.useContext(N) }, ae.useDebugValue = function () { }, ae.useDeferredValue = function (N, P) { return F.H.useDeferredValue(N, P) }, ae.useEffect = function (N, P) { return F.H.useEffect(N, P) }, ae.useEffectEvent = function (N) { return F.H.useEffectEvent(N) }, ae.useId = function () { return F.H.useId() }, ae.useImperativeHandle = function (N, P, Y) { return F.H.useImperativeHandle(N, P, Y) }, ae.useInsertionEffect = function (N, P) { return F.H.useInsertionEffect(N, P) }, ae.useLayoutEffect = function (N, P) { return F.H.useLayoutEffect(N, P) }, ae.useMemo = function (N, P) { return F.H.useMemo(N, P) }, ae.useOptimistic = function (N, P) { return F.H.useOptimistic(N, P) }, ae.useReducer = function (N, P, Y) { return F.H.useReducer(N, P, Y) }, ae.useRef = function (N) { return F.H.useRef(N) }, ae.useState = function (N) { return F.H.useState(N) }, ae.useSyncExternalStore = function (N, P, Y) { return F.H.useSyncExternalStore(N, P, Y) }, ae.useTransition = function () { return F.H.useTransition() }, ae.version = "19.2.3", ae } var Zm; function Gu() { return Zm || (Zm = 1, mu.exports = Tv()), mu.exports } var ze = Gu(); const Ia = Fp(ze); var hu = { exports: {} }, nl = {}, pu = { exports: {} }, gu = {};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var $m; function _v() { return $m || ($m = 1, (function (i) { function t(L, O) { var ie = L.length; L.push(O); e: for (; 0 < ie;) { var Ne = ie - 1 >>> 1, Ie = L[Ne]; if (0 < r(Ie, O)) L[Ne] = O, L[ie] = Ie, ie = Ne; else break e } } function l(L) { return L.length === 0 ? null : L[0] } function a(L) { if (L.length === 0) return null; var O = L[0], ie = L.pop(); if (ie !== O) { L[0] = ie; e: for (var Ne = 0, Ie = L.length, N = Ie >>> 1; Ne < N;) { var P = 2 * (Ne + 1) - 1, Y = L[P], Q = P + 1, se = L[Q]; if (0 > r(Y, ie)) Q < Ie && 0 > r(se, Y) ? (L[Ne] = se, L[Q] = ie, Ne = Q) : (L[Ne] = Y, L[P] = ie, Ne = P); else if (Q < Ie && 0 > r(se, ie)) L[Ne] = se, L[Q] = ie, Ne = Q; else break e } } return O } function r(L, O) { var ie = L.sortIndex - O.sortIndex; return ie !== 0 ? ie : L.id - O.id } if (i.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") { var d = performance; i.unstable_now = function () { return d.now() } } else { var m = Date, g = m.now(); i.unstable_now = function () { return m.now() - g } } var v = [], p = [], x = 1, T = null, _ = 3, A = !1, k = !1, G = !1, U = !1, V = typeof setTimeout == "function" ? setTimeout : null, W = typeof clearTimeout == "function" ? clearTimeout : null, B = typeof setImmediate < "u" ? setImmediate : null; function K(L) { for (var O = l(p); O !== null;) { if (O.callback === null) a(p); else if (O.startTime <= L) a(p), O.sortIndex = O.expirationTime, t(v, O); else break; O = l(p) } } function ee(L) { if (G = !1, K(L), !k) if (l(v) !== null) k = !0, te || (te = !0, Le()); else { var O = l(p); O !== null && ut(ee, O.startTime - L) } } var te = !1, F = -1, ge = 5, Z = -1; function me() { return U ? !0 : !(i.unstable_now() - Z < ge) } function Ae() { if (U = !1, te) { var L = i.unstable_now(); Z = L; var O = !0; try { e: { k = !1, G && (G = !1, W(F), F = -1), A = !0; var ie = _; try { t: { for (K(L), T = l(v); T !== null && !(T.expirationTime > L && me());) { var Ne = T.callback; if (typeof Ne == "function") { T.callback = null, _ = T.priorityLevel; var Ie = Ne(T.expirationTime <= L); if (L = i.unstable_now(), typeof Ie == "function") { T.callback = Ie, K(L), O = !0; break t } T === l(v) && a(v), K(L) } else a(v); T = l(v) } if (T !== null) O = !0; else { var N = l(p); N !== null && ut(ee, N.startTime - L), O = !1 } } break e } finally { T = null, _ = ie, A = !1 } O = void 0 } } finally { O ? Le() : te = !1 } } } var Le; if (typeof B == "function") Le = function () { B(Ae) }; else if (typeof MessageChannel < "u") { var _e = new MessageChannel, Oe = _e.port2; _e.port1.onmessage = Ae, Le = function () { Oe.postMessage(null) } } else Le = function () { V(Ae, 0) }; function ut(L, O) { F = V(function () { L(i.unstable_now()) }, O) } i.unstable_IdlePriority = 5, i.unstable_ImmediatePriority = 1, i.unstable_LowPriority = 4, i.unstable_NormalPriority = 3, i.unstable_Profiling = null, i.unstable_UserBlockingPriority = 2, i.unstable_cancelCallback = function (L) { L.callback = null }, i.unstable_forceFrameRate = function (L) { 0 > L || 125 < L ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : ge = 0 < L ? Math.floor(1e3 / L) : 5 }, i.unstable_getCurrentPriorityLevel = function () { return _ }, i.unstable_next = function (L) { switch (_) { case 1: case 2: case 3: var O = 3; break; default: O = _ }var ie = _; _ = O; try { return L() } finally { _ = ie } }, i.unstable_requestPaint = function () { U = !0 }, i.unstable_runWithPriority = function (L, O) { switch (L) { case 1: case 2: case 3: case 4: case 5: break; default: L = 3 }var ie = _; _ = L; try { return O() } finally { _ = ie } }, i.unstable_scheduleCallback = function (L, O, ie) { var Ne = i.unstable_now(); switch (typeof ie == "object" && ie !== null ? (ie = ie.delay, ie = typeof ie == "number" && 0 < ie ? Ne + ie : Ne) : ie = Ne, L) { case 1: var Ie = -1; break; case 2: Ie = 250; break; case 5: Ie = 1073741823; break; case 4: Ie = 1e4; break; default: Ie = 5e3 }return Ie = ie + Ie, L = { id: x++, callback: O, priorityLevel: L, startTime: ie, expirationTime: Ie, sortIndex: -1 }, ie > Ne ? (L.sortIndex = ie, t(p, L), l(v) === null && L === l(p) && (G ? (W(F), F = -1) : G = !0, ut(ee, ie - Ne))) : (L.sortIndex = Ie, t(v, L), k || A || (k = !0, te || (te = !0, Le()))), L }, i.unstable_shouldYield = me, i.unstable_wrapCallback = function (L) { var O = _; return function () { var ie = _; _ = O; try { return L.apply(this, arguments) } finally { _ = ie } } } })(gu)), gu } var eh; function Ev() { return eh || (eh = 1, pu.exports = _v()), pu.exports } var yu = { exports: {} }, it = {};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var th; function Av() { if (th) return it; th = 1; var i = Gu(); function t(v) { var p = "https://react.dev/errors/" + v; if (1 < arguments.length) { p += "?args[]=" + encodeURIComponent(arguments[1]); for (var x = 2; x < arguments.length; x++)p += "&args[]=" + encodeURIComponent(arguments[x]) } return "Minified React error #" + v + "; visit " + p + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } function l() { } var a = { d: { f: l, r: function () { throw Error(t(522)) }, D: l, C: l, L: l, m: l, X: l, S: l, M: l }, p: 0, findDOMNode: null }, r = Symbol.for("react.portal"); function d(v, p, x) { var T = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: r, key: T == null ? null : "" + T, children: v, containerInfo: p, implementation: x } } var m = i.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE; function g(v, p) { if (v === "font") return ""; if (typeof p == "string") return p === "use-credentials" ? p : "" } return it.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = a, it.createPortal = function (v, p) { var x = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!p || p.nodeType !== 1 && p.nodeType !== 9 && p.nodeType !== 11) throw Error(t(299)); return d(v, p, null, x) }, it.flushSync = function (v) { var p = m.T, x = a.p; try { if (m.T = null, a.p = 2, v) return v() } finally { m.T = p, a.p = x, a.d.f() } }, it.preconnect = function (v, p) { typeof v == "string" && (p ? (p = p.crossOrigin, p = typeof p == "string" ? p === "use-credentials" ? p : "" : void 0) : p = null, a.d.C(v, p)) }, it.prefetchDNS = function (v) { typeof v == "string" && a.d.D(v) }, it.preinit = function (v, p) { if (typeof v == "string" && p && typeof p.as == "string") { var x = p.as, T = g(x, p.crossOrigin), _ = typeof p.integrity == "string" ? p.integrity : void 0, A = typeof p.fetchPriority == "string" ? p.fetchPriority : void 0; x === "style" ? a.d.S(v, typeof p.precedence == "string" ? p.precedence : void 0, { crossOrigin: T, integrity: _, fetchPriority: A }) : x === "script" && a.d.X(v, { crossOrigin: T, integrity: _, fetchPriority: A, nonce: typeof p.nonce == "string" ? p.nonce : void 0 }) } }, it.preinitModule = function (v, p) { if (typeof v == "string") if (typeof p == "object" && p !== null) { if (p.as == null || p.as === "script") { var x = g(p.as, p.crossOrigin); a.d.M(v, { crossOrigin: x, integrity: typeof p.integrity == "string" ? p.integrity : void 0, nonce: typeof p.nonce == "string" ? p.nonce : void 0 }) } } else p == null && a.d.M(v) }, it.preload = function (v, p) { if (typeof v == "string" && typeof p == "object" && p !== null && typeof p.as == "string") { var x = p.as, T = g(x, p.crossOrigin); a.d.L(v, x, { crossOrigin: T, integrity: typeof p.integrity == "string" ? p.integrity : void 0, nonce: typeof p.nonce == "string" ? p.nonce : void 0, type: typeof p.type == "string" ? p.type : void 0, fetchPriority: typeof p.fetchPriority == "string" ? p.fetchPriority : void 0, referrerPolicy: typeof p.referrerPolicy == "string" ? p.referrerPolicy : void 0, imageSrcSet: typeof p.imageSrcSet == "string" ? p.imageSrcSet : void 0, imageSizes: typeof p.imageSizes == "string" ? p.imageSizes : void 0, media: typeof p.media == "string" ? p.media : void 0 }) } }, it.preloadModule = function (v, p) { if (typeof v == "string") if (p) { var x = g(p.as, p.crossOrigin); a.d.m(v, { as: typeof p.as == "string" && p.as !== "script" ? p.as : void 0, crossOrigin: x, integrity: typeof p.integrity == "string" ? p.integrity : void 0 }) } else a.d.m(v) }, it.requestFormReset = function (v) { a.d.r(v) }, it.unstable_batchedUpdates = function (v, p) { return v(p) }, it.useFormState = function (v, p, x) { return m.H.useFormState(v, p, x) }, it.useFormStatus = function () { return m.H.useHostTransitionStatus() }, it.version = "19.2.3", it } var nh; function Cv() { if (nh) return yu.exports; nh = 1; function i() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(i) } catch (t) { console.error(t) } } return i(), yu.exports = Av(), yu.exports }/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ih; function bv() {
  if (ih) return nl; ih = 1; var i = Ev(), t = Gu(), l = Cv(); function a(e) { var n = "https://react.dev/errors/" + e; if (1 < arguments.length) { n += "?args[]=" + encodeURIComponent(arguments[1]); for (var o = 2; o < arguments.length; o++)n += "&args[]=" + encodeURIComponent(arguments[o]) } return "Minified React error #" + e + "; visit " + n + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } function r(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function d(e) { var n = e, o = e; if (e.alternate) for (; n.return;)n = n.return; else { e = n; do n = e, (n.flags & 4098) !== 0 && (o = n.return), e = n.return; while (e) } return n.tag === 3 ? o : null } function m(e) { if (e.tag === 13) { var n = e.memoizedState; if (n === null && (e = e.alternate, e !== null && (n = e.memoizedState)), n !== null) return n.dehydrated } return null } function g(e) { if (e.tag === 31) { var n = e.memoizedState; if (n === null && (e = e.alternate, e !== null && (n = e.memoizedState)), n !== null) return n.dehydrated } return null } function v(e) { if (d(e) !== e) throw Error(a(188)) } function p(e) { var n = e.alternate; if (!n) { if (n = d(e), n === null) throw Error(a(188)); return n !== e ? null : e } for (var o = e, s = n; ;) { var f = o.return; if (f === null) break; var h = f.alternate; if (h === null) { if (s = f.return, s !== null) { o = s; continue } break } if (f.child === h.child) { for (h = f.child; h;) { if (h === o) return v(f), e; if (h === s) return v(f), n; h = h.sibling } throw Error(a(188)) } if (o.return !== s.return) o = f, s = h; else { for (var S = !1, E = f.child; E;) { if (E === o) { S = !0, o = f, s = h; break } if (E === s) { S = !0, s = f, o = h; break } E = E.sibling } if (!S) { for (E = h.child; E;) { if (E === o) { S = !0, o = h, s = f; break } if (E === s) { S = !0, s = h, o = f; break } E = E.sibling } if (!S) throw Error(a(189)) } } if (o.alternate !== s) throw Error(a(190)) } if (o.tag !== 3) throw Error(a(188)); return o.stateNode.current === o ? e : n } function x(e) { var n = e.tag; if (n === 5 || n === 26 || n === 27 || n === 6) return e; for (e = e.child; e !== null;) { if (n = x(e), n !== null) return n; e = e.sibling } return null } var T = Object.assign, _ = Symbol.for("react.element"), A = Symbol.for("react.transitional.element"), k = Symbol.for("react.portal"), G = Symbol.for("react.fragment"), U = Symbol.for("react.strict_mode"), V = Symbol.for("react.profiler"), W = Symbol.for("react.consumer"), B = Symbol.for("react.context"), K = Symbol.for("react.forward_ref"), ee = Symbol.for("react.suspense"), te = Symbol.for("react.suspense_list"), F = Symbol.for("react.memo"), ge = Symbol.for("react.lazy"), Z = Symbol.for("react.activity"), me = Symbol.for("react.memo_cache_sentinel"), Ae = Symbol.iterator; function Le(e) { return e === null || typeof e != "object" ? null : (e = Ae && e[Ae] || e["@@iterator"], typeof e == "function" ? e : null) } var _e = Symbol.for("react.client.reference"); function Oe(e) { if (e == null) return null; if (typeof e == "function") return e.$$typeof === _e ? null : e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case G: return "Fragment"; case V: return "Profiler"; case U: return "StrictMode"; case ee: return "Suspense"; case te: return "SuspenseList"; case Z: return "Activity" }if (typeof e == "object") switch (e.$$typeof) { case k: return "Portal"; case B: return e.displayName || "Context"; case W: return (e._context.displayName || "Context") + ".Consumer"; case K: var n = e.render; return e = e.displayName, e || (e = n.displayName || n.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case F: return n = e.displayName || null, n !== null ? n : Oe(e.type) || "Memo"; case ge: n = e._payload, e = e._init; try { return Oe(e(n)) } catch { } }return null } var ut = Array.isArray, L = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, O = l.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ie = { pending: !1, data: null, method: null, action: null }, Ne = [], Ie = -1; function N(e) { return { current: e } } function P(e) { 0 > Ie || (e.current = Ne[Ie], Ne[Ie] = null, Ie--) } function Y(e, n) { Ie++, Ne[Ie] = e.current, e.current = n } var Q = N(null), se = N(null), ce = N(null), Ee = N(null); function lt(e, n) { switch (Y(ce, n), Y(se, e), Y(Q, null), n.nodeType) { case 9: case 11: e = (e = n.documentElement) && (e = e.namespaceURI) ? vm(e) : 0; break; default: if (e = n.tagName, n = n.namespaceURI) n = vm(n), e = xm(n, e); else switch (e) { case "svg": e = 1; break; case "math": e = 2; break; default: e = 0 } }P(Q), Y(Q, e) } function Pe() { P(Q), P(se), P(ce) } function so(e) { e.memoizedState !== null && Y(Ee, e); var n = Q.current, o = xm(n, e.type); n !== o && (Y(se, e), Y(Q, o)) } function sl(e) { se.current === e && (P(Q), P(se)), Ee.current === e && (P(Ee), jo._currentValue = ie) } var Ka, Wu; function Jn(e) {
    if (Ka === void 0) try { throw Error() } catch (o) {
      var n = o.stack.trim().match(/\n( *(at )?)/); Ka = n && n[1] || "", Wu = -1 < o.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < o.stack.indexOf("@") ? "@unknown:0:0" : ""
    } return `
`+ Ka + e + Wu
  } var Xa = !1; function Qa(e, n) {
    if (!e || Xa) return ""; Xa = !0; var o = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try {
      var s = { DetermineComponentFrameRoot: function () { try { if (n) { var H = function () { throw Error() }; if (Object.defineProperty(H.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(H, []) } catch (D) { var I = D } Reflect.construct(e, [], H) } else { try { H.call() } catch (D) { I = D } e.call(H.prototype) } } else { try { throw Error() } catch (D) { I = D } (H = e()) && typeof H.catch == "function" && H.catch(function () { }) } } catch (D) { if (D && I && typeof D.stack == "string") return [D.stack, I.stack] } return [null, null] } }; s.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot"; var f = Object.getOwnPropertyDescriptor(s.DetermineComponentFrameRoot, "name"); f && f.configurable && Object.defineProperty(s.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" }); var h = s.DetermineComponentFrameRoot(), S = h[0], E = h[1]; if (S && E) {
        var C = S.split(`
`), R = E.split(`
`); for (f = s = 0; s < C.length && !C[s].includes("DetermineComponentFrameRoot");)s++; for (; f < R.length && !R[f].includes("DetermineComponentFrameRoot");)f++; if (s === C.length || f === R.length) for (s = C.length - 1, f = R.length - 1; 1 <= s && 0 <= f && C[s] !== R[f];)f--; for (; 1 <= s && 0 <= f; s--, f--)if (C[s] !== R[f]) {
          if (s !== 1 || f !== 1) do if (s--, f--, 0 > f || C[s] !== R[f]) {
            var z = `
`+ C[s].replace(" at new ", " at "); return e.displayName && z.includes("<anonymous>") && (z = z.replace("<anonymous>", e.displayName)), z
          } while (1 <= s && 0 <= f); break
        }
      }
    } finally { Xa = !1, Error.prepareStackTrace = o } return (o = e ? e.displayName || e.name : "") ? Jn(o) : ""
  } function Qg(e, n) { switch (e.tag) { case 26: case 27: case 5: return Jn(e.type); case 16: return Jn("Lazy"); case 13: return e.child !== n && n !== null ? Jn("Suspense Fallback") : Jn("Suspense"); case 19: return Jn("SuspenseList"); case 0: case 15: return Qa(e.type, !1); case 11: return Qa(e.type.render, !1); case 1: return Qa(e.type, !0); case 31: return Jn("Activity"); default: return "" } } function Ku(e) {
    try { var n = "", o = null; do n += Qg(e, o), o = e, e = e.return; while (e); return n } catch (s) {
      return `
Error generating stack: `+ s.message + `
`+ s.stack
    }
  } var ja = Object.prototype.hasOwnProperty, Za = i.unstable_scheduleCallback, $a = i.unstable_cancelCallback, jg = i.unstable_shouldYield, Zg = i.unstable_requestPaint, yt = i.unstable_now, $g = i.unstable_getCurrentPriorityLevel, Xu = i.unstable_ImmediatePriority, Qu = i.unstable_UserBlockingPriority, rl = i.unstable_NormalPriority, ey = i.unstable_LowPriority, ju = i.unstable_IdlePriority, ty = i.log, ny = i.unstable_setDisableYieldValue, ro = null, vt = null; function Sn(e) { if (typeof ty == "function" && ny(e), vt && typeof vt.setStrictMode == "function") try { vt.setStrictMode(ro, e) } catch { } } var xt = Math.clz32 ? Math.clz32 : ly, iy = Math.log, oy = Math.LN2; function ly(e) { return e >>>= 0, e === 0 ? 32 : 31 - (iy(e) / oy | 0) | 0 } var ul = 256, cl = 262144, dl = 4194304; function Wn(e) { var n = e & 42; if (n !== 0) return n; switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: return 64; case 128: return 128; case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: return e & 261888; case 262144: case 524288: case 1048576: case 2097152: return e & 3932160; case 4194304: case 8388608: case 16777216: case 33554432: return e & 62914560; case 67108864: return 67108864; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 0; default: return e } } function fl(e, n, o) { var s = e.pendingLanes; if (s === 0) return 0; var f = 0, h = e.suspendedLanes, S = e.pingedLanes; e = e.warmLanes; var E = s & 134217727; return E !== 0 ? (s = E & ~h, s !== 0 ? f = Wn(s) : (S &= E, S !== 0 ? f = Wn(S) : o || (o = E & ~e, o !== 0 && (f = Wn(o))))) : (E = s & ~h, E !== 0 ? f = Wn(E) : S !== 0 ? f = Wn(S) : o || (o = s & ~e, o !== 0 && (f = Wn(o)))), f === 0 ? 0 : n !== 0 && n !== f && (n & h) === 0 && (h = f & -f, o = n & -n, h >= o || h === 32 && (o & 4194048) !== 0) ? n : f } function uo(e, n) { return (e.pendingLanes & ~(e.suspendedLanes & ~e.pingedLanes) & n) === 0 } function ay(e, n) { switch (e) { case 1: case 2: case 4: case 8: case 64: return n + 250; case 16: case 32: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return n + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: return -1; case 67108864: case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function Zu() { var e = dl; return dl <<= 1, (dl & 62914560) === 0 && (dl = 4194304), e } function es(e) { for (var n = [], o = 0; 31 > o; o++)n.push(e); return n } function co(e, n) { e.pendingLanes |= n, n !== 268435456 && (e.suspendedLanes = 0, e.pingedLanes = 0, e.warmLanes = 0) } function sy(e, n, o, s, f, h) { var S = e.pendingLanes; e.pendingLanes = o, e.suspendedLanes = 0, e.pingedLanes = 0, e.warmLanes = 0, e.expiredLanes &= o, e.entangledLanes &= o, e.errorRecoveryDisabledLanes &= o, e.shellSuspendCounter = 0; var E = e.entanglements, C = e.expirationTimes, R = e.hiddenUpdates; for (o = S & ~o; 0 < o;) { var z = 31 - xt(o), H = 1 << z; E[z] = 0, C[z] = -1; var I = R[z]; if (I !== null) for (R[z] = null, z = 0; z < I.length; z++) { var D = I[z]; D !== null && (D.lane &= -536870913) } o &= ~H } s !== 0 && $u(e, s, 0), h !== 0 && f === 0 && e.tag !== 0 && (e.suspendedLanes |= h & ~(S & ~n)) } function $u(e, n, o) { e.pendingLanes |= n, e.suspendedLanes &= ~n; var s = 31 - xt(n); e.entangledLanes |= n, e.entanglements[s] = e.entanglements[s] | 1073741824 | o & 261930 } function ec(e, n) { var o = e.entangledLanes |= n; for (e = e.entanglements; o;) { var s = 31 - xt(o), f = 1 << s; f & n | e[s] & n && (e[s] |= n), o &= ~f } } function tc(e, n) { var o = n & -n; return o = (o & 42) !== 0 ? 1 : ts(o), (o & (e.suspendedLanes | n)) !== 0 ? 0 : o } function ts(e) { switch (e) { case 2: e = 1; break; case 8: e = 4; break; case 32: e = 16; break; case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: e = 128; break; case 268435456: e = 134217728; break; default: e = 0 }return e } function ns(e) { return e &= -e, 2 < e ? 8 < e ? (e & 134217727) !== 0 ? 32 : 268435456 : 8 : 2 } function nc() { var e = O.p; return e !== 0 ? e : (e = window.event, e === void 0 ? 32 : Bm(e.type)) } function ic(e, n) { var o = O.p; try { return O.p = e, n() } finally { O.p = o } } var Tn = Math.random().toString(36).slice(2), Ze = "__reactFiber$" + Tn, ct = "__reactProps$" + Tn, hi = "__reactContainer$" + Tn, is = "__reactEvents$" + Tn, ry = "__reactListeners$" + Tn, uy = "__reactHandles$" + Tn, oc = "__reactResources$" + Tn, fo = "__reactMarker$" + Tn; function os(e) { delete e[Ze], delete e[ct], delete e[is], delete e[ry], delete e[uy] } function pi(e) { var n = e[Ze]; if (n) return n; for (var o = e.parentNode; o;) { if (n = o[hi] || o[Ze]) { if (o = n.alternate, n.child !== null || o !== null && o.child !== null) for (e = bm(e); e !== null;) { if (o = e[Ze]) return o; e = bm(e) } return n } e = o, o = e.parentNode } return null } function gi(e) { if (e = e[Ze] || e[hi]) { var n = e.tag; if (n === 5 || n === 6 || n === 13 || n === 31 || n === 26 || n === 27 || n === 3) return e } return null } function mo(e) { var n = e.tag; if (n === 5 || n === 26 || n === 27 || n === 6) return e.stateNode; throw Error(a(33)) } function yi(e) { var n = e[oc]; return n || (n = e[oc] = { hoistableStyles: new Map, hoistableScripts: new Map }), n } function Xe(e) { e[fo] = !0 } var lc = new Set, ac = {}; function Kn(e, n) { vi(e, n), vi(e + "Capture", n) } function vi(e, n) { for (ac[e] = n, e = 0; e < n.length; e++)lc.add(n[e]) } var cy = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), sc = {}, rc = {}; function dy(e) { return ja.call(rc, e) ? !0 : ja.call(sc, e) ? !1 : cy.test(e) ? rc[e] = !0 : (sc[e] = !0, !1) } function ml(e, n, o) { if (dy(n)) if (o === null) e.removeAttribute(n); else { switch (typeof o) { case "undefined": case "function": case "symbol": e.removeAttribute(n); return; case "boolean": var s = n.toLowerCase().slice(0, 5); if (s !== "data-" && s !== "aria-") { e.removeAttribute(n); return } }e.setAttribute(n, "" + o) } } function hl(e, n, o) { if (o === null) e.removeAttribute(n); else { switch (typeof o) { case "undefined": case "function": case "symbol": case "boolean": e.removeAttribute(n); return }e.setAttribute(n, "" + o) } } function Zt(e, n, o, s) { if (s === null) e.removeAttribute(o); else { switch (typeof s) { case "undefined": case "function": case "symbol": case "boolean": e.removeAttribute(o); return }e.setAttributeNS(n, o, "" + s) } } function Nt(e) { switch (typeof e) { case "bigint": case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function uc(e) { var n = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (n === "checkbox" || n === "radio") } function fy(e, n, o) { var s = Object.getOwnPropertyDescriptor(e.constructor.prototype, n); if (!e.hasOwnProperty(n) && typeof s < "u" && typeof s.get == "function" && typeof s.set == "function") { var f = s.get, h = s.set; return Object.defineProperty(e, n, { configurable: !0, get: function () { return f.call(this) }, set: function (S) { o = "" + S, h.call(this, S) } }), Object.defineProperty(e, n, { enumerable: s.enumerable }), { getValue: function () { return o }, setValue: function (S) { o = "" + S }, stopTracking: function () { e._valueTracker = null, delete e[n] } } } } function ls(e) { if (!e._valueTracker) { var n = uc(e) ? "checked" : "value"; e._valueTracker = fy(e, n, "" + e[n]) } } function cc(e) { if (!e) return !1; var n = e._valueTracker; if (!n) return !0; var o = n.getValue(), s = ""; return e && (s = uc(e) ? e.checked ? "true" : "false" : e.value), e = s, e !== o ? (n.setValue(e), !0) : !1 } function pl(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } var my = /[\n"\\]/g; function wt(e) { return e.replace(my, function (n) { return "\\" + n.charCodeAt(0).toString(16) + " " }) } function as(e, n, o, s, f, h, S, E) { e.name = "", S != null && typeof S != "function" && typeof S != "symbol" && typeof S != "boolean" ? e.type = S : e.removeAttribute("type"), n != null ? S === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + Nt(n)) : e.value !== "" + Nt(n) && (e.value = "" + Nt(n)) : S !== "submit" && S !== "reset" || e.removeAttribute("value"), n != null ? ss(e, S, Nt(n)) : o != null ? ss(e, S, Nt(o)) : s != null && e.removeAttribute("value"), f == null && h != null && (e.defaultChecked = !!h), f != null && (e.checked = f && typeof f != "function" && typeof f != "symbol"), E != null && typeof E != "function" && typeof E != "symbol" && typeof E != "boolean" ? e.name = "" + Nt(E) : e.removeAttribute("name") } function dc(e, n, o, s, f, h, S, E) { if (h != null && typeof h != "function" && typeof h != "symbol" && typeof h != "boolean" && (e.type = h), n != null || o != null) { if (!(h !== "submit" && h !== "reset" || n != null)) { ls(e); return } o = o != null ? "" + Nt(o) : "", n = n != null ? "" + Nt(n) : o, E || n === e.value || (e.value = n), e.defaultValue = n } s = s ?? f, s = typeof s != "function" && typeof s != "symbol" && !!s, e.checked = E ? e.checked : !!s, e.defaultChecked = !!s, S != null && typeof S != "function" && typeof S != "symbol" && typeof S != "boolean" && (e.name = S), ls(e) } function ss(e, n, o) { n === "number" && pl(e.ownerDocument) === e || e.defaultValue === "" + o || (e.defaultValue = "" + o) } function xi(e, n, o, s) { if (e = e.options, n) { n = {}; for (var f = 0; f < o.length; f++)n["$" + o[f]] = !0; for (o = 0; o < e.length; o++)f = n.hasOwnProperty("$" + e[o].value), e[o].selected !== f && (e[o].selected = f), f && s && (e[o].defaultSelected = !0) } else { for (o = "" + Nt(o), n = null, f = 0; f < e.length; f++) { if (e[f].value === o) { e[f].selected = !0, s && (e[f].defaultSelected = !0); return } n !== null || e[f].disabled || (n = e[f]) } n !== null && (n.selected = !0) } } function fc(e, n, o) { if (n != null && (n = "" + Nt(n), n !== e.value && (e.value = n), o == null)) { e.defaultValue !== n && (e.defaultValue = n); return } e.defaultValue = o != null ? "" + Nt(o) : "" } function mc(e, n, o, s) { if (n == null) { if (s != null) { if (o != null) throw Error(a(92)); if (ut(s)) { if (1 < s.length) throw Error(a(93)); s = s[0] } o = s } o == null && (o = ""), n = o } o = Nt(n), e.defaultValue = o, s = e.textContent, s === o && s !== "" && s !== null && (e.value = s), ls(e) } function Si(e, n) { if (n) { var o = e.firstChild; if (o && o === e.lastChild && o.nodeType === 3) { o.nodeValue = n; return } } e.textContent = n } var hy = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")); function hc(e, n, o) { var s = n.indexOf("--") === 0; o == null || typeof o == "boolean" || o === "" ? s ? e.setProperty(n, "") : n === "float" ? e.cssFloat = "" : e[n] = "" : s ? e.setProperty(n, o) : typeof o != "number" || o === 0 || hy.has(n) ? n === "float" ? e.cssFloat = o : e[n] = ("" + o).trim() : e[n] = o + "px" } function pc(e, n, o) { if (n != null && typeof n != "object") throw Error(a(62)); if (e = e.style, o != null) { for (var s in o) !o.hasOwnProperty(s) || n != null && n.hasOwnProperty(s) || (s.indexOf("--") === 0 ? e.setProperty(s, "") : s === "float" ? e.cssFloat = "" : e[s] = ""); for (var f in n) s = n[f], n.hasOwnProperty(f) && o[f] !== s && hc(e, f, s) } else for (var h in n) n.hasOwnProperty(h) && hc(e, h, n[h]) } function rs(e) { if (e.indexOf("-") === -1) return !1; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var py = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]]), gy = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i; function gl(e) { return gy.test("" + e) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : e } function $t() { } var us = null; function cs(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var Ti = null, _i = null; function gc(e) { var n = gi(e); if (n && (e = n.stateNode)) { var o = e[ct] || null; e: switch (e = n.stateNode, n.type) { case "input": if (as(e, o.value, o.defaultValue, o.defaultValue, o.checked, o.defaultChecked, o.type, o.name), n = o.name, o.type === "radio" && n != null) { for (o = e; o.parentNode;)o = o.parentNode; for (o = o.querySelectorAll('input[name="' + wt("" + n) + '"][type="radio"]'), n = 0; n < o.length; n++) { var s = o[n]; if (s !== e && s.form === e.form) { var f = s[ct] || null; if (!f) throw Error(a(90)); as(s, f.value, f.defaultValue, f.defaultValue, f.checked, f.defaultChecked, f.type, f.name) } } for (n = 0; n < o.length; n++)s = o[n], s.form === e.form && cc(s) } break e; case "textarea": fc(e, o.value, o.defaultValue); break e; case "select": n = o.value, n != null && xi(e, !!o.multiple, n, !1) } } } var ds = !1; function yc(e, n, o) { if (ds) return e(n, o); ds = !0; try { var s = e(n); return s } finally { if (ds = !1, (Ti !== null || _i !== null) && (ia(), Ti && (n = Ti, e = _i, _i = Ti = null, gc(n), e))) for (n = 0; n < e.length; n++)gc(e[n]) } } function ho(e, n) { var o = e.stateNode; if (o === null) return null; var s = o[ct] || null; if (s === null) return null; o = s[n]; e: switch (n) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (s = !s.disabled) || (e = e.type, s = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !s; break e; default: e = !1 }if (e) return null; if (o && typeof o != "function") throw Error(a(231, n, typeof o)); return o } var en = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), fs = !1; if (en) try { var po = {}; Object.defineProperty(po, "passive", { get: function () { fs = !0 } }), window.addEventListener("test", po, po), window.removeEventListener("test", po, po) } catch { fs = !1 } var _n = null, ms = null, yl = null; function vc() { if (yl) return yl; var e, n = ms, o = n.length, s, f = "value" in _n ? _n.value : _n.textContent, h = f.length; for (e = 0; e < o && n[e] === f[e]; e++); var S = o - e; for (s = 1; s <= S && n[o - s] === f[h - s]; s++); return yl = f.slice(e, 1 < s ? 1 - s : void 0) } function vl(e) { var n = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && n === 13 && (e = 13)) : e = n, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function xl() { return !0 } function xc() { return !1 } function dt(e) { function n(o, s, f, h, S) { this._reactName = o, this._targetInst = f, this.type = s, this.nativeEvent = h, this.target = S, this.currentTarget = null; for (var E in e) e.hasOwnProperty(E) && (o = e[E], this[E] = o ? o(h) : h[E]); return this.isDefaultPrevented = (h.defaultPrevented != null ? h.defaultPrevented : h.returnValue === !1) ? xl : xc, this.isPropagationStopped = xc, this } return T(n.prototype, { preventDefault: function () { this.defaultPrevented = !0; var o = this.nativeEvent; o && (o.preventDefault ? o.preventDefault() : typeof o.returnValue != "unknown" && (o.returnValue = !1), this.isDefaultPrevented = xl) }, stopPropagation: function () { var o = this.nativeEvent; o && (o.stopPropagation ? o.stopPropagation() : typeof o.cancelBubble != "unknown" && (o.cancelBubble = !0), this.isPropagationStopped = xl) }, persist: function () { }, isPersistent: xl }), n } var Xn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Sl = dt(Xn), go = T({}, Xn, { view: 0, detail: 0 }), yy = dt(go), hs, ps, yo, Tl = T({}, go, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: ys, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== yo && (yo && e.type === "mousemove" ? (hs = e.screenX - yo.screenX, ps = e.screenY - yo.screenY) : ps = hs = 0, yo = e), hs) }, movementY: function (e) { return "movementY" in e ? e.movementY : ps } }), Sc = dt(Tl), vy = T({}, Tl, { dataTransfer: 0 }), xy = dt(vy), Sy = T({}, go, { relatedTarget: 0 }), gs = dt(Sy), Ty = T({}, Xn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), _y = dt(Ty), Ey = T({}, Xn, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), Ay = dt(Ey), Cy = T({}, Xn, { data: 0 }), Tc = dt(Cy), by = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Ny = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, wy = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function My(e) { var n = this.nativeEvent; return n.getModifierState ? n.getModifierState(e) : (e = wy[e]) ? !!n[e] : !1 } function ys() { return My } var Ry = T({}, go, { key: function (e) { if (e.key) { var n = by[e.key] || e.key; if (n !== "Unidentified") return n } return e.type === "keypress" ? (e = vl(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? Ny[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: ys, charCode: function (e) { return e.type === "keypress" ? vl(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? vl(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), Iy = dt(Ry), ky = T({}, Tl, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), _c = dt(ky), Dy = T({}, go, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: ys }), Uy = dt(Dy), Gy = T({}, Xn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Ly = dt(Gy), zy = T({}, Tl, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), qy = dt(zy), Hy = T({}, Xn, { newState: 0, oldState: 0 }), Py = dt(Hy), Vy = [9, 13, 27, 32], vs = en && "CompositionEvent" in window, vo = null; en && "documentMode" in document && (vo = document.documentMode); var By = en && "TextEvent" in window && !vo, Ec = en && (!vs || vo && 8 < vo && 11 >= vo), Ac = " ", Cc = !1; function bc(e, n) { switch (e) { case "keyup": return Vy.indexOf(n.keyCode) !== -1; case "keydown": return n.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Nc(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var Ei = !1; function Oy(e, n) { switch (e) { case "compositionend": return Nc(n); case "keypress": return n.which !== 32 ? null : (Cc = !0, Ac); case "textInput": return e = n.data, e === Ac && Cc ? null : e; default: return null } } function Fy(e, n) { if (Ei) return e === "compositionend" || !vs && bc(e, n) ? (e = vc(), yl = ms = _n = null, Ei = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(n.ctrlKey || n.altKey || n.metaKey) || n.ctrlKey && n.altKey) { if (n.char && 1 < n.char.length) return n.char; if (n.which) return String.fromCharCode(n.which) } return null; case "compositionend": return Ec && n.locale !== "ko" ? null : n.data; default: return null } } var Yy = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function wc(e) { var n = e && e.nodeName && e.nodeName.toLowerCase(); return n === "input" ? !!Yy[e.type] : n === "textarea" } function Mc(e, n, o, s) { Ti ? _i ? _i.push(s) : _i = [s] : Ti = s, n = ca(n, "onChange"), 0 < n.length && (o = new Sl("onChange", "change", null, o, s), e.push({ event: o, listeners: n })) } var xo = null, So = null; function Jy(e) { fm(e, 0) } function _l(e) { var n = mo(e); if (cc(n)) return e } function Rc(e, n) { if (e === "change") return n } var Ic = !1; if (en) { var xs; if (en) { var Ss = "oninput" in document; if (!Ss) { var kc = document.createElement("div"); kc.setAttribute("oninput", "return;"), Ss = typeof kc.oninput == "function" } xs = Ss } else xs = !1; Ic = xs && (!document.documentMode || 9 < document.documentMode) } function Dc() { xo && (xo.detachEvent("onpropertychange", Uc), So = xo = null) } function Uc(e) { if (e.propertyName === "value" && _l(So)) { var n = []; Mc(n, So, e, cs(e)), yc(Jy, n) } } function Wy(e, n, o) { e === "focusin" ? (Dc(), xo = n, So = o, xo.attachEvent("onpropertychange", Uc)) : e === "focusout" && Dc() } function Ky(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return _l(So) } function Xy(e, n) { if (e === "click") return _l(n) } function Qy(e, n) { if (e === "input" || e === "change") return _l(n) } function jy(e, n) { return e === n && (e !== 0 || 1 / e === 1 / n) || e !== e && n !== n } var St = typeof Object.is == "function" ? Object.is : jy; function To(e, n) { if (St(e, n)) return !0; if (typeof e != "object" || e === null || typeof n != "object" || n === null) return !1; var o = Object.keys(e), s = Object.keys(n); if (o.length !== s.length) return !1; for (s = 0; s < o.length; s++) { var f = o[s]; if (!ja.call(n, f) || !St(e[f], n[f])) return !1 } return !0 } function Gc(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function Lc(e, n) { var o = Gc(e); e = 0; for (var s; o;) { if (o.nodeType === 3) { if (s = e + o.textContent.length, e <= n && s >= n) return { node: o, offset: n - e }; e = s } e: { for (; o;) { if (o.nextSibling) { o = o.nextSibling; break e } o = o.parentNode } o = void 0 } o = Gc(o) } } function zc(e, n) { return e && n ? e === n ? !0 : e && e.nodeType === 3 ? !1 : n && n.nodeType === 3 ? zc(e, n.parentNode) : "contains" in e ? e.contains(n) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(n) & 16) : !1 : !1 } function qc(e) { e = e != null && e.ownerDocument != null && e.ownerDocument.defaultView != null ? e.ownerDocument.defaultView : window; for (var n = pl(e.document); n instanceof e.HTMLIFrameElement;) { try { var o = typeof n.contentWindow.location.href == "string" } catch { o = !1 } if (o) e = n.contentWindow; else break; n = pl(e.document) } return n } function Ts(e) { var n = e && e.nodeName && e.nodeName.toLowerCase(); return n && (n === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || n === "textarea" || e.contentEditable === "true") } var Zy = en && "documentMode" in document && 11 >= document.documentMode, Ai = null, _s = null, _o = null, Es = !1; function Hc(e, n, o) { var s = o.window === o ? o.document : o.nodeType === 9 ? o : o.ownerDocument; Es || Ai == null || Ai !== pl(s) || (s = Ai, "selectionStart" in s && Ts(s) ? s = { start: s.selectionStart, end: s.selectionEnd } : (s = (s.ownerDocument && s.ownerDocument.defaultView || window).getSelection(), s = { anchorNode: s.anchorNode, anchorOffset: s.anchorOffset, focusNode: s.focusNode, focusOffset: s.focusOffset }), _o && To(_o, s) || (_o = s, s = ca(_s, "onSelect"), 0 < s.length && (n = new Sl("onSelect", "select", null, n, o), e.push({ event: n, listeners: s }), n.target = Ai))) } function Qn(e, n) { var o = {}; return o[e.toLowerCase()] = n.toLowerCase(), o["Webkit" + e] = "webkit" + n, o["Moz" + e] = "moz" + n, o } var Ci = { animationend: Qn("Animation", "AnimationEnd"), animationiteration: Qn("Animation", "AnimationIteration"), animationstart: Qn("Animation", "AnimationStart"), transitionrun: Qn("Transition", "TransitionRun"), transitionstart: Qn("Transition", "TransitionStart"), transitioncancel: Qn("Transition", "TransitionCancel"), transitionend: Qn("Transition", "TransitionEnd") }, As = {}, Pc = {}; en && (Pc = document.createElement("div").style, "AnimationEvent" in window || (delete Ci.animationend.animation, delete Ci.animationiteration.animation, delete Ci.animationstart.animation), "TransitionEvent" in window || delete Ci.transitionend.transition); function jn(e) { if (As[e]) return As[e]; if (!Ci[e]) return e; var n = Ci[e], o; for (o in n) if (n.hasOwnProperty(o) && o in Pc) return As[e] = n[o]; return e } var Vc = jn("animationend"), Bc = jn("animationiteration"), Oc = jn("animationstart"), $y = jn("transitionrun"), e0 = jn("transitionstart"), t0 = jn("transitioncancel"), Fc = jn("transitionend"), Yc = new Map, Cs = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); Cs.push("scrollEnd"); function Vt(e, n) { Yc.set(e, n), Kn(n, [e]) } var El = typeof reportError == "function" ? reportError : function (e) { if (typeof window == "object" && typeof window.ErrorEvent == "function") { var n = new window.ErrorEvent("error", { bubbles: !0, cancelable: !0, message: typeof e == "object" && e !== null && typeof e.message == "string" ? String(e.message) : String(e), error: e }); if (!window.dispatchEvent(n)) return } else if (typeof process == "object" && typeof process.emit == "function") { process.emit("uncaughtException", e); return } console.error(e) }, Mt = [], bi = 0, bs = 0; function Al() { for (var e = bi, n = bs = bi = 0; n < e;) { var o = Mt[n]; Mt[n++] = null; var s = Mt[n]; Mt[n++] = null; var f = Mt[n]; Mt[n++] = null; var h = Mt[n]; if (Mt[n++] = null, s !== null && f !== null) { var S = s.pending; S === null ? f.next = f : (f.next = S.next, S.next = f), s.pending = f } h !== 0 && Jc(o, f, h) } } function Cl(e, n, o, s) { Mt[bi++] = e, Mt[bi++] = n, Mt[bi++] = o, Mt[bi++] = s, bs |= s, e.lanes |= s, e = e.alternate, e !== null && (e.lanes |= s) } function Ns(e, n, o, s) { return Cl(e, n, o, s), bl(e) } function Zn(e, n) { return Cl(e, null, null, n), bl(e) } function Jc(e, n, o) { e.lanes |= o; var s = e.alternate; s !== null && (s.lanes |= o); for (var f = !1, h = e.return; h !== null;)h.childLanes |= o, s = h.alternate, s !== null && (s.childLanes |= o), h.tag === 22 && (e = h.stateNode, e === null || e._visibility & 1 || (f = !0)), e = h, h = h.return; return e.tag === 3 ? (h = e.stateNode, f && n !== null && (f = 31 - xt(o), e = h.hiddenUpdates, s = e[f], s === null ? e[f] = [n] : s.push(n), n.lane = o | 536870912), h) : null } function bl(e) { if (50 < Fo) throw Fo = 0, Lr = null, Error(a(185)); for (var n = e.return; n !== null;)e = n, n = e.return; return e.tag === 3 ? e.stateNode : null } var Ni = {}; function n0(e, n, o, s) { this.tag = e, this.key = o, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = n, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = s, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Tt(e, n, o, s) { return new n0(e, n, o, s) } function ws(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function tn(e, n) { var o = e.alternate; return o === null ? (o = Tt(e.tag, n, e.key, e.mode), o.elementType = e.elementType, o.type = e.type, o.stateNode = e.stateNode, o.alternate = e, e.alternate = o) : (o.pendingProps = n, o.type = e.type, o.flags = 0, o.subtreeFlags = 0, o.deletions = null), o.flags = e.flags & 65011712, o.childLanes = e.childLanes, o.lanes = e.lanes, o.child = e.child, o.memoizedProps = e.memoizedProps, o.memoizedState = e.memoizedState, o.updateQueue = e.updateQueue, n = e.dependencies, o.dependencies = n === null ? null : { lanes: n.lanes, firstContext: n.firstContext }, o.sibling = e.sibling, o.index = e.index, o.ref = e.ref, o.refCleanup = e.refCleanup, o } function Wc(e, n) { e.flags &= 65011714; var o = e.alternate; return o === null ? (e.childLanes = 0, e.lanes = n, e.child = null, e.subtreeFlags = 0, e.memoizedProps = null, e.memoizedState = null, e.updateQueue = null, e.dependencies = null, e.stateNode = null) : (e.childLanes = o.childLanes, e.lanes = o.lanes, e.child = o.child, e.subtreeFlags = 0, e.deletions = null, e.memoizedProps = o.memoizedProps, e.memoizedState = o.memoizedState, e.updateQueue = o.updateQueue, e.type = o.type, n = o.dependencies, e.dependencies = n === null ? null : { lanes: n.lanes, firstContext: n.firstContext }), e } function Nl(e, n, o, s, f, h) { var S = 0; if (s = e, typeof e == "function") ws(e) && (S = 1); else if (typeof e == "string") S = sv(e, o, Q.current) ? 26 : e === "html" || e === "head" || e === "body" ? 27 : 5; else e: switch (e) { case Z: return e = Tt(31, o, n, f), e.elementType = Z, e.lanes = h, e; case G: return $n(o.children, f, h, n); case U: S = 8, f |= 24; break; case V: return e = Tt(12, o, n, f | 2), e.elementType = V, e.lanes = h, e; case ee: return e = Tt(13, o, n, f), e.elementType = ee, e.lanes = h, e; case te: return e = Tt(19, o, n, f), e.elementType = te, e.lanes = h, e; default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case B: S = 10; break e; case W: S = 9; break e; case K: S = 11; break e; case F: S = 14; break e; case ge: S = 16, s = null; break e }S = 29, o = Error(a(130, e === null ? "null" : typeof e, "")), s = null }return n = Tt(S, o, n, f), n.elementType = e, n.type = s, n.lanes = h, n } function $n(e, n, o, s) { return e = Tt(7, e, s, n), e.lanes = o, e } function Ms(e, n, o) { return e = Tt(6, e, null, n), e.lanes = o, e } function Kc(e) { var n = Tt(18, null, null, 0); return n.stateNode = e, n } function Rs(e, n, o) { return n = Tt(4, e.children !== null ? e.children : [], e.key, n), n.lanes = o, n.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, n } var Xc = new WeakMap; function Rt(e, n) { if (typeof e == "object" && e !== null) { var o = Xc.get(e); return o !== void 0 ? o : (n = { value: e, source: n, stack: Ku(n) }, Xc.set(e, n), n) } return { value: e, source: n, stack: Ku(n) } } var wi = [], Mi = 0, wl = null, Eo = 0, It = [], kt = 0, En = null, Kt = 1, Xt = ""; function nn(e, n) { wi[Mi++] = Eo, wi[Mi++] = wl, wl = e, Eo = n } function Qc(e, n, o) { It[kt++] = Kt, It[kt++] = Xt, It[kt++] = En, En = e; var s = Kt; e = Xt; var f = 32 - xt(s) - 1; s &= ~(1 << f), o += 1; var h = 32 - xt(n) + f; if (30 < h) { var S = f - f % 5; h = (s & (1 << S) - 1).toString(32), s >>= S, f -= S, Kt = 1 << 32 - xt(n) + f | o << f | s, Xt = h + e } else Kt = 1 << h | o << f | s, Xt = e } function Is(e) { e.return !== null && (nn(e, 1), Qc(e, 1, 0)) } function ks(e) { for (; e === wl;)wl = wi[--Mi], wi[Mi] = null, Eo = wi[--Mi], wi[Mi] = null; for (; e === En;)En = It[--kt], It[kt] = null, Xt = It[--kt], It[kt] = null, Kt = It[--kt], It[kt] = null } function jc(e, n) { It[kt++] = Kt, It[kt++] = Xt, It[kt++] = En, Kt = n.id, Xt = n.overflow, En = e } var $e = null, De = null, ye = !1, An = null, Dt = !1, Ds = Error(a(519)); function Cn(e) { var n = Error(a(418, 1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML", "")); throw Ao(Rt(n, e)), Ds } function Zc(e) { var n = e.stateNode, o = e.type, s = e.memoizedProps; switch (n[Ze] = e, n[ct] = s, o) { case "dialog": fe("cancel", n), fe("close", n); break; case "iframe": case "object": case "embed": fe("load", n); break; case "video": case "audio": for (o = 0; o < Jo.length; o++)fe(Jo[o], n); break; case "source": fe("error", n); break; case "img": case "image": case "link": fe("error", n), fe("load", n); break; case "details": fe("toggle", n); break; case "input": fe("invalid", n), dc(n, s.value, s.defaultValue, s.checked, s.defaultChecked, s.type, s.name, !0); break; case "select": fe("invalid", n); break; case "textarea": fe("invalid", n), mc(n, s.value, s.defaultValue, s.children) }o = s.children, typeof o != "string" && typeof o != "number" && typeof o != "bigint" || n.textContent === "" + o || s.suppressHydrationWarning === !0 || gm(n.textContent, o) ? (s.popover != null && (fe("beforetoggle", n), fe("toggle", n)), s.onScroll != null && fe("scroll", n), s.onScrollEnd != null && fe("scrollend", n), s.onClick != null && (n.onclick = $t), n = !0) : n = !1, n || Cn(e, !0) } function $c(e) { for ($e = e.return; $e;)switch ($e.tag) { case 5: case 31: case 13: Dt = !1; return; case 27: case 3: Dt = !0; return; default: $e = $e.return } } function Ri(e) { if (e !== $e) return !1; if (!ye) return $c(e), ye = !0, !1; var n = e.tag, o; if ((o = n !== 3 && n !== 27) && ((o = n === 5) && (o = e.type, o = !(o !== "form" && o !== "button") || jr(e.type, e.memoizedProps)), o = !o), o && De && Cn(e), $c(e), n === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(a(317)); De = Cm(e) } else if (n === 31) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(a(317)); De = Cm(e) } else n === 27 ? (n = De, Hn(e.type) ? (e = nu, nu = null, De = e) : De = n) : De = $e ? Gt(e.stateNode.nextSibling) : null; return !0 } function ei() { De = $e = null, ye = !1 } function Us() { var e = An; return e !== null && (pt === null ? pt = e : pt.push.apply(pt, e), An = null), e } function Ao(e) { An === null ? An = [e] : An.push(e) } var Gs = N(null), ti = null, on = null; function bn(e, n, o) { Y(Gs, n._currentValue), n._currentValue = o } function ln(e) { e._currentValue = Gs.current, P(Gs) } function Ls(e, n, o) { for (; e !== null;) { var s = e.alternate; if ((e.childLanes & n) !== n ? (e.childLanes |= n, s !== null && (s.childLanes |= n)) : s !== null && (s.childLanes & n) !== n && (s.childLanes |= n), e === o) break; e = e.return } } function zs(e, n, o, s) { var f = e.child; for (f !== null && (f.return = e); f !== null;) { var h = f.dependencies; if (h !== null) { var S = f.child; h = h.firstContext; e: for (; h !== null;) { var E = h; h = f; for (var C = 0; C < n.length; C++)if (E.context === n[C]) { h.lanes |= o, E = h.alternate, E !== null && (E.lanes |= o), Ls(h.return, o, e), s || (S = null); break e } h = E.next } } else if (f.tag === 18) { if (S = f.return, S === null) throw Error(a(341)); S.lanes |= o, h = S.alternate, h !== null && (h.lanes |= o), Ls(S, o, e), S = null } else S = f.child; if (S !== null) S.return = f; else for (S = f; S !== null;) { if (S === e) { S = null; break } if (f = S.sibling, f !== null) { f.return = S.return, S = f; break } S = S.return } f = S } } function Ii(e, n, o, s) { e = null; for (var f = n, h = !1; f !== null;) { if (!h) { if ((f.flags & 524288) !== 0) h = !0; else if ((f.flags & 262144) !== 0) break } if (f.tag === 10) { var S = f.alternate; if (S === null) throw Error(a(387)); if (S = S.memoizedProps, S !== null) { var E = f.type; St(f.pendingProps.value, S.value) || (e !== null ? e.push(E) : e = [E]) } } else if (f === Ee.current) { if (S = f.alternate, S === null) throw Error(a(387)); S.memoizedState.memoizedState !== f.memoizedState.memoizedState && (e !== null ? e.push(jo) : e = [jo]) } f = f.return } e !== null && zs(n, e, o, s), n.flags |= 262144 } function Ml(e) { for (e = e.firstContext; e !== null;) { if (!St(e.context._currentValue, e.memoizedValue)) return !0; e = e.next } return !1 } function ni(e) { ti = e, on = null, e = e.dependencies, e !== null && (e.firstContext = null) } function et(e) { return ed(ti, e) } function Rl(e, n) { return ti === null && ni(e), ed(e, n) } function ed(e, n) { var o = n._currentValue; if (n = { context: n, memoizedValue: o, next: null }, on === null) { if (e === null) throw Error(a(308)); on = n, e.dependencies = { lanes: 0, firstContext: n }, e.flags |= 524288 } else on = on.next = n; return o } var i0 = typeof AbortController < "u" ? AbortController : function () { var e = [], n = this.signal = { aborted: !1, addEventListener: function (o, s) { e.push(s) } }; this.abort = function () { n.aborted = !0, e.forEach(function (o) { return o() }) } }, o0 = i.unstable_scheduleCallback, l0 = i.unstable_NormalPriority, Fe = { $$typeof: B, Consumer: null, Provider: null, _currentValue: null, _currentValue2: null, _threadCount: 0 }; function qs() { return { controller: new i0, data: new Map, refCount: 0 } } function Co(e) { e.refCount--, e.refCount === 0 && o0(l0, function () { e.controller.abort() }) } var bo = null, Hs = 0, ki = 0, Di = null; function a0(e, n) { if (bo === null) { var o = bo = []; Hs = 0, ki = Br(), Di = { status: "pending", value: void 0, then: function (s) { o.push(s) } } } return Hs++, n.then(td, td), n } function td() { if (--Hs === 0 && bo !== null) { Di !== null && (Di.status = "fulfilled"); var e = bo; bo = null, ki = 0, Di = null; for (var n = 0; n < e.length; n++)(0, e[n])() } } function s0(e, n) { var o = [], s = { status: "pending", value: null, reason: null, then: function (f) { o.push(f) } }; return e.then(function () { s.status = "fulfilled", s.value = n; for (var f = 0; f < o.length; f++)(0, o[f])(n) }, function (f) { for (s.status = "rejected", s.reason = f, f = 0; f < o.length; f++)(0, o[f])(void 0) }), s } var nd = L.S; L.S = function (e, n) { Pf = yt(), typeof n == "object" && n !== null && typeof n.then == "function" && a0(e, n), nd !== null && nd(e, n) }; var ii = N(null); function Ps() { var e = ii.current; return e !== null ? e : ke.pooledCache } function Il(e, n) { n === null ? Y(ii, ii.current) : Y(ii, n.pool) } function id() { var e = Ps(); return e === null ? null : { parent: Fe._currentValue, pool: e } } var Ui = Error(a(460)), Vs = Error(a(474)), kl = Error(a(542)), Dl = { then: function () { } }; function od(e) { return e = e.status, e === "fulfilled" || e === "rejected" } function ld(e, n, o) { switch (o = e[o], o === void 0 ? e.push(n) : o !== n && (n.then($t, $t), n = o), n.status) { case "fulfilled": return n.value; case "rejected": throw e = n.reason, sd(e), e; default: if (typeof n.status == "string") n.then($t, $t); else { if (e = ke, e !== null && 100 < e.shellSuspendCounter) throw Error(a(482)); e = n, e.status = "pending", e.then(function (s) { if (n.status === "pending") { var f = n; f.status = "fulfilled", f.value = s } }, function (s) { if (n.status === "pending") { var f = n; f.status = "rejected", f.reason = s } }) } switch (n.status) { case "fulfilled": return n.value; case "rejected": throw e = n.reason, sd(e), e }throw li = n, Ui } } function oi(e) { try { var n = e._init; return n(e._payload) } catch (o) { throw o !== null && typeof o == "object" && typeof o.then == "function" ? (li = o, Ui) : o } } var li = null; function ad() { if (li === null) throw Error(a(459)); var e = li; return li = null, e } function sd(e) { if (e === Ui || e === kl) throw Error(a(483)) } var Gi = null, No = 0; function Ul(e) { var n = No; return No += 1, Gi === null && (Gi = []), ld(Gi, e, n) } function wo(e, n) { n = n.props.ref, e.ref = n !== void 0 ? n : null } function Gl(e, n) { throw n.$$typeof === _ ? Error(a(525)) : (e = Object.prototype.toString.call(n), Error(a(31, e === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : e))) } function rd(e) { function n(w, b) { if (e) { var M = w.deletions; M === null ? (w.deletions = [b], w.flags |= 16) : M.push(b) } } function o(w, b) { if (!e) return null; for (; b !== null;)n(w, b), b = b.sibling; return null } function s(w) { for (var b = new Map; w !== null;)w.key !== null ? b.set(w.key, w) : b.set(w.index, w), w = w.sibling; return b } function f(w, b) { return w = tn(w, b), w.index = 0, w.sibling = null, w } function h(w, b, M) { return w.index = M, e ? (M = w.alternate, M !== null ? (M = M.index, M < b ? (w.flags |= 67108866, b) : M) : (w.flags |= 67108866, b)) : (w.flags |= 1048576, b) } function S(w) { return e && w.alternate === null && (w.flags |= 67108866), w } function E(w, b, M, q) { return b === null || b.tag !== 6 ? (b = Ms(M, w.mode, q), b.return = w, b) : (b = f(b, M), b.return = w, b) } function C(w, b, M, q) { var $ = M.type; return $ === G ? z(w, b, M.props.children, q, M.key) : b !== null && (b.elementType === $ || typeof $ == "object" && $ !== null && $.$$typeof === ge && oi($) === b.type) ? (b = f(b, M.props), wo(b, M), b.return = w, b) : (b = Nl(M.type, M.key, M.props, null, w.mode, q), wo(b, M), b.return = w, b) } function R(w, b, M, q) { return b === null || b.tag !== 4 || b.stateNode.containerInfo !== M.containerInfo || b.stateNode.implementation !== M.implementation ? (b = Rs(M, w.mode, q), b.return = w, b) : (b = f(b, M.children || []), b.return = w, b) } function z(w, b, M, q, $) { return b === null || b.tag !== 7 ? (b = $n(M, w.mode, q, $), b.return = w, b) : (b = f(b, M), b.return = w, b) } function H(w, b, M) { if (typeof b == "string" && b !== "" || typeof b == "number" || typeof b == "bigint") return b = Ms("" + b, w.mode, M), b.return = w, b; if (typeof b == "object" && b !== null) { switch (b.$$typeof) { case A: return M = Nl(b.type, b.key, b.props, null, w.mode, M), wo(M, b), M.return = w, M; case k: return b = Rs(b, w.mode, M), b.return = w, b; case ge: return b = oi(b), H(w, b, M) }if (ut(b) || Le(b)) return b = $n(b, w.mode, M, null), b.return = w, b; if (typeof b.then == "function") return H(w, Ul(b), M); if (b.$$typeof === B) return H(w, Rl(w, b), M); Gl(w, b) } return null } function I(w, b, M, q) { var $ = b !== null ? b.key : null; if (typeof M == "string" && M !== "" || typeof M == "number" || typeof M == "bigint") return $ !== null ? null : E(w, b, "" + M, q); if (typeof M == "object" && M !== null) { switch (M.$$typeof) { case A: return M.key === $ ? C(w, b, M, q) : null; case k: return M.key === $ ? R(w, b, M, q) : null; case ge: return M = oi(M), I(w, b, M, q) }if (ut(M) || Le(M)) return $ !== null ? null : z(w, b, M, q, null); if (typeof M.then == "function") return I(w, b, Ul(M), q); if (M.$$typeof === B) return I(w, b, Rl(w, M), q); Gl(w, M) } return null } function D(w, b, M, q, $) { if (typeof q == "string" && q !== "" || typeof q == "number" || typeof q == "bigint") return w = w.get(M) || null, E(b, w, "" + q, $); if (typeof q == "object" && q !== null) { switch (q.$$typeof) { case A: return w = w.get(q.key === null ? M : q.key) || null, C(b, w, q, $); case k: return w = w.get(q.key === null ? M : q.key) || null, R(b, w, q, $); case ge: return q = oi(q), D(w, b, M, q, $) }if (ut(q) || Le(q)) return w = w.get(M) || null, z(b, w, q, $, null); if (typeof q.then == "function") return D(w, b, M, Ul(q), $); if (q.$$typeof === B) return D(w, b, M, Rl(b, q), $); Gl(b, q) } return null } function X(w, b, M, q) { for (var $ = null, ve = null, j = b, ue = b = 0, pe = null; j !== null && ue < M.length; ue++) { j.index > ue ? (pe = j, j = null) : pe = j.sibling; var xe = I(w, j, M[ue], q); if (xe === null) { j === null && (j = pe); break } e && j && xe.alternate === null && n(w, j), b = h(xe, b, ue), ve === null ? $ = xe : ve.sibling = xe, ve = xe, j = pe } if (ue === M.length) return o(w, j), ye && nn(w, ue), $; if (j === null) { for (; ue < M.length; ue++)j = H(w, M[ue], q), j !== null && (b = h(j, b, ue), ve === null ? $ = j : ve.sibling = j, ve = j); return ye && nn(w, ue), $ } for (j = s(j); ue < M.length; ue++)pe = D(j, w, ue, M[ue], q), pe !== null && (e && pe.alternate !== null && j.delete(pe.key === null ? ue : pe.key), b = h(pe, b, ue), ve === null ? $ = pe : ve.sibling = pe, ve = pe); return e && j.forEach(function (Fn) { return n(w, Fn) }), ye && nn(w, ue), $ } function ne(w, b, M, q) { if (M == null) throw Error(a(151)); for (var $ = null, ve = null, j = b, ue = b = 0, pe = null, xe = M.next(); j !== null && !xe.done; ue++, xe = M.next()) { j.index > ue ? (pe = j, j = null) : pe = j.sibling; var Fn = I(w, j, xe.value, q); if (Fn === null) { j === null && (j = pe); break } e && j && Fn.alternate === null && n(w, j), b = h(Fn, b, ue), ve === null ? $ = Fn : ve.sibling = Fn, ve = Fn, j = pe } if (xe.done) return o(w, j), ye && nn(w, ue), $; if (j === null) { for (; !xe.done; ue++, xe = M.next())xe = H(w, xe.value, q), xe !== null && (b = h(xe, b, ue), ve === null ? $ = xe : ve.sibling = xe, ve = xe); return ye && nn(w, ue), $ } for (j = s(j); !xe.done; ue++, xe = M.next())xe = D(j, w, ue, xe.value, q), xe !== null && (e && xe.alternate !== null && j.delete(xe.key === null ? ue : xe.key), b = h(xe, b, ue), ve === null ? $ = xe : ve.sibling = xe, ve = xe); return e && j.forEach(function (vv) { return n(w, vv) }), ye && nn(w, ue), $ } function Re(w, b, M, q) { if (typeof M == "object" && M !== null && M.type === G && M.key === null && (M = M.props.children), typeof M == "object" && M !== null) { switch (M.$$typeof) { case A: e: { for (var $ = M.key; b !== null;) { if (b.key === $) { if ($ = M.type, $ === G) { if (b.tag === 7) { o(w, b.sibling), q = f(b, M.props.children), q.return = w, w = q; break e } } else if (b.elementType === $ || typeof $ == "object" && $ !== null && $.$$typeof === ge && oi($) === b.type) { o(w, b.sibling), q = f(b, M.props), wo(q, M), q.return = w, w = q; break e } o(w, b); break } else n(w, b); b = b.sibling } M.type === G ? (q = $n(M.props.children, w.mode, q, M.key), q.return = w, w = q) : (q = Nl(M.type, M.key, M.props, null, w.mode, q), wo(q, M), q.return = w, w = q) } return S(w); case k: e: { for ($ = M.key; b !== null;) { if (b.key === $) if (b.tag === 4 && b.stateNode.containerInfo === M.containerInfo && b.stateNode.implementation === M.implementation) { o(w, b.sibling), q = f(b, M.children || []), q.return = w, w = q; break e } else { o(w, b); break } else n(w, b); b = b.sibling } q = Rs(M, w.mode, q), q.return = w, w = q } return S(w); case ge: return M = oi(M), Re(w, b, M, q) }if (ut(M)) return X(w, b, M, q); if (Le(M)) { if ($ = Le(M), typeof $ != "function") throw Error(a(150)); return M = $.call(M), ne(w, b, M, q) } if (typeof M.then == "function") return Re(w, b, Ul(M), q); if (M.$$typeof === B) return Re(w, b, Rl(w, M), q); Gl(w, M) } return typeof M == "string" && M !== "" || typeof M == "number" || typeof M == "bigint" ? (M = "" + M, b !== null && b.tag === 6 ? (o(w, b.sibling), q = f(b, M), q.return = w, w = q) : (o(w, b), q = Ms(M, w.mode, q), q.return = w, w = q), S(w)) : o(w, b) } return function (w, b, M, q) { try { No = 0; var $ = Re(w, b, M, q); return Gi = null, $ } catch (j) { if (j === Ui || j === kl) throw j; var ve = Tt(29, j, null, w.mode); return ve.lanes = q, ve.return = w, ve } finally { } } } var ai = rd(!0), ud = rd(!1), Nn = !1; function Bs(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, lanes: 0, hiddenCallbacks: null }, callbacks: null } } function Os(e, n) { e = e.updateQueue, n.updateQueue === e && (n.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, callbacks: null }) } function wn(e) { return { lane: e, tag: 0, payload: null, callback: null, next: null } } function Mn(e, n, o) { var s = e.updateQueue; if (s === null) return null; if (s = s.shared, (Te & 2) !== 0) { var f = s.pending; return f === null ? n.next = n : (n.next = f.next, f.next = n), s.pending = n, n = bl(e), Jc(e, null, o), n } return Cl(e, s, n, o), bl(e) } function Mo(e, n, o) { if (n = n.updateQueue, n !== null && (n = n.shared, (o & 4194048) !== 0)) { var s = n.lanes; s &= e.pendingLanes, o |= s, n.lanes = o, ec(e, o) } } function Fs(e, n) { var o = e.updateQueue, s = e.alternate; if (s !== null && (s = s.updateQueue, o === s)) { var f = null, h = null; if (o = o.firstBaseUpdate, o !== null) { do { var S = { lane: o.lane, tag: o.tag, payload: o.payload, callback: null, next: null }; h === null ? f = h = S : h = h.next = S, o = o.next } while (o !== null); h === null ? f = h = n : h = h.next = n } else f = h = n; o = { baseState: s.baseState, firstBaseUpdate: f, lastBaseUpdate: h, shared: s.shared, callbacks: s.callbacks }, e.updateQueue = o; return } e = o.lastBaseUpdate, e === null ? o.firstBaseUpdate = n : e.next = n, o.lastBaseUpdate = n } var Ys = !1; function Ro() { if (Ys) { var e = Di; if (e !== null) throw e } } function Io(e, n, o, s) { Ys = !1; var f = e.updateQueue; Nn = !1; var h = f.firstBaseUpdate, S = f.lastBaseUpdate, E = f.shared.pending; if (E !== null) { f.shared.pending = null; var C = E, R = C.next; C.next = null, S === null ? h = R : S.next = R, S = C; var z = e.alternate; z !== null && (z = z.updateQueue, E = z.lastBaseUpdate, E !== S && (E === null ? z.firstBaseUpdate = R : E.next = R, z.lastBaseUpdate = C)) } if (h !== null) { var H = f.baseState; S = 0, z = R = C = null, E = h; do { var I = E.lane & -536870913, D = I !== E.lane; if (D ? (he & I) === I : (s & I) === I) { I !== 0 && I === ki && (Ys = !0), z !== null && (z = z.next = { lane: 0, tag: E.tag, payload: E.payload, callback: null, next: null }); e: { var X = e, ne = E; I = n; var Re = o; switch (ne.tag) { case 1: if (X = ne.payload, typeof X == "function") { H = X.call(Re, H, I); break e } H = X; break e; case 3: X.flags = X.flags & -65537 | 128; case 0: if (X = ne.payload, I = typeof X == "function" ? X.call(Re, H, I) : X, I == null) break e; H = T({}, H, I); break e; case 2: Nn = !0 } } I = E.callback, I !== null && (e.flags |= 64, D && (e.flags |= 8192), D = f.callbacks, D === null ? f.callbacks = [I] : D.push(I)) } else D = { lane: I, tag: E.tag, payload: E.payload, callback: E.callback, next: null }, z === null ? (R = z = D, C = H) : z = z.next = D, S |= I; if (E = E.next, E === null) { if (E = f.shared.pending, E === null) break; D = E, E = D.next, D.next = null, f.lastBaseUpdate = D, f.shared.pending = null } } while (!0); z === null && (C = H), f.baseState = C, f.firstBaseUpdate = R, f.lastBaseUpdate = z, h === null && (f.shared.lanes = 0), Un |= S, e.lanes = S, e.memoizedState = H } } function cd(e, n) { if (typeof e != "function") throw Error(a(191, e)); e.call(n) } function dd(e, n) { var o = e.callbacks; if (o !== null) for (e.callbacks = null, e = 0; e < o.length; e++)cd(o[e], n) } var Li = N(null), Ll = N(0); function fd(e, n) { e = hn, Y(Ll, e), Y(Li, n), hn = e | n.baseLanes } function Js() { Y(Ll, hn), Y(Li, Li.current) } function Ws() { hn = Ll.current, P(Li), P(Ll) } var _t = N(null), Ut = null; function Rn(e) { var n = e.alternate; Y(Ve, Ve.current & 1), Y(_t, e), Ut === null && (n === null || Li.current !== null || n.memoizedState !== null) && (Ut = e) } function Ks(e) { Y(Ve, Ve.current), Y(_t, e), Ut === null && (Ut = e) } function md(e) { e.tag === 22 ? (Y(Ve, Ve.current), Y(_t, e), Ut === null && (Ut = e)) : In() } function In() { Y(Ve, Ve.current), Y(_t, _t.current) } function Et(e) { P(_t), Ut === e && (Ut = null), P(Ve) } var Ve = N(0); function zl(e) { for (var n = e; n !== null;) { if (n.tag === 13) { var o = n.memoizedState; if (o !== null && (o = o.dehydrated, o === null || eu(o) || tu(o))) return n } else if (n.tag === 19 && (n.memoizedProps.revealOrder === "forwards" || n.memoizedProps.revealOrder === "backwards" || n.memoizedProps.revealOrder === "unstable_legacy-backwards" || n.memoizedProps.revealOrder === "together")) { if ((n.flags & 128) !== 0) return n } else if (n.child !== null) { n.child.return = n, n = n.child; continue } if (n === e) break; for (; n.sibling === null;) { if (n.return === null || n.return === e) return null; n = n.return } n.sibling.return = n.return, n = n.sibling } return null } var an = 0, re = null, we = null, Ye = null, ql = !1, zi = !1, si = !1, Hl = 0, ko = 0, qi = null, r0 = 0; function qe() { throw Error(a(321)) } function Xs(e, n) { if (n === null) return !1; for (var o = 0; o < n.length && o < e.length; o++)if (!St(e[o], n[o])) return !1; return !0 } function Qs(e, n, o, s, f, h) { return an = h, re = n, n.memoizedState = null, n.updateQueue = null, n.lanes = 0, L.H = e === null || e.memoizedState === null ? Qd : dr, si = !1, h = o(s, f), si = !1, zi && (h = pd(n, o, s, f)), hd(e), h } function hd(e) { L.H = Go; var n = we !== null && we.next !== null; if (an = 0, Ye = we = re = null, ql = !1, ko = 0, qi = null, n) throw Error(a(300)); e === null || Je || (e = e.dependencies, e !== null && Ml(e) && (Je = !0)) } function pd(e, n, o, s) { re = e; var f = 0; do { if (zi && (qi = null), ko = 0, zi = !1, 25 <= f) throw Error(a(301)); if (f += 1, Ye = we = null, e.updateQueue != null) { var h = e.updateQueue; h.lastEffect = null, h.events = null, h.stores = null, h.memoCache != null && (h.memoCache.index = 0) } L.H = jd, h = n(o, s) } while (zi); return h } function u0() { var e = L.H, n = e.useState()[0]; return n = typeof n.then == "function" ? Do(n) : n, e = e.useState()[0], (we !== null ? we.memoizedState : null) !== e && (re.flags |= 1024), n } function js() { var e = Hl !== 0; return Hl = 0, e } function Zs(e, n, o) { n.updateQueue = e.updateQueue, n.flags &= -2053, e.lanes &= ~o } function $s(e) { if (ql) { for (e = e.memoizedState; e !== null;) { var n = e.queue; n !== null && (n.pending = null), e = e.next } ql = !1 } an = 0, Ye = we = re = null, zi = !1, ko = Hl = 0, qi = null } function at() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Ye === null ? re.memoizedState = Ye = e : Ye = Ye.next = e, Ye } function Be() { if (we === null) { var e = re.alternate; e = e !== null ? e.memoizedState : null } else e = we.next; var n = Ye === null ? re.memoizedState : Ye.next; if (n !== null) Ye = n, we = e; else { if (e === null) throw re.alternate === null ? Error(a(467)) : Error(a(310)); we = e, e = { memoizedState: we.memoizedState, baseState: we.baseState, baseQueue: we.baseQueue, queue: we.queue, next: null }, Ye === null ? re.memoizedState = Ye = e : Ye = Ye.next = e } return Ye } function Pl() { return { lastEffect: null, events: null, stores: null, memoCache: null } } function Do(e) { var n = ko; return ko += 1, qi === null && (qi = []), e = ld(qi, e, n), n = re, (Ye === null ? n.memoizedState : Ye.next) === null && (n = n.alternate, L.H = n === null || n.memoizedState === null ? Qd : dr), e } function Vl(e) { if (e !== null && typeof e == "object") { if (typeof e.then == "function") return Do(e); if (e.$$typeof === B) return et(e) } throw Error(a(438, String(e))) } function er(e) { var n = null, o = re.updateQueue; if (o !== null && (n = o.memoCache), n == null) { var s = re.alternate; s !== null && (s = s.updateQueue, s !== null && (s = s.memoCache, s != null && (n = { data: s.data.map(function (f) { return f.slice() }), index: 0 }))) } if (n == null && (n = { data: [], index: 0 }), o === null && (o = Pl(), re.updateQueue = o), o.memoCache = n, o = n.data[n.index], o === void 0) for (o = n.data[n.index] = Array(e), s = 0; s < e; s++)o[s] = me; return n.index++, o } function sn(e, n) { return typeof n == "function" ? n(e) : n } function Bl(e) { var n = Be(); return tr(n, we, e) } function tr(e, n, o) { var s = e.queue; if (s === null) throw Error(a(311)); s.lastRenderedReducer = o; var f = e.baseQueue, h = s.pending; if (h !== null) { if (f !== null) { var S = f.next; f.next = h.next, h.next = S } n.baseQueue = f = h, s.pending = null } if (h = e.baseState, f === null) e.memoizedState = h; else { n = f.next; var E = S = null, C = null, R = n, z = !1; do { var H = R.lane & -536870913; if (H !== R.lane ? (he & H) === H : (an & H) === H) { var I = R.revertLane; if (I === 0) C !== null && (C = C.next = { lane: 0, revertLane: 0, gesture: null, action: R.action, hasEagerState: R.hasEagerState, eagerState: R.eagerState, next: null }), H === ki && (z = !0); else if ((an & I) === I) { R = R.next, I === ki && (z = !0); continue } else H = { lane: 0, revertLane: R.revertLane, gesture: null, action: R.action, hasEagerState: R.hasEagerState, eagerState: R.eagerState, next: null }, C === null ? (E = C = H, S = h) : C = C.next = H, re.lanes |= I, Un |= I; H = R.action, si && o(h, H), h = R.hasEagerState ? R.eagerState : o(h, H) } else I = { lane: H, revertLane: R.revertLane, gesture: R.gesture, action: R.action, hasEagerState: R.hasEagerState, eagerState: R.eagerState, next: null }, C === null ? (E = C = I, S = h) : C = C.next = I, re.lanes |= H, Un |= H; R = R.next } while (R !== null && R !== n); if (C === null ? S = h : C.next = E, !St(h, e.memoizedState) && (Je = !0, z && (o = Di, o !== null))) throw o; e.memoizedState = h, e.baseState = S, e.baseQueue = C, s.lastRenderedState = h } return f === null && (s.lanes = 0), [e.memoizedState, s.dispatch] } function nr(e) { var n = Be(), o = n.queue; if (o === null) throw Error(a(311)); o.lastRenderedReducer = e; var s = o.dispatch, f = o.pending, h = n.memoizedState; if (f !== null) { o.pending = null; var S = f = f.next; do h = e(h, S.action), S = S.next; while (S !== f); St(h, n.memoizedState) || (Je = !0), n.memoizedState = h, n.baseQueue === null && (n.baseState = h), o.lastRenderedState = h } return [h, s] } function gd(e, n, o) { var s = re, f = Be(), h = ye; if (h) { if (o === void 0) throw Error(a(407)); o = o() } else o = n(); var S = !St((we || f).memoizedState, o); if (S && (f.memoizedState = o, Je = !0), f = f.queue, lr(xd.bind(null, s, f, e), [e]), f.getSnapshot !== n || S || Ye !== null && Ye.memoizedState.tag & 1) { if (s.flags |= 2048, Hi(9, { destroy: void 0 }, vd.bind(null, s, f, o, n), null), ke === null) throw Error(a(349)); h || (an & 127) !== 0 || yd(s, n, o) } return o } function yd(e, n, o) { e.flags |= 16384, e = { getSnapshot: n, value: o }, n = re.updateQueue, n === null ? (n = Pl(), re.updateQueue = n, n.stores = [e]) : (o = n.stores, o === null ? n.stores = [e] : o.push(e)) } function vd(e, n, o, s) { n.value = o, n.getSnapshot = s, Sd(n) && Td(e) } function xd(e, n, o) { return o(function () { Sd(n) && Td(e) }) } function Sd(e) { var n = e.getSnapshot; e = e.value; try { var o = n(); return !St(e, o) } catch { return !0 } } function Td(e) { var n = Zn(e, 2); n !== null && gt(n, e, 2) } function ir(e) { var n = at(); if (typeof e == "function") { var o = e; if (e = o(), si) { Sn(!0); try { o() } finally { Sn(!1) } } } return n.memoizedState = n.baseState = e, n.queue = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: sn, lastRenderedState: e }, n } function _d(e, n, o, s) { return e.baseState = o, tr(e, we, typeof s == "function" ? s : sn) } function c0(e, n, o, s, f) { if (Yl(e)) throw Error(a(485)); if (e = n.action, e !== null) { var h = { payload: f, action: e, next: null, isTransition: !0, status: "pending", value: null, reason: null, listeners: [], then: function (S) { h.listeners.push(S) } }; L.T !== null ? o(!0) : h.isTransition = !1, s(h), o = n.pending, o === null ? (h.next = n.pending = h, Ed(n, h)) : (h.next = o.next, n.pending = o.next = h) } } function Ed(e, n) { var o = n.action, s = n.payload, f = e.state; if (n.isTransition) { var h = L.T, S = {}; L.T = S; try { var E = o(f, s), C = L.S; C !== null && C(S, E), Ad(e, n, E) } catch (R) { or(e, n, R) } finally { h !== null && S.types !== null && (h.types = S.types), L.T = h } } else try { h = o(f, s), Ad(e, n, h) } catch (R) { or(e, n, R) } } function Ad(e, n, o) { o !== null && typeof o == "object" && typeof o.then == "function" ? o.then(function (s) { Cd(e, n, s) }, function (s) { return or(e, n, s) }) : Cd(e, n, o) } function Cd(e, n, o) { n.status = "fulfilled", n.value = o, bd(n), e.state = o, n = e.pending, n !== null && (o = n.next, o === n ? e.pending = null : (o = o.next, n.next = o, Ed(e, o))) } function or(e, n, o) { var s = e.pending; if (e.pending = null, s !== null) { s = s.next; do n.status = "rejected", n.reason = o, bd(n), n = n.next; while (n !== s) } e.action = null } function bd(e) { e = e.listeners; for (var n = 0; n < e.length; n++)(0, e[n])() } function Nd(e, n) { return n } function wd(e, n) { if (ye) { var o = ke.formState; if (o !== null) { e: { var s = re; if (ye) { if (De) { t: { for (var f = De, h = Dt; f.nodeType !== 8;) { if (!h) { f = null; break t } if (f = Gt(f.nextSibling), f === null) { f = null; break t } } h = f.data, f = h === "F!" || h === "F" ? f : null } if (f) { De = Gt(f.nextSibling), s = f.data === "F!"; break e } } Cn(s) } s = !1 } s && (n = o[0]) } } return o = at(), o.memoizedState = o.baseState = n, s = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Nd, lastRenderedState: n }, o.queue = s, o = Wd.bind(null, re, s), s.dispatch = o, s = ir(!1), h = cr.bind(null, re, !1, s.queue), s = at(), f = { state: n, dispatch: null, action: e, pending: null }, s.queue = f, o = c0.bind(null, re, f, h, o), f.dispatch = o, s.memoizedState = e, [n, o, !1] } function Md(e) { var n = Be(); return Rd(n, we, e) } function Rd(e, n, o) { if (n = tr(e, n, Nd)[0], e = Bl(sn)[0], typeof n == "object" && n !== null && typeof n.then == "function") try { var s = Do(n) } catch (S) { throw S === Ui ? kl : S } else s = n; n = Be(); var f = n.queue, h = f.dispatch; return o !== n.memoizedState && (re.flags |= 2048, Hi(9, { destroy: void 0 }, d0.bind(null, f, o), null)), [s, h, e] } function d0(e, n) { e.action = n } function Id(e) { var n = Be(), o = we; if (o !== null) return Rd(n, o, e); Be(), n = n.memoizedState, o = Be(); var s = o.queue.dispatch; return o.memoizedState = e, [n, s, !1] } function Hi(e, n, o, s) { return e = { tag: e, create: o, deps: s, inst: n, next: null }, n = re.updateQueue, n === null && (n = Pl(), re.updateQueue = n), o = n.lastEffect, o === null ? n.lastEffect = e.next = e : (s = o.next, o.next = e, e.next = s, n.lastEffect = e), e } function kd() { return Be().memoizedState } function Ol(e, n, o, s) { var f = at(); re.flags |= e, f.memoizedState = Hi(1 | n, { destroy: void 0 }, o, s === void 0 ? null : s) } function Fl(e, n, o, s) { var f = Be(); s = s === void 0 ? null : s; var h = f.memoizedState.inst; we !== null && s !== null && Xs(s, we.memoizedState.deps) ? f.memoizedState = Hi(n, h, o, s) : (re.flags |= e, f.memoizedState = Hi(1 | n, h, o, s)) } function Dd(e, n) { Ol(8390656, 8, e, n) } function lr(e, n) { Fl(2048, 8, e, n) } function f0(e) { re.flags |= 4; var n = re.updateQueue; if (n === null) n = Pl(), re.updateQueue = n, n.events = [e]; else { var o = n.events; o === null ? n.events = [e] : o.push(e) } } function Ud(e) { var n = Be().memoizedState; return f0({ ref: n, nextImpl: e }), function () { if ((Te & 2) !== 0) throw Error(a(440)); return n.impl.apply(void 0, arguments) } } function Gd(e, n) { return Fl(4, 2, e, n) } function Ld(e, n) { return Fl(4, 4, e, n) } function zd(e, n) { if (typeof n == "function") { e = e(); var o = n(e); return function () { typeof o == "function" ? o() : n(null) } } if (n != null) return e = e(), n.current = e, function () { n.current = null } } function qd(e, n, o) { o = o != null ? o.concat([e]) : null, Fl(4, 4, zd.bind(null, n, e), o) } function ar() { } function Hd(e, n) { var o = Be(); n = n === void 0 ? null : n; var s = o.memoizedState; return n !== null && Xs(n, s[1]) ? s[0] : (o.memoizedState = [e, n], e) } function Pd(e, n) { var o = Be(); n = n === void 0 ? null : n; var s = o.memoizedState; if (n !== null && Xs(n, s[1])) return s[0]; if (s = e(), si) { Sn(!0); try { e() } finally { Sn(!1) } } return o.memoizedState = [s, n], s } function sr(e, n, o) { return o === void 0 || (an & 1073741824) !== 0 && (he & 261930) === 0 ? e.memoizedState = n : (e.memoizedState = o, e = Bf(), re.lanes |= e, Un |= e, o) } function Vd(e, n, o, s) { return St(o, n) ? o : Li.current !== null ? (e = sr(e, o, s), St(e, n) || (Je = !0), e) : (an & 42) === 0 || (an & 1073741824) !== 0 && (he & 261930) === 0 ? (Je = !0, e.memoizedState = o) : (e = Bf(), re.lanes |= e, Un |= e, n) } function Bd(e, n, o, s, f) { var h = O.p; O.p = h !== 0 && 8 > h ? h : 8; var S = L.T, E = {}; L.T = E, cr(e, !1, n, o); try { var C = f(), R = L.S; if (R !== null && R(E, C), C !== null && typeof C == "object" && typeof C.then == "function") { var z = s0(C, s); Uo(e, n, z, bt(e)) } else Uo(e, n, s, bt(e)) } catch (H) { Uo(e, n, { then: function () { }, status: "rejected", reason: H }, bt()) } finally { O.p = h, S !== null && E.types !== null && (S.types = E.types), L.T = S } } function m0() { } function rr(e, n, o, s) { if (e.tag !== 5) throw Error(a(476)); var f = Od(e).queue; Bd(e, f, n, ie, o === null ? m0 : function () { return Fd(e), o(s) }) } function Od(e) { var n = e.memoizedState; if (n !== null) return n; n = { memoizedState: ie, baseState: ie, baseQueue: null, queue: { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: sn, lastRenderedState: ie }, next: null }; var o = {}; return n.next = { memoizedState: o, baseState: o, baseQueue: null, queue: { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: sn, lastRenderedState: o }, next: null }, e.memoizedState = n, e = e.alternate, e !== null && (e.memoizedState = n), n } function Fd(e) { var n = Od(e); n.next === null && (n = e.alternate.memoizedState), Uo(e, n.next.queue, {}, bt()) } function ur() { return et(jo) } function Yd() { return Be().memoizedState } function Jd() { return Be().memoizedState } function h0(e) { for (var n = e.return; n !== null;) { switch (n.tag) { case 24: case 3: var o = bt(); e = wn(o); var s = Mn(n, e, o); s !== null && (gt(s, n, o), Mo(s, n, o)), n = { cache: qs() }, e.payload = n; return }n = n.return } } function p0(e, n, o) { var s = bt(); o = { lane: s, revertLane: 0, gesture: null, action: o, hasEagerState: !1, eagerState: null, next: null }, Yl(e) ? Kd(n, o) : (o = Ns(e, n, o, s), o !== null && (gt(o, e, s), Xd(o, n, s))) } function Wd(e, n, o) { var s = bt(); Uo(e, n, o, s) } function Uo(e, n, o, s) { var f = { lane: s, revertLane: 0, gesture: null, action: o, hasEagerState: !1, eagerState: null, next: null }; if (Yl(e)) Kd(n, f); else { var h = e.alternate; if (e.lanes === 0 && (h === null || h.lanes === 0) && (h = n.lastRenderedReducer, h !== null)) try { var S = n.lastRenderedState, E = h(S, o); if (f.hasEagerState = !0, f.eagerState = E, St(E, S)) return Cl(e, n, f, 0), ke === null && Al(), !1 } catch { } finally { } if (o = Ns(e, n, f, s), o !== null) return gt(o, e, s), Xd(o, n, s), !0 } return !1 } function cr(e, n, o, s) { if (s = { lane: 2, revertLane: Br(), gesture: null, action: s, hasEagerState: !1, eagerState: null, next: null }, Yl(e)) { if (n) throw Error(a(479)) } else n = Ns(e, o, s, 2), n !== null && gt(n, e, 2) } function Yl(e) { var n = e.alternate; return e === re || n !== null && n === re } function Kd(e, n) { zi = ql = !0; var o = e.pending; o === null ? n.next = n : (n.next = o.next, o.next = n), e.pending = n } function Xd(e, n, o) { if ((o & 4194048) !== 0) { var s = n.lanes; s &= e.pendingLanes, o |= s, n.lanes = o, ec(e, o) } } var Go = { readContext: et, use: Vl, useCallback: qe, useContext: qe, useEffect: qe, useImperativeHandle: qe, useLayoutEffect: qe, useInsertionEffect: qe, useMemo: qe, useReducer: qe, useRef: qe, useState: qe, useDebugValue: qe, useDeferredValue: qe, useTransition: qe, useSyncExternalStore: qe, useId: qe, useHostTransitionStatus: qe, useFormState: qe, useActionState: qe, useOptimistic: qe, useMemoCache: qe, useCacheRefresh: qe }; Go.useEffectEvent = qe; var Qd = { readContext: et, use: Vl, useCallback: function (e, n) { return at().memoizedState = [e, n === void 0 ? null : n], e }, useContext: et, useEffect: Dd, useImperativeHandle: function (e, n, o) { o = o != null ? o.concat([e]) : null, Ol(4194308, 4, zd.bind(null, n, e), o) }, useLayoutEffect: function (e, n) { return Ol(4194308, 4, e, n) }, useInsertionEffect: function (e, n) { Ol(4, 2, e, n) }, useMemo: function (e, n) { var o = at(); n = n === void 0 ? null : n; var s = e(); if (si) { Sn(!0); try { e() } finally { Sn(!1) } } return o.memoizedState = [s, n], s }, useReducer: function (e, n, o) { var s = at(); if (o !== void 0) { var f = o(n); if (si) { Sn(!0); try { o(n) } finally { Sn(!1) } } } else f = n; return s.memoizedState = s.baseState = f, e = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: f }, s.queue = e, e = e.dispatch = p0.bind(null, re, e), [s.memoizedState, e] }, useRef: function (e) { var n = at(); return e = { current: e }, n.memoizedState = e }, useState: function (e) { e = ir(e); var n = e.queue, o = Wd.bind(null, re, n); return n.dispatch = o, [e.memoizedState, o] }, useDebugValue: ar, useDeferredValue: function (e, n) { var o = at(); return sr(o, e, n) }, useTransition: function () { var e = ir(!1); return e = Bd.bind(null, re, e.queue, !0, !1), at().memoizedState = e, [!1, e] }, useSyncExternalStore: function (e, n, o) { var s = re, f = at(); if (ye) { if (o === void 0) throw Error(a(407)); o = o() } else { if (o = n(), ke === null) throw Error(a(349)); (he & 127) !== 0 || yd(s, n, o) } f.memoizedState = o; var h = { value: o, getSnapshot: n }; return f.queue = h, Dd(xd.bind(null, s, h, e), [e]), s.flags |= 2048, Hi(9, { destroy: void 0 }, vd.bind(null, s, h, o, n), null), o }, useId: function () { var e = at(), n = ke.identifierPrefix; if (ye) { var o = Xt, s = Kt; o = (s & ~(1 << 32 - xt(s) - 1)).toString(32) + o, n = "_" + n + "R_" + o, o = Hl++, 0 < o && (n += "H" + o.toString(32)), n += "_" } else o = r0++, n = "_" + n + "r_" + o.toString(32) + "_"; return e.memoizedState = n }, useHostTransitionStatus: ur, useFormState: wd, useActionState: wd, useOptimistic: function (e) { var n = at(); n.memoizedState = n.baseState = e; var o = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: null, lastRenderedState: null }; return n.queue = o, n = cr.bind(null, re, !0, o), o.dispatch = n, [e, n] }, useMemoCache: er, useCacheRefresh: function () { return at().memoizedState = h0.bind(null, re) }, useEffectEvent: function (e) { var n = at(), o = { impl: e }; return n.memoizedState = o, function () { if ((Te & 2) !== 0) throw Error(a(440)); return o.impl.apply(void 0, arguments) } } }, dr = { readContext: et, use: Vl, useCallback: Hd, useContext: et, useEffect: lr, useImperativeHandle: qd, useInsertionEffect: Gd, useLayoutEffect: Ld, useMemo: Pd, useReducer: Bl, useRef: kd, useState: function () { return Bl(sn) }, useDebugValue: ar, useDeferredValue: function (e, n) { var o = Be(); return Vd(o, we.memoizedState, e, n) }, useTransition: function () { var e = Bl(sn)[0], n = Be().memoizedState; return [typeof e == "boolean" ? e : Do(e), n] }, useSyncExternalStore: gd, useId: Yd, useHostTransitionStatus: ur, useFormState: Md, useActionState: Md, useOptimistic: function (e, n) { var o = Be(); return _d(o, we, e, n) }, useMemoCache: er, useCacheRefresh: Jd }; dr.useEffectEvent = Ud; var jd = { readContext: et, use: Vl, useCallback: Hd, useContext: et, useEffect: lr, useImperativeHandle: qd, useInsertionEffect: Gd, useLayoutEffect: Ld, useMemo: Pd, useReducer: nr, useRef: kd, useState: function () { return nr(sn) }, useDebugValue: ar, useDeferredValue: function (e, n) { var o = Be(); return we === null ? sr(o, e, n) : Vd(o, we.memoizedState, e, n) }, useTransition: function () { var e = nr(sn)[0], n = Be().memoizedState; return [typeof e == "boolean" ? e : Do(e), n] }, useSyncExternalStore: gd, useId: Yd, useHostTransitionStatus: ur, useFormState: Id, useActionState: Id, useOptimistic: function (e, n) { var o = Be(); return we !== null ? _d(o, we, e, n) : (o.baseState = e, [e, o.queue.dispatch]) }, useMemoCache: er, useCacheRefresh: Jd }; jd.useEffectEvent = Ud; function fr(e, n, o, s) { n = e.memoizedState, o = o(s, n), o = o == null ? n : T({}, n, o), e.memoizedState = o, e.lanes === 0 && (e.updateQueue.baseState = o) } var mr = { enqueueSetState: function (e, n, o) { e = e._reactInternals; var s = bt(), f = wn(s); f.payload = n, o != null && (f.callback = o), n = Mn(e, f, s), n !== null && (gt(n, e, s), Mo(n, e, s)) }, enqueueReplaceState: function (e, n, o) { e = e._reactInternals; var s = bt(), f = wn(s); f.tag = 1, f.payload = n, o != null && (f.callback = o), n = Mn(e, f, s), n !== null && (gt(n, e, s), Mo(n, e, s)) }, enqueueForceUpdate: function (e, n) { e = e._reactInternals; var o = bt(), s = wn(o); s.tag = 2, n != null && (s.callback = n), n = Mn(e, s, o), n !== null && (gt(n, e, o), Mo(n, e, o)) } }; function Zd(e, n, o, s, f, h, S) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(s, h, S) : n.prototype && n.prototype.isPureReactComponent ? !To(o, s) || !To(f, h) : !0 } function $d(e, n, o, s) { e = n.state, typeof n.componentWillReceiveProps == "function" && n.componentWillReceiveProps(o, s), typeof n.UNSAFE_componentWillReceiveProps == "function" && n.UNSAFE_componentWillReceiveProps(o, s), n.state !== e && mr.enqueueReplaceState(n, n.state, null) } function ri(e, n) { var o = n; if ("ref" in n) { o = {}; for (var s in n) s !== "ref" && (o[s] = n[s]) } if (e = e.defaultProps) { o === n && (o = T({}, o)); for (var f in e) o[f] === void 0 && (o[f] = e[f]) } return o } function ef(e) { El(e) } function tf(e) { console.error(e) } function nf(e) { El(e) } function Jl(e, n) { try { var o = e.onUncaughtError; o(n.value, { componentStack: n.stack }) } catch (s) { setTimeout(function () { throw s }) } } function of(e, n, o) { try { var s = e.onCaughtError; s(o.value, { componentStack: o.stack, errorBoundary: n.tag === 1 ? n.stateNode : null }) } catch (f) { setTimeout(function () { throw f }) } } function hr(e, n, o) { return o = wn(o), o.tag = 3, o.payload = { element: null }, o.callback = function () { Jl(e, n) }, o } function lf(e) { return e = wn(e), e.tag = 3, e } function af(e, n, o, s) { var f = o.type.getDerivedStateFromError; if (typeof f == "function") { var h = s.value; e.payload = function () { return f(h) }, e.callback = function () { of(n, o, s) } } var S = o.stateNode; S !== null && typeof S.componentDidCatch == "function" && (e.callback = function () { of(n, o, s), typeof f != "function" && (Gn === null ? Gn = new Set([this]) : Gn.add(this)); var E = s.stack; this.componentDidCatch(s.value, { componentStack: E !== null ? E : "" }) }) } function g0(e, n, o, s, f) { if (o.flags |= 32768, s !== null && typeof s == "object" && typeof s.then == "function") { if (n = o.alternate, n !== null && Ii(n, o, f, !0), o = _t.current, o !== null) { switch (o.tag) { case 31: case 13: return Ut === null ? oa() : o.alternate === null && He === 0 && (He = 3), o.flags &= -257, o.flags |= 65536, o.lanes = f, s === Dl ? o.flags |= 16384 : (n = o.updateQueue, n === null ? o.updateQueue = new Set([s]) : n.add(s), Hr(e, s, f)), !1; case 22: return o.flags |= 65536, s === Dl ? o.flags |= 16384 : (n = o.updateQueue, n === null ? (n = { transitions: null, markerInstances: null, retryQueue: new Set([s]) }, o.updateQueue = n) : (o = n.retryQueue, o === null ? n.retryQueue = new Set([s]) : o.add(s)), Hr(e, s, f)), !1 }throw Error(a(435, o.tag)) } return Hr(e, s, f), oa(), !1 } if (ye) return n = _t.current, n !== null ? ((n.flags & 65536) === 0 && (n.flags |= 256), n.flags |= 65536, n.lanes = f, s !== Ds && (e = Error(a(422), { cause: s }), Ao(Rt(e, o)))) : (s !== Ds && (n = Error(a(423), { cause: s }), Ao(Rt(n, o))), e = e.current.alternate, e.flags |= 65536, f &= -f, e.lanes |= f, s = Rt(s, o), f = hr(e.stateNode, s, f), Fs(e, f), He !== 4 && (He = 2)), !1; var h = Error(a(520), { cause: s }); if (h = Rt(h, o), Oo === null ? Oo = [h] : Oo.push(h), He !== 4 && (He = 2), n === null) return !0; s = Rt(s, o), o = n; do { switch (o.tag) { case 3: return o.flags |= 65536, e = f & -f, o.lanes |= e, e = hr(o.stateNode, s, e), Fs(o, e), !1; case 1: if (n = o.type, h = o.stateNode, (o.flags & 128) === 0 && (typeof n.getDerivedStateFromError == "function" || h !== null && typeof h.componentDidCatch == "function" && (Gn === null || !Gn.has(h)))) return o.flags |= 65536, f &= -f, o.lanes |= f, f = lf(f), af(f, e, o, s), Fs(o, f), !1 }o = o.return } while (o !== null); return !1 } var pr = Error(a(461)), Je = !1; function tt(e, n, o, s) { n.child = e === null ? ud(n, null, o, s) : ai(n, e.child, o, s) } function sf(e, n, o, s, f) { o = o.render; var h = n.ref; if ("ref" in s) { var S = {}; for (var E in s) E !== "ref" && (S[E] = s[E]) } else S = s; return ni(n), s = Qs(e, n, o, S, h, f), E = js(), e !== null && !Je ? (Zs(e, n, f), rn(e, n, f)) : (ye && E && Is(n), n.flags |= 1, tt(e, n, s, f), n.child) } function rf(e, n, o, s, f) { if (e === null) { var h = o.type; return typeof h == "function" && !ws(h) && h.defaultProps === void 0 && o.compare === null ? (n.tag = 15, n.type = h, uf(e, n, h, s, f)) : (e = Nl(o.type, null, s, n, n.mode, f), e.ref = n.ref, e.return = n, n.child = e) } if (h = e.child, !Er(e, f)) { var S = h.memoizedProps; if (o = o.compare, o = o !== null ? o : To, o(S, s) && e.ref === n.ref) return rn(e, n, f) } return n.flags |= 1, e = tn(h, s), e.ref = n.ref, e.return = n, n.child = e } function uf(e, n, o, s, f) { if (e !== null) { var h = e.memoizedProps; if (To(h, s) && e.ref === n.ref) if (Je = !1, n.pendingProps = s = h, Er(e, f)) (e.flags & 131072) !== 0 && (Je = !0); else return n.lanes = e.lanes, rn(e, n, f) } return gr(e, n, o, s, f) } function cf(e, n, o, s) { var f = s.children, h = e !== null ? e.memoizedState : null; if (e === null && n.stateNode === null && (n.stateNode = { _visibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null }), s.mode === "hidden") { if ((n.flags & 128) !== 0) { if (h = h !== null ? h.baseLanes | o : o, e !== null) { for (s = n.child = e.child, f = 0; s !== null;)f = f | s.lanes | s.childLanes, s = s.sibling; s = f & ~h } else s = 0, n.child = null; return df(e, n, h, o, s) } if ((o & 536870912) !== 0) n.memoizedState = { baseLanes: 0, cachePool: null }, e !== null && Il(n, h !== null ? h.cachePool : null), h !== null ? fd(n, h) : Js(), md(n); else return s = n.lanes = 536870912, df(e, n, h !== null ? h.baseLanes | o : o, o, s) } else h !== null ? (Il(n, h.cachePool), fd(n, h), In(), n.memoizedState = null) : (e !== null && Il(n, null), Js(), In()); return tt(e, n, f, o), n.child } function Lo(e, n) { return e !== null && e.tag === 22 || n.stateNode !== null || (n.stateNode = { _visibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null }), n.sibling } function df(e, n, o, s, f) { var h = Ps(); return h = h === null ? null : { parent: Fe._currentValue, pool: h }, n.memoizedState = { baseLanes: o, cachePool: h }, e !== null && Il(n, null), Js(), md(n), e !== null && Ii(e, n, s, !0), n.childLanes = f, null } function Wl(e, n) { return n = Xl({ mode: n.mode, children: n.children }, e.mode), n.ref = e.ref, e.child = n, n.return = e, n } function ff(e, n, o) { return ai(n, e.child, null, o), e = Wl(n, n.pendingProps), e.flags |= 2, Et(n), n.memoizedState = null, e } function y0(e, n, o) { var s = n.pendingProps, f = (n.flags & 128) !== 0; if (n.flags &= -129, e === null) { if (ye) { if (s.mode === "hidden") return e = Wl(n, s), n.lanes = 536870912, Lo(null, e); if (Ks(n), (e = De) ? (e = Am(e, Dt), e = e !== null && e.data === "&" ? e : null, e !== null && (n.memoizedState = { dehydrated: e, treeContext: En !== null ? { id: Kt, overflow: Xt } : null, retryLane: 536870912, hydrationErrors: null }, o = Kc(e), o.return = n, n.child = o, $e = n, De = null)) : e = null, e === null) throw Cn(n); return n.lanes = 536870912, null } return Wl(n, s) } var h = e.memoizedState; if (h !== null) { var S = h.dehydrated; if (Ks(n), f) if (n.flags & 256) n.flags &= -257, n = ff(e, n, o); else if (n.memoizedState !== null) n.child = e.child, n.flags |= 128, n = null; else throw Error(a(558)); else if (Je || Ii(e, n, o, !1), f = (o & e.childLanes) !== 0, Je || f) { if (s = ke, s !== null && (S = tc(s, o), S !== 0 && S !== h.retryLane)) throw h.retryLane = S, Zn(e, S), gt(s, e, S), pr; oa(), n = ff(e, n, o) } else e = h.treeContext, De = Gt(S.nextSibling), $e = n, ye = !0, An = null, Dt = !1, e !== null && jc(n, e), n = Wl(n, s), n.flags |= 4096; return n } return e = tn(e.child, { mode: s.mode, children: s.children }), e.ref = n.ref, n.child = e, e.return = n, e } function Kl(e, n) { var o = n.ref; if (o === null) e !== null && e.ref !== null && (n.flags |= 4194816); else { if (typeof o != "function" && typeof o != "object") throw Error(a(284)); (e === null || e.ref !== o) && (n.flags |= 4194816) } } function gr(e, n, o, s, f) { return ni(n), o = Qs(e, n, o, s, void 0, f), s = js(), e !== null && !Je ? (Zs(e, n, f), rn(e, n, f)) : (ye && s && Is(n), n.flags |= 1, tt(e, n, o, f), n.child) } function mf(e, n, o, s, f, h) { return ni(n), n.updateQueue = null, o = pd(n, s, o, f), hd(e), s = js(), e !== null && !Je ? (Zs(e, n, h), rn(e, n, h)) : (ye && s && Is(n), n.flags |= 1, tt(e, n, o, h), n.child) } function hf(e, n, o, s, f) { if (ni(n), n.stateNode === null) { var h = Ni, S = o.contextType; typeof S == "object" && S !== null && (h = et(S)), h = new o(s, h), n.memoizedState = h.state !== null && h.state !== void 0 ? h.state : null, h.updater = mr, n.stateNode = h, h._reactInternals = n, h = n.stateNode, h.props = s, h.state = n.memoizedState, h.refs = {}, Bs(n), S = o.contextType, h.context = typeof S == "object" && S !== null ? et(S) : Ni, h.state = n.memoizedState, S = o.getDerivedStateFromProps, typeof S == "function" && (fr(n, o, S, s), h.state = n.memoizedState), typeof o.getDerivedStateFromProps == "function" || typeof h.getSnapshotBeforeUpdate == "function" || typeof h.UNSAFE_componentWillMount != "function" && typeof h.componentWillMount != "function" || (S = h.state, typeof h.componentWillMount == "function" && h.componentWillMount(), typeof h.UNSAFE_componentWillMount == "function" && h.UNSAFE_componentWillMount(), S !== h.state && mr.enqueueReplaceState(h, h.state, null), Io(n, s, h, f), Ro(), h.state = n.memoizedState), typeof h.componentDidMount == "function" && (n.flags |= 4194308), s = !0 } else if (e === null) { h = n.stateNode; var E = n.memoizedProps, C = ri(o, E); h.props = C; var R = h.context, z = o.contextType; S = Ni, typeof z == "object" && z !== null && (S = et(z)); var H = o.getDerivedStateFromProps; z = typeof H == "function" || typeof h.getSnapshotBeforeUpdate == "function", E = n.pendingProps !== E, z || typeof h.UNSAFE_componentWillReceiveProps != "function" && typeof h.componentWillReceiveProps != "function" || (E || R !== S) && $d(n, h, s, S), Nn = !1; var I = n.memoizedState; h.state = I, Io(n, s, h, f), Ro(), R = n.memoizedState, E || I !== R || Nn ? (typeof H == "function" && (fr(n, o, H, s), R = n.memoizedState), (C = Nn || Zd(n, o, C, s, I, R, S)) ? (z || typeof h.UNSAFE_componentWillMount != "function" && typeof h.componentWillMount != "function" || (typeof h.componentWillMount == "function" && h.componentWillMount(), typeof h.UNSAFE_componentWillMount == "function" && h.UNSAFE_componentWillMount()), typeof h.componentDidMount == "function" && (n.flags |= 4194308)) : (typeof h.componentDidMount == "function" && (n.flags |= 4194308), n.memoizedProps = s, n.memoizedState = R), h.props = s, h.state = R, h.context = S, s = C) : (typeof h.componentDidMount == "function" && (n.flags |= 4194308), s = !1) } else { h = n.stateNode, Os(e, n), S = n.memoizedProps, z = ri(o, S), h.props = z, H = n.pendingProps, I = h.context, R = o.contextType, C = Ni, typeof R == "object" && R !== null && (C = et(R)), E = o.getDerivedStateFromProps, (R = typeof E == "function" || typeof h.getSnapshotBeforeUpdate == "function") || typeof h.UNSAFE_componentWillReceiveProps != "function" && typeof h.componentWillReceiveProps != "function" || (S !== H || I !== C) && $d(n, h, s, C), Nn = !1, I = n.memoizedState, h.state = I, Io(n, s, h, f), Ro(); var D = n.memoizedState; S !== H || I !== D || Nn || e !== null && e.dependencies !== null && Ml(e.dependencies) ? (typeof E == "function" && (fr(n, o, E, s), D = n.memoizedState), (z = Nn || Zd(n, o, z, s, I, D, C) || e !== null && e.dependencies !== null && Ml(e.dependencies)) ? (R || typeof h.UNSAFE_componentWillUpdate != "function" && typeof h.componentWillUpdate != "function" || (typeof h.componentWillUpdate == "function" && h.componentWillUpdate(s, D, C), typeof h.UNSAFE_componentWillUpdate == "function" && h.UNSAFE_componentWillUpdate(s, D, C)), typeof h.componentDidUpdate == "function" && (n.flags |= 4), typeof h.getSnapshotBeforeUpdate == "function" && (n.flags |= 1024)) : (typeof h.componentDidUpdate != "function" || S === e.memoizedProps && I === e.memoizedState || (n.flags |= 4), typeof h.getSnapshotBeforeUpdate != "function" || S === e.memoizedProps && I === e.memoizedState || (n.flags |= 1024), n.memoizedProps = s, n.memoizedState = D), h.props = s, h.state = D, h.context = C, s = z) : (typeof h.componentDidUpdate != "function" || S === e.memoizedProps && I === e.memoizedState || (n.flags |= 4), typeof h.getSnapshotBeforeUpdate != "function" || S === e.memoizedProps && I === e.memoizedState || (n.flags |= 1024), s = !1) } return h = s, Kl(e, n), s = (n.flags & 128) !== 0, h || s ? (h = n.stateNode, o = s && typeof o.getDerivedStateFromError != "function" ? null : h.render(), n.flags |= 1, e !== null && s ? (n.child = ai(n, e.child, null, f), n.child = ai(n, null, o, f)) : tt(e, n, o, f), n.memoizedState = h.state, e = n.child) : e = rn(e, n, f), e } function pf(e, n, o, s) { return ei(), n.flags |= 256, tt(e, n, o, s), n.child } var yr = { dehydrated: null, treeContext: null, retryLane: 0, hydrationErrors: null }; function vr(e) { return { baseLanes: e, cachePool: id() } } function xr(e, n, o) { return e = e !== null ? e.childLanes & ~o : 0, n && (e |= Ct), e } function gf(e, n, o) { var s = n.pendingProps, f = !1, h = (n.flags & 128) !== 0, S; if ((S = h) || (S = e !== null && e.memoizedState === null ? !1 : (Ve.current & 2) !== 0), S && (f = !0, n.flags &= -129), S = (n.flags & 32) !== 0, n.flags &= -33, e === null) { if (ye) { if (f ? Rn(n) : In(), (e = De) ? (e = Am(e, Dt), e = e !== null && e.data !== "&" ? e : null, e !== null && (n.memoizedState = { dehydrated: e, treeContext: En !== null ? { id: Kt, overflow: Xt } : null, retryLane: 536870912, hydrationErrors: null }, o = Kc(e), o.return = n, n.child = o, $e = n, De = null)) : e = null, e === null) throw Cn(n); return tu(e) ? n.lanes = 32 : n.lanes = 536870912, null } var E = s.children; return s = s.fallback, f ? (In(), f = n.mode, E = Xl({ mode: "hidden", children: E }, f), s = $n(s, f, o, null), E.return = n, s.return = n, E.sibling = s, n.child = E, s = n.child, s.memoizedState = vr(o), s.childLanes = xr(e, S, o), n.memoizedState = yr, Lo(null, s)) : (Rn(n), Sr(n, E)) } var C = e.memoizedState; if (C !== null && (E = C.dehydrated, E !== null)) { if (h) n.flags & 256 ? (Rn(n), n.flags &= -257, n = Tr(e, n, o)) : n.memoizedState !== null ? (In(), n.child = e.child, n.flags |= 128, n = null) : (In(), E = s.fallback, f = n.mode, s = Xl({ mode: "visible", children: s.children }, f), E = $n(E, f, o, null), E.flags |= 2, s.return = n, E.return = n, s.sibling = E, n.child = s, ai(n, e.child, null, o), s = n.child, s.memoizedState = vr(o), s.childLanes = xr(e, S, o), n.memoizedState = yr, n = Lo(null, s)); else if (Rn(n), tu(E)) { if (S = E.nextSibling && E.nextSibling.dataset, S) var R = S.dgst; S = R, s = Error(a(419)), s.stack = "", s.digest = S, Ao({ value: s, source: null, stack: null }), n = Tr(e, n, o) } else if (Je || Ii(e, n, o, !1), S = (o & e.childLanes) !== 0, Je || S) { if (S = ke, S !== null && (s = tc(S, o), s !== 0 && s !== C.retryLane)) throw C.retryLane = s, Zn(e, s), gt(S, e, s), pr; eu(E) || oa(), n = Tr(e, n, o) } else eu(E) ? (n.flags |= 192, n.child = e.child, n = null) : (e = C.treeContext, De = Gt(E.nextSibling), $e = n, ye = !0, An = null, Dt = !1, e !== null && jc(n, e), n = Sr(n, s.children), n.flags |= 4096); return n } return f ? (In(), E = s.fallback, f = n.mode, C = e.child, R = C.sibling, s = tn(C, { mode: "hidden", children: s.children }), s.subtreeFlags = C.subtreeFlags & 65011712, R !== null ? E = tn(R, E) : (E = $n(E, f, o, null), E.flags |= 2), E.return = n, s.return = n, s.sibling = E, n.child = s, Lo(null, s), s = n.child, E = e.child.memoizedState, E === null ? E = vr(o) : (f = E.cachePool, f !== null ? (C = Fe._currentValue, f = f.parent !== C ? { parent: C, pool: C } : f) : f = id(), E = { baseLanes: E.baseLanes | o, cachePool: f }), s.memoizedState = E, s.childLanes = xr(e, S, o), n.memoizedState = yr, Lo(e.child, s)) : (Rn(n), o = e.child, e = o.sibling, o = tn(o, { mode: "visible", children: s.children }), o.return = n, o.sibling = null, e !== null && (S = n.deletions, S === null ? (n.deletions = [e], n.flags |= 16) : S.push(e)), n.child = o, n.memoizedState = null, o) } function Sr(e, n) { return n = Xl({ mode: "visible", children: n }, e.mode), n.return = e, e.child = n } function Xl(e, n) { return e = Tt(22, e, null, n), e.lanes = 0, e } function Tr(e, n, o) { return ai(n, e.child, null, o), e = Sr(n, n.pendingProps.children), e.flags |= 2, n.memoizedState = null, e } function yf(e, n, o) { e.lanes |= n; var s = e.alternate; s !== null && (s.lanes |= n), Ls(e.return, n, o) } function _r(e, n, o, s, f, h) { var S = e.memoizedState; S === null ? e.memoizedState = { isBackwards: n, rendering: null, renderingStartTime: 0, last: s, tail: o, tailMode: f, treeForkCount: h } : (S.isBackwards = n, S.rendering = null, S.renderingStartTime = 0, S.last = s, S.tail = o, S.tailMode = f, S.treeForkCount = h) } function vf(e, n, o) { var s = n.pendingProps, f = s.revealOrder, h = s.tail; s = s.children; var S = Ve.current, E = (S & 2) !== 0; if (E ? (S = S & 1 | 2, n.flags |= 128) : S &= 1, Y(Ve, S), tt(e, n, s, o), s = ye ? Eo : 0, !E && e !== null && (e.flags & 128) !== 0) e: for (e = n.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && yf(e, o, n); else if (e.tag === 19) yf(e, o, n); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === n) break e; for (; e.sibling === null;) { if (e.return === null || e.return === n) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } switch (f) { case "forwards": for (o = n.child, f = null; o !== null;)e = o.alternate, e !== null && zl(e) === null && (f = o), o = o.sibling; o = f, o === null ? (f = n.child, n.child = null) : (f = o.sibling, o.sibling = null), _r(n, !1, f, o, h, s); break; case "backwards": case "unstable_legacy-backwards": for (o = null, f = n.child, n.child = null; f !== null;) { if (e = f.alternate, e !== null && zl(e) === null) { n.child = f; break } e = f.sibling, f.sibling = o, o = f, f = e } _r(n, !0, o, null, h, s); break; case "together": _r(n, !1, null, null, void 0, s); break; default: n.memoizedState = null }return n.child } function rn(e, n, o) { if (e !== null && (n.dependencies = e.dependencies), Un |= n.lanes, (o & n.childLanes) === 0) if (e !== null) { if (Ii(e, n, o, !1), (o & n.childLanes) === 0) return null } else return null; if (e !== null && n.child !== e.child) throw Error(a(153)); if (n.child !== null) { for (e = n.child, o = tn(e, e.pendingProps), n.child = o, o.return = n; e.sibling !== null;)e = e.sibling, o = o.sibling = tn(e, e.pendingProps), o.return = n; o.sibling = null } return n.child } function Er(e, n) { return (e.lanes & n) !== 0 ? !0 : (e = e.dependencies, !!(e !== null && Ml(e))) } function v0(e, n, o) { switch (n.tag) { case 3: lt(n, n.stateNode.containerInfo), bn(n, Fe, e.memoizedState.cache), ei(); break; case 27: case 5: so(n); break; case 4: lt(n, n.stateNode.containerInfo); break; case 10: bn(n, n.type, n.memoizedProps.value); break; case 31: if (n.memoizedState !== null) return n.flags |= 128, Ks(n), null; break; case 13: var s = n.memoizedState; if (s !== null) return s.dehydrated !== null ? (Rn(n), n.flags |= 128, null) : (o & n.child.childLanes) !== 0 ? gf(e, n, o) : (Rn(n), e = rn(e, n, o), e !== null ? e.sibling : null); Rn(n); break; case 19: var f = (e.flags & 128) !== 0; if (s = (o & n.childLanes) !== 0, s || (Ii(e, n, o, !1), s = (o & n.childLanes) !== 0), f) { if (s) return vf(e, n, o); n.flags |= 128 } if (f = n.memoizedState, f !== null && (f.rendering = null, f.tail = null, f.lastEffect = null), Y(Ve, Ve.current), s) break; return null; case 22: return n.lanes = 0, cf(e, n, o, n.pendingProps); case 24: bn(n, Fe, e.memoizedState.cache) }return rn(e, n, o) } function xf(e, n, o) { if (e !== null) if (e.memoizedProps !== n.pendingProps) Je = !0; else { if (!Er(e, o) && (n.flags & 128) === 0) return Je = !1, v0(e, n, o); Je = (e.flags & 131072) !== 0 } else Je = !1, ye && (n.flags & 1048576) !== 0 && Qc(n, Eo, n.index); switch (n.lanes = 0, n.tag) { case 16: e: { var s = n.pendingProps; if (e = oi(n.elementType), n.type = e, typeof e == "function") ws(e) ? (s = ri(e, s), n.tag = 1, n = hf(null, n, e, s, o)) : (n.tag = 0, n = gr(null, n, e, s, o)); else { if (e != null) { var f = e.$$typeof; if (f === K) { n.tag = 11, n = sf(null, n, e, s, o); break e } else if (f === F) { n.tag = 14, n = rf(null, n, e, s, o); break e } } throw n = Oe(e) || e, Error(a(306, n, "")) } } return n; case 0: return gr(e, n, n.type, n.pendingProps, o); case 1: return s = n.type, f = ri(s, n.pendingProps), hf(e, n, s, f, o); case 3: e: { if (lt(n, n.stateNode.containerInfo), e === null) throw Error(a(387)); s = n.pendingProps; var h = n.memoizedState; f = h.element, Os(e, n), Io(n, s, null, o); var S = n.memoizedState; if (s = S.cache, bn(n, Fe, s), s !== h.cache && zs(n, [Fe], o, !0), Ro(), s = S.element, h.isDehydrated) if (h = { element: s, isDehydrated: !1, cache: S.cache }, n.updateQueue.baseState = h, n.memoizedState = h, n.flags & 256) { n = pf(e, n, s, o); break e } else if (s !== f) { f = Rt(Error(a(424)), n), Ao(f), n = pf(e, n, s, o); break e } else { switch (e = n.stateNode.containerInfo, e.nodeType) { case 9: e = e.body; break; default: e = e.nodeName === "HTML" ? e.ownerDocument.body : e }for (De = Gt(e.firstChild), $e = n, ye = !0, An = null, Dt = !0, o = ud(n, null, s, o), n.child = o; o;)o.flags = o.flags & -3 | 4096, o = o.sibling } else { if (ei(), s === f) { n = rn(e, n, o); break e } tt(e, n, s, o) } n = n.child } return n; case 26: return Kl(e, n), e === null ? (o = Rm(n.type, null, n.pendingProps, null)) ? n.memoizedState = o : ye || (o = n.type, e = n.pendingProps, s = da(ce.current).createElement(o), s[Ze] = n, s[ct] = e, nt(s, o, e), Xe(s), n.stateNode = s) : n.memoizedState = Rm(n.type, e.memoizedProps, n.pendingProps, e.memoizedState), null; case 27: return so(n), e === null && ye && (s = n.stateNode = Nm(n.type, n.pendingProps, ce.current), $e = n, Dt = !0, f = De, Hn(n.type) ? (nu = f, De = Gt(s.firstChild)) : De = f), tt(e, n, n.pendingProps.children, o), Kl(e, n), e === null && (n.flags |= 4194304), n.child; case 5: return e === null && ye && ((f = s = De) && (s = K0(s, n.type, n.pendingProps, Dt), s !== null ? (n.stateNode = s, $e = n, De = Gt(s.firstChild), Dt = !1, f = !0) : f = !1), f || Cn(n)), so(n), f = n.type, h = n.pendingProps, S = e !== null ? e.memoizedProps : null, s = h.children, jr(f, h) ? s = null : S !== null && jr(f, S) && (n.flags |= 32), n.memoizedState !== null && (f = Qs(e, n, u0, null, null, o), jo._currentValue = f), Kl(e, n), tt(e, n, s, o), n.child; case 6: return e === null && ye && ((e = o = De) && (o = X0(o, n.pendingProps, Dt), o !== null ? (n.stateNode = o, $e = n, De = null, e = !0) : e = !1), e || Cn(n)), null; case 13: return gf(e, n, o); case 4: return lt(n, n.stateNode.containerInfo), s = n.pendingProps, e === null ? n.child = ai(n, null, s, o) : tt(e, n, s, o), n.child; case 11: return sf(e, n, n.type, n.pendingProps, o); case 7: return tt(e, n, n.pendingProps, o), n.child; case 8: return tt(e, n, n.pendingProps.children, o), n.child; case 12: return tt(e, n, n.pendingProps.children, o), n.child; case 10: return s = n.pendingProps, bn(n, n.type, s.value), tt(e, n, s.children, o), n.child; case 9: return f = n.type._context, s = n.pendingProps.children, ni(n), f = et(f), s = s(f), n.flags |= 1, tt(e, n, s, o), n.child; case 14: return rf(e, n, n.type, n.pendingProps, o); case 15: return uf(e, n, n.type, n.pendingProps, o); case 19: return vf(e, n, o); case 31: return y0(e, n, o); case 22: return cf(e, n, o, n.pendingProps); case 24: return ni(n), s = et(Fe), e === null ? (f = Ps(), f === null && (f = ke, h = qs(), f.pooledCache = h, h.refCount++, h !== null && (f.pooledCacheLanes |= o), f = h), n.memoizedState = { parent: s, cache: f }, Bs(n), bn(n, Fe, f)) : ((e.lanes & o) !== 0 && (Os(e, n), Io(n, null, null, o), Ro()), f = e.memoizedState, h = n.memoizedState, f.parent !== s ? (f = { parent: s, cache: s }, n.memoizedState = f, n.lanes === 0 && (n.memoizedState = n.updateQueue.baseState = f), bn(n, Fe, s)) : (s = h.cache, bn(n, Fe, s), s !== f.cache && zs(n, [Fe], o, !0))), tt(e, n, n.pendingProps.children, o), n.child; case 29: throw n.pendingProps }throw Error(a(156, n.tag)) } function un(e) { e.flags |= 4 } function Ar(e, n, o, s, f) { if ((n = (e.mode & 32) !== 0) && (n = !1), n) { if (e.flags |= 16777216, (f & 335544128) === f) if (e.stateNode.complete) e.flags |= 8192; else if (Jf()) e.flags |= 8192; else throw li = Dl, Vs } else e.flags &= -16777217 } function Sf(e, n) { if (n.type !== "stylesheet" || (n.state.loading & 4) !== 0) e.flags &= -16777217; else if (e.flags |= 16777216, !Gm(n)) if (Jf()) e.flags |= 8192; else throw li = Dl, Vs } function Ql(e, n) { n !== null && (e.flags |= 4), e.flags & 16384 && (n = e.tag !== 22 ? Zu() : 536870912, e.lanes |= n, Oi |= n) } function zo(e, n) { if (!ye) switch (e.tailMode) { case "hidden": n = e.tail; for (var o = null; n !== null;)n.alternate !== null && (o = n), n = n.sibling; o === null ? e.tail = null : o.sibling = null; break; case "collapsed": o = e.tail; for (var s = null; o !== null;)o.alternate !== null && (s = o), o = o.sibling; s === null ? n || e.tail === null ? e.tail = null : e.tail.sibling = null : s.sibling = null } } function Ue(e) { var n = e.alternate !== null && e.alternate.child === e.child, o = 0, s = 0; if (n) for (var f = e.child; f !== null;)o |= f.lanes | f.childLanes, s |= f.subtreeFlags & 65011712, s |= f.flags & 65011712, f.return = e, f = f.sibling; else for (f = e.child; f !== null;)o |= f.lanes | f.childLanes, s |= f.subtreeFlags, s |= f.flags, f.return = e, f = f.sibling; return e.subtreeFlags |= s, e.childLanes = o, n } function x0(e, n, o) { var s = n.pendingProps; switch (ks(n), n.tag) { case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Ue(n), null; case 1: return Ue(n), null; case 3: return o = n.stateNode, s = null, e !== null && (s = e.memoizedState.cache), n.memoizedState.cache !== s && (n.flags |= 2048), ln(Fe), Pe(), o.pendingContext && (o.context = o.pendingContext, o.pendingContext = null), (e === null || e.child === null) && (Ri(n) ? un(n) : e === null || e.memoizedState.isDehydrated && (n.flags & 256) === 0 || (n.flags |= 1024, Us())), Ue(n), null; case 26: var f = n.type, h = n.memoizedState; return e === null ? (un(n), h !== null ? (Ue(n), Sf(n, h)) : (Ue(n), Ar(n, f, null, s, o))) : h ? h !== e.memoizedState ? (un(n), Ue(n), Sf(n, h)) : (Ue(n), n.flags &= -16777217) : (e = e.memoizedProps, e !== s && un(n), Ue(n), Ar(n, f, e, s, o)), null; case 27: if (sl(n), o = ce.current, f = n.type, e !== null && n.stateNode != null) e.memoizedProps !== s && un(n); else { if (!s) { if (n.stateNode === null) throw Error(a(166)); return Ue(n), null } e = Q.current, Ri(n) ? Zc(n) : (e = Nm(f, s, o), n.stateNode = e, un(n)) } return Ue(n), null; case 5: if (sl(n), f = n.type, e !== null && n.stateNode != null) e.memoizedProps !== s && un(n); else { if (!s) { if (n.stateNode === null) throw Error(a(166)); return Ue(n), null } if (h = Q.current, Ri(n)) Zc(n); else { var S = da(ce.current); switch (h) { case 1: h = S.createElementNS("http://www.w3.org/2000/svg", f); break; case 2: h = S.createElementNS("http://www.w3.org/1998/Math/MathML", f); break; default: switch (f) { case "svg": h = S.createElementNS("http://www.w3.org/2000/svg", f); break; case "math": h = S.createElementNS("http://www.w3.org/1998/Math/MathML", f); break; case "script": h = S.createElement("div"), h.innerHTML = "<script><\/script>", h = h.removeChild(h.firstChild); break; case "select": h = typeof s.is == "string" ? S.createElement("select", { is: s.is }) : S.createElement("select"), s.multiple ? h.multiple = !0 : s.size && (h.size = s.size); break; default: h = typeof s.is == "string" ? S.createElement(f, { is: s.is }) : S.createElement(f) } }h[Ze] = n, h[ct] = s; e: for (S = n.child; S !== null;) { if (S.tag === 5 || S.tag === 6) h.appendChild(S.stateNode); else if (S.tag !== 4 && S.tag !== 27 && S.child !== null) { S.child.return = S, S = S.child; continue } if (S === n) break e; for (; S.sibling === null;) { if (S.return === null || S.return === n) break e; S = S.return } S.sibling.return = S.return, S = S.sibling } n.stateNode = h; e: switch (nt(h, f, s), f) { case "button": case "input": case "select": case "textarea": s = !!s.autoFocus; break e; case "img": s = !0; break e; default: s = !1 }s && un(n) } } return Ue(n), Ar(n, n.type, e === null ? null : e.memoizedProps, n.pendingProps, o), null; case 6: if (e && n.stateNode != null) e.memoizedProps !== s && un(n); else { if (typeof s != "string" && n.stateNode === null) throw Error(a(166)); if (e = ce.current, Ri(n)) { if (e = n.stateNode, o = n.memoizedProps, s = null, f = $e, f !== null) switch (f.tag) { case 27: case 5: s = f.memoizedProps }e[Ze] = n, e = !!(e.nodeValue === o || s !== null && s.suppressHydrationWarning === !0 || gm(e.nodeValue, o)), e || Cn(n, !0) } else e = da(e).createTextNode(s), e[Ze] = n, n.stateNode = e } return Ue(n), null; case 31: if (o = n.memoizedState, e === null || e.memoizedState !== null) { if (s = Ri(n), o !== null) { if (e === null) { if (!s) throw Error(a(318)); if (e = n.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(a(557)); e[Ze] = n } else ei(), (n.flags & 128) === 0 && (n.memoizedState = null), n.flags |= 4; Ue(n), e = !1 } else o = Us(), e !== null && e.memoizedState !== null && (e.memoizedState.hydrationErrors = o), e = !0; if (!e) return n.flags & 256 ? (Et(n), n) : (Et(n), null); if ((n.flags & 128) !== 0) throw Error(a(558)) } return Ue(n), null; case 13: if (s = n.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (f = Ri(n), s !== null && s.dehydrated !== null) { if (e === null) { if (!f) throw Error(a(318)); if (f = n.memoizedState, f = f !== null ? f.dehydrated : null, !f) throw Error(a(317)); f[Ze] = n } else ei(), (n.flags & 128) === 0 && (n.memoizedState = null), n.flags |= 4; Ue(n), f = !1 } else f = Us(), e !== null && e.memoizedState !== null && (e.memoizedState.hydrationErrors = f), f = !0; if (!f) return n.flags & 256 ? (Et(n), n) : (Et(n), null) } return Et(n), (n.flags & 128) !== 0 ? (n.lanes = o, n) : (o = s !== null, e = e !== null && e.memoizedState !== null, o && (s = n.child, f = null, s.alternate !== null && s.alternate.memoizedState !== null && s.alternate.memoizedState.cachePool !== null && (f = s.alternate.memoizedState.cachePool.pool), h = null, s.memoizedState !== null && s.memoizedState.cachePool !== null && (h = s.memoizedState.cachePool.pool), h !== f && (s.flags |= 2048)), o !== e && o && (n.child.flags |= 8192), Ql(n, n.updateQueue), Ue(n), null); case 4: return Pe(), e === null && Jr(n.stateNode.containerInfo), Ue(n), null; case 10: return ln(n.type), Ue(n), null; case 19: if (P(Ve), s = n.memoizedState, s === null) return Ue(n), null; if (f = (n.flags & 128) !== 0, h = s.rendering, h === null) if (f) zo(s, !1); else { if (He !== 0 || e !== null && (e.flags & 128) !== 0) for (e = n.child; e !== null;) { if (h = zl(e), h !== null) { for (n.flags |= 128, zo(s, !1), e = h.updateQueue, n.updateQueue = e, Ql(n, e), n.subtreeFlags = 0, e = o, o = n.child; o !== null;)Wc(o, e), o = o.sibling; return Y(Ve, Ve.current & 1 | 2), ye && nn(n, s.treeForkCount), n.child } e = e.sibling } s.tail !== null && yt() > ta && (n.flags |= 128, f = !0, zo(s, !1), n.lanes = 4194304) } else { if (!f) if (e = zl(h), e !== null) { if (n.flags |= 128, f = !0, e = e.updateQueue, n.updateQueue = e, Ql(n, e), zo(s, !0), s.tail === null && s.tailMode === "hidden" && !h.alternate && !ye) return Ue(n), null } else 2 * yt() - s.renderingStartTime > ta && o !== 536870912 && (n.flags |= 128, f = !0, zo(s, !1), n.lanes = 4194304); s.isBackwards ? (h.sibling = n.child, n.child = h) : (e = s.last, e !== null ? e.sibling = h : n.child = h, s.last = h) } return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = yt(), e.sibling = null, o = Ve.current, Y(Ve, f ? o & 1 | 2 : o & 1), ye && nn(n, s.treeForkCount), e) : (Ue(n), null); case 22: case 23: return Et(n), Ws(), s = n.memoizedState !== null, e !== null ? e.memoizedState !== null !== s && (n.flags |= 8192) : s && (n.flags |= 8192), s ? (o & 536870912) !== 0 && (n.flags & 128) === 0 && (Ue(n), n.subtreeFlags & 6 && (n.flags |= 8192)) : Ue(n), o = n.updateQueue, o !== null && Ql(n, o.retryQueue), o = null, e !== null && e.memoizedState !== null && e.memoizedState.cachePool !== null && (o = e.memoizedState.cachePool.pool), s = null, n.memoizedState !== null && n.memoizedState.cachePool !== null && (s = n.memoizedState.cachePool.pool), s !== o && (n.flags |= 2048), e !== null && P(ii), null; case 24: return o = null, e !== null && (o = e.memoizedState.cache), n.memoizedState.cache !== o && (n.flags |= 2048), ln(Fe), Ue(n), null; case 25: return null; case 30: return null }throw Error(a(156, n.tag)) } function S0(e, n) { switch (ks(n), n.tag) { case 1: return e = n.flags, e & 65536 ? (n.flags = e & -65537 | 128, n) : null; case 3: return ln(Fe), Pe(), e = n.flags, (e & 65536) !== 0 && (e & 128) === 0 ? (n.flags = e & -65537 | 128, n) : null; case 26: case 27: case 5: return sl(n), null; case 31: if (n.memoizedState !== null) { if (Et(n), n.alternate === null) throw Error(a(340)); ei() } return e = n.flags, e & 65536 ? (n.flags = e & -65537 | 128, n) : null; case 13: if (Et(n), e = n.memoizedState, e !== null && e.dehydrated !== null) { if (n.alternate === null) throw Error(a(340)); ei() } return e = n.flags, e & 65536 ? (n.flags = e & -65537 | 128, n) : null; case 19: return P(Ve), null; case 4: return Pe(), null; case 10: return ln(n.type), null; case 22: case 23: return Et(n), Ws(), e !== null && P(ii), e = n.flags, e & 65536 ? (n.flags = e & -65537 | 128, n) : null; case 24: return ln(Fe), null; case 25: return null; default: return null } } function Tf(e, n) { switch (ks(n), n.tag) { case 3: ln(Fe), Pe(); break; case 26: case 27: case 5: sl(n); break; case 4: Pe(); break; case 31: n.memoizedState !== null && Et(n); break; case 13: Et(n); break; case 19: P(Ve); break; case 10: ln(n.type); break; case 22: case 23: Et(n), Ws(), e !== null && P(ii); break; case 24: ln(Fe) } } function qo(e, n) { try { var o = n.updateQueue, s = o !== null ? o.lastEffect : null; if (s !== null) { var f = s.next; o = f; do { if ((o.tag & e) === e) { s = void 0; var h = o.create, S = o.inst; s = h(), S.destroy = s } o = o.next } while (o !== f) } } catch (E) { be(n, n.return, E) } } function kn(e, n, o) { try { var s = n.updateQueue, f = s !== null ? s.lastEffect : null; if (f !== null) { var h = f.next; s = h; do { if ((s.tag & e) === e) { var S = s.inst, E = S.destroy; if (E !== void 0) { S.destroy = void 0, f = n; var C = o, R = E; try { R() } catch (z) { be(f, C, z) } } } s = s.next } while (s !== h) } } catch (z) { be(n, n.return, z) } } function _f(e) { var n = e.updateQueue; if (n !== null) { var o = e.stateNode; try { dd(n, o) } catch (s) { be(e, e.return, s) } } } function Ef(e, n, o) { o.props = ri(e.type, e.memoizedProps), o.state = e.memoizedState; try { o.componentWillUnmount() } catch (s) { be(e, n, s) } } function Ho(e, n) { try { var o = e.ref; if (o !== null) { switch (e.tag) { case 26: case 27: case 5: var s = e.stateNode; break; case 30: s = e.stateNode; break; default: s = e.stateNode }typeof o == "function" ? e.refCleanup = o(s) : o.current = s } } catch (f) { be(e, n, f) } } function Qt(e, n) { var o = e.ref, s = e.refCleanup; if (o !== null) if (typeof s == "function") try { s() } catch (f) { be(e, n, f) } finally { e.refCleanup = null, e = e.alternate, e != null && (e.refCleanup = null) } else if (typeof o == "function") try { o(null) } catch (f) { be(e, n, f) } else o.current = null } function Af(e) { var n = e.type, o = e.memoizedProps, s = e.stateNode; try { e: switch (n) { case "button": case "input": case "select": case "textarea": o.autoFocus && s.focus(); break e; case "img": o.src ? s.src = o.src : o.srcSet && (s.srcset = o.srcSet) } } catch (f) { be(e, e.return, f) } } function Cr(e, n, o) { try { var s = e.stateNode; B0(s, e.type, o, n), s[ct] = n } catch (f) { be(e, e.return, f) } } function Cf(e) { return e.tag === 5 || e.tag === 3 || e.tag === 26 || e.tag === 27 && Hn(e.type) || e.tag === 4 } function br(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || Cf(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.tag === 27 && Hn(e.type) || e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function Nr(e, n, o) { var s = e.tag; if (s === 5 || s === 6) e = e.stateNode, n ? (o.nodeType === 9 ? o.body : o.nodeName === "HTML" ? o.ownerDocument.body : o).insertBefore(e, n) : (n = o.nodeType === 9 ? o.body : o.nodeName === "HTML" ? o.ownerDocument.body : o, n.appendChild(e), o = o._reactRootContainer, o != null || n.onclick !== null || (n.onclick = $t)); else if (s !== 4 && (s === 27 && Hn(e.type) && (o = e.stateNode, n = null), e = e.child, e !== null)) for (Nr(e, n, o), e = e.sibling; e !== null;)Nr(e, n, o), e = e.sibling } function jl(e, n, o) { var s = e.tag; if (s === 5 || s === 6) e = e.stateNode, n ? o.insertBefore(e, n) : o.appendChild(e); else if (s !== 4 && (s === 27 && Hn(e.type) && (o = e.stateNode), e = e.child, e !== null)) for (jl(e, n, o), e = e.sibling; e !== null;)jl(e, n, o), e = e.sibling } function bf(e) { var n = e.stateNode, o = e.memoizedProps; try { for (var s = e.type, f = n.attributes; f.length;)n.removeAttributeNode(f[0]); nt(n, s, o), n[Ze] = e, n[ct] = o } catch (h) { be(e, e.return, h) } } var cn = !1, We = !1, wr = !1, Nf = typeof WeakSet == "function" ? WeakSet : Set, Qe = null; function T0(e, n) { if (e = e.containerInfo, Xr = va, e = qc(e), Ts(e)) { if ("selectionStart" in e) var o = { start: e.selectionStart, end: e.selectionEnd }; else e: { o = (o = e.ownerDocument) && o.defaultView || window; var s = o.getSelection && o.getSelection(); if (s && s.rangeCount !== 0) { o = s.anchorNode; var f = s.anchorOffset, h = s.focusNode; s = s.focusOffset; try { o.nodeType, h.nodeType } catch { o = null; break e } var S = 0, E = -1, C = -1, R = 0, z = 0, H = e, I = null; t: for (; ;) { for (var D; H !== o || f !== 0 && H.nodeType !== 3 || (E = S + f), H !== h || s !== 0 && H.nodeType !== 3 || (C = S + s), H.nodeType === 3 && (S += H.nodeValue.length), (D = H.firstChild) !== null;)I = H, H = D; for (; ;) { if (H === e) break t; if (I === o && ++R === f && (E = S), I === h && ++z === s && (C = S), (D = H.nextSibling) !== null) break; H = I, I = H.parentNode } H = D } o = E === -1 || C === -1 ? null : { start: E, end: C } } else o = null } o = o || { start: 0, end: 0 } } else o = null; for (Qr = { focusedElem: e, selectionRange: o }, va = !1, Qe = n; Qe !== null;)if (n = Qe, e = n.child, (n.subtreeFlags & 1028) !== 0 && e !== null) e.return = n, Qe = e; else for (; Qe !== null;) { switch (n = Qe, h = n.alternate, e = n.flags, n.tag) { case 0: if ((e & 4) !== 0 && (e = n.updateQueue, e = e !== null ? e.events : null, e !== null)) for (o = 0; o < e.length; o++)f = e[o], f.ref.impl = f.nextImpl; break; case 11: case 15: break; case 1: if ((e & 1024) !== 0 && h !== null) { e = void 0, o = n, f = h.memoizedProps, h = h.memoizedState, s = o.stateNode; try { var X = ri(o.type, f); e = s.getSnapshotBeforeUpdate(X, h), s.__reactInternalSnapshotBeforeUpdate = e } catch (ne) { be(o, o.return, ne) } } break; case 3: if ((e & 1024) !== 0) { if (e = n.stateNode.containerInfo, o = e.nodeType, o === 9) $r(e); else if (o === 1) switch (e.nodeName) { case "HEAD": case "HTML": case "BODY": $r(e); break; default: e.textContent = "" } } break; case 5: case 26: case 27: case 6: case 4: case 17: break; default: if ((e & 1024) !== 0) throw Error(a(163)) }if (e = n.sibling, e !== null) { e.return = n.return, Qe = e; break } Qe = n.return } } function wf(e, n, o) { var s = o.flags; switch (o.tag) { case 0: case 11: case 15: fn(e, o), s & 4 && qo(5, o); break; case 1: if (fn(e, o), s & 4) if (e = o.stateNode, n === null) try { e.componentDidMount() } catch (S) { be(o, o.return, S) } else { var f = ri(o.type, n.memoizedProps); n = n.memoizedState; try { e.componentDidUpdate(f, n, e.__reactInternalSnapshotBeforeUpdate) } catch (S) { be(o, o.return, S) } } s & 64 && _f(o), s & 512 && Ho(o, o.return); break; case 3: if (fn(e, o), s & 64 && (e = o.updateQueue, e !== null)) { if (n = null, o.child !== null) switch (o.child.tag) { case 27: case 5: n = o.child.stateNode; break; case 1: n = o.child.stateNode }try { dd(e, n) } catch (S) { be(o, o.return, S) } } break; case 27: n === null && s & 4 && bf(o); case 26: case 5: fn(e, o), n === null && s & 4 && Af(o), s & 512 && Ho(o, o.return); break; case 12: fn(e, o); break; case 31: fn(e, o), s & 4 && If(e, o); break; case 13: fn(e, o), s & 4 && kf(e, o), s & 64 && (e = o.memoizedState, e !== null && (e = e.dehydrated, e !== null && (o = R0.bind(null, o), Q0(e, o)))); break; case 22: if (s = o.memoizedState !== null || cn, !s) { n = n !== null && n.memoizedState !== null || We, f = cn; var h = We; cn = s, (We = n) && !h ? mn(e, o, (o.subtreeFlags & 8772) !== 0) : fn(e, o), cn = f, We = h } break; case 30: break; default: fn(e, o) } } function Mf(e) { var n = e.alternate; n !== null && (e.alternate = null, Mf(n)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (n = e.stateNode, n !== null && os(n)), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } var Ge = null, ft = !1; function dn(e, n, o) { for (o = o.child; o !== null;)Rf(e, n, o), o = o.sibling } function Rf(e, n, o) { if (vt && typeof vt.onCommitFiberUnmount == "function") try { vt.onCommitFiberUnmount(ro, o) } catch { } switch (o.tag) { case 26: We || Qt(o, n), dn(e, n, o), o.memoizedState ? o.memoizedState.count-- : o.stateNode && (o = o.stateNode, o.parentNode.removeChild(o)); break; case 27: We || Qt(o, n); var s = Ge, f = ft; Hn(o.type) && (Ge = o.stateNode, ft = !1), dn(e, n, o), Ko(o.stateNode), Ge = s, ft = f; break; case 5: We || Qt(o, n); case 6: if (s = Ge, f = ft, Ge = null, dn(e, n, o), Ge = s, ft = f, Ge !== null) if (ft) try { (Ge.nodeType === 9 ? Ge.body : Ge.nodeName === "HTML" ? Ge.ownerDocument.body : Ge).removeChild(o.stateNode) } catch (h) { be(o, n, h) } else try { Ge.removeChild(o.stateNode) } catch (h) { be(o, n, h) } break; case 18: Ge !== null && (ft ? (e = Ge, _m(e.nodeType === 9 ? e.body : e.nodeName === "HTML" ? e.ownerDocument.body : e, o.stateNode), ji(e)) : _m(Ge, o.stateNode)); break; case 4: s = Ge, f = ft, Ge = o.stateNode.containerInfo, ft = !0, dn(e, n, o), Ge = s, ft = f; break; case 0: case 11: case 14: case 15: kn(2, o, n), We || kn(4, o, n), dn(e, n, o); break; case 1: We || (Qt(o, n), s = o.stateNode, typeof s.componentWillUnmount == "function" && Ef(o, n, s)), dn(e, n, o); break; case 21: dn(e, n, o); break; case 22: We = (s = We) || o.memoizedState !== null, dn(e, n, o), We = s; break; default: dn(e, n, o) } } function If(e, n) { if (n.memoizedState === null && (e = n.alternate, e !== null && (e = e.memoizedState, e !== null))) { e = e.dehydrated; try { ji(e) } catch (o) { be(n, n.return, o) } } } function kf(e, n) { if (n.memoizedState === null && (e = n.alternate, e !== null && (e = e.memoizedState, e !== null && (e = e.dehydrated, e !== null)))) try { ji(e) } catch (o) { be(n, n.return, o) } } function _0(e) { switch (e.tag) { case 31: case 13: case 19: var n = e.stateNode; return n === null && (n = e.stateNode = new Nf), n; case 22: return e = e.stateNode, n = e._retryCache, n === null && (n = e._retryCache = new Nf), n; default: throw Error(a(435, e.tag)) } } function Zl(e, n) { var o = _0(e); n.forEach(function (s) { if (!o.has(s)) { o.add(s); var f = I0.bind(null, e, s); s.then(f, f) } }) } function mt(e, n) { var o = n.deletions; if (o !== null) for (var s = 0; s < o.length; s++) { var f = o[s], h = e, S = n, E = S; e: for (; E !== null;) { switch (E.tag) { case 27: if (Hn(E.type)) { Ge = E.stateNode, ft = !1; break e } break; case 5: Ge = E.stateNode, ft = !1; break e; case 3: case 4: Ge = E.stateNode.containerInfo, ft = !0; break e }E = E.return } if (Ge === null) throw Error(a(160)); Rf(h, S, f), Ge = null, ft = !1, h = f.alternate, h !== null && (h.return = null), f.return = null } if (n.subtreeFlags & 13886) for (n = n.child; n !== null;)Df(n, e), n = n.sibling } var Bt = null; function Df(e, n) { var o = e.alternate, s = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: mt(n, e), ht(e), s & 4 && (kn(3, e, e.return), qo(3, e), kn(5, e, e.return)); break; case 1: mt(n, e), ht(e), s & 512 && (We || o === null || Qt(o, o.return)), s & 64 && cn && (e = e.updateQueue, e !== null && (s = e.callbacks, s !== null && (o = e.shared.hiddenCallbacks, e.shared.hiddenCallbacks = o === null ? s : o.concat(s)))); break; case 26: var f = Bt; if (mt(n, e), ht(e), s & 512 && (We || o === null || Qt(o, o.return)), s & 4) { var h = o !== null ? o.memoizedState : null; if (s = e.memoizedState, o === null) if (s === null) if (e.stateNode === null) { e: { s = e.type, o = e.memoizedProps, f = f.ownerDocument || f; t: switch (s) { case "title": h = f.getElementsByTagName("title")[0], (!h || h[fo] || h[Ze] || h.namespaceURI === "http://www.w3.org/2000/svg" || h.hasAttribute("itemprop")) && (h = f.createElement(s), f.head.insertBefore(h, f.querySelector("head > title"))), nt(h, s, o), h[Ze] = e, Xe(h), s = h; break e; case "link": var S = Dm("link", "href", f).get(s + (o.href || "")); if (S) { for (var E = 0; E < S.length; E++)if (h = S[E], h.getAttribute("href") === (o.href == null || o.href === "" ? null : o.href) && h.getAttribute("rel") === (o.rel == null ? null : o.rel) && h.getAttribute("title") === (o.title == null ? null : o.title) && h.getAttribute("crossorigin") === (o.crossOrigin == null ? null : o.crossOrigin)) { S.splice(E, 1); break t } } h = f.createElement(s), nt(h, s, o), f.head.appendChild(h); break; case "meta": if (S = Dm("meta", "content", f).get(s + (o.content || ""))) { for (E = 0; E < S.length; E++)if (h = S[E], h.getAttribute("content") === (o.content == null ? null : "" + o.content) && h.getAttribute("name") === (o.name == null ? null : o.name) && h.getAttribute("property") === (o.property == null ? null : o.property) && h.getAttribute("http-equiv") === (o.httpEquiv == null ? null : o.httpEquiv) && h.getAttribute("charset") === (o.charSet == null ? null : o.charSet)) { S.splice(E, 1); break t } } h = f.createElement(s), nt(h, s, o), f.head.appendChild(h); break; default: throw Error(a(468, s)) }h[Ze] = e, Xe(h), s = h } e.stateNode = s } else Um(f, e.type, e.stateNode); else e.stateNode = km(f, s, e.memoizedProps); else h !== s ? (h === null ? o.stateNode !== null && (o = o.stateNode, o.parentNode.removeChild(o)) : h.count--, s === null ? Um(f, e.type, e.stateNode) : km(f, s, e.memoizedProps)) : s === null && e.stateNode !== null && Cr(e, e.memoizedProps, o.memoizedProps) } break; case 27: mt(n, e), ht(e), s & 512 && (We || o === null || Qt(o, o.return)), o !== null && s & 4 && Cr(e, e.memoizedProps, o.memoizedProps); break; case 5: if (mt(n, e), ht(e), s & 512 && (We || o === null || Qt(o, o.return)), e.flags & 32) { f = e.stateNode; try { Si(f, "") } catch (X) { be(e, e.return, X) } } s & 4 && e.stateNode != null && (f = e.memoizedProps, Cr(e, f, o !== null ? o.memoizedProps : f)), s & 1024 && (wr = !0); break; case 6: if (mt(n, e), ht(e), s & 4) { if (e.stateNode === null) throw Error(a(162)); s = e.memoizedProps, o = e.stateNode; try { o.nodeValue = s } catch (X) { be(e, e.return, X) } } break; case 3: if (ha = null, f = Bt, Bt = fa(n.containerInfo), mt(n, e), Bt = f, ht(e), s & 4 && o !== null && o.memoizedState.isDehydrated) try { ji(n.containerInfo) } catch (X) { be(e, e.return, X) } wr && (wr = !1, Uf(e)); break; case 4: s = Bt, Bt = fa(e.stateNode.containerInfo), mt(n, e), ht(e), Bt = s; break; case 12: mt(n, e), ht(e); break; case 31: mt(n, e), ht(e), s & 4 && (s = e.updateQueue, s !== null && (e.updateQueue = null, Zl(e, s))); break; case 13: mt(n, e), ht(e), e.child.flags & 8192 && e.memoizedState !== null != (o !== null && o.memoizedState !== null) && (ea = yt()), s & 4 && (s = e.updateQueue, s !== null && (e.updateQueue = null, Zl(e, s))); break; case 22: f = e.memoizedState !== null; var C = o !== null && o.memoizedState !== null, R = cn, z = We; if (cn = R || f, We = z || C, mt(n, e), We = z, cn = R, ht(e), s & 8192) e: for (n = e.stateNode, n._visibility = f ? n._visibility & -2 : n._visibility | 1, f && (o === null || C || cn || We || ui(e)), o = null, n = e; ;) { if (n.tag === 5 || n.tag === 26) { if (o === null) { C = o = n; try { if (h = C.stateNode, f) S = h.style, typeof S.setProperty == "function" ? S.setProperty("display", "none", "important") : S.display = "none"; else { E = C.stateNode; var H = C.memoizedProps.style, I = H != null && H.hasOwnProperty("display") ? H.display : null; E.style.display = I == null || typeof I == "boolean" ? "" : ("" + I).trim() } } catch (X) { be(C, C.return, X) } } } else if (n.tag === 6) { if (o === null) { C = n; try { C.stateNode.nodeValue = f ? "" : C.memoizedProps } catch (X) { be(C, C.return, X) } } } else if (n.tag === 18) { if (o === null) { C = n; try { var D = C.stateNode; f ? Em(D, !0) : Em(C.stateNode, !1) } catch (X) { be(C, C.return, X) } } } else if ((n.tag !== 22 && n.tag !== 23 || n.memoizedState === null || n === e) && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === e) break e; for (; n.sibling === null;) { if (n.return === null || n.return === e) break e; o === n && (o = null), n = n.return } o === n && (o = null), n.sibling.return = n.return, n = n.sibling } s & 4 && (s = e.updateQueue, s !== null && (o = s.retryQueue, o !== null && (s.retryQueue = null, Zl(e, o)))); break; case 19: mt(n, e), ht(e), s & 4 && (s = e.updateQueue, s !== null && (e.updateQueue = null, Zl(e, s))); break; case 30: break; case 21: break; default: mt(n, e), ht(e) } } function ht(e) { var n = e.flags; if (n & 2) { try { for (var o, s = e.return; s !== null;) { if (Cf(s)) { o = s; break } s = s.return } if (o == null) throw Error(a(160)); switch (o.tag) { case 27: var f = o.stateNode, h = br(e); jl(e, h, f); break; case 5: var S = o.stateNode; o.flags & 32 && (Si(S, ""), o.flags &= -33); var E = br(e); jl(e, E, S); break; case 3: case 4: var C = o.stateNode.containerInfo, R = br(e); Nr(e, R, C); break; default: throw Error(a(161)) } } catch (z) { be(e, e.return, z) } e.flags &= -3 } n & 4096 && (e.flags &= -4097) } function Uf(e) { if (e.subtreeFlags & 1024) for (e = e.child; e !== null;) { var n = e; Uf(n), n.tag === 5 && n.flags & 1024 && n.stateNode.reset(), e = e.sibling } } function fn(e, n) { if (n.subtreeFlags & 8772) for (n = n.child; n !== null;)wf(e, n.alternate, n), n = n.sibling } function ui(e) { for (e = e.child; e !== null;) { var n = e; switch (n.tag) { case 0: case 11: case 14: case 15: kn(4, n, n.return), ui(n); break; case 1: Qt(n, n.return); var o = n.stateNode; typeof o.componentWillUnmount == "function" && Ef(n, n.return, o), ui(n); break; case 27: Ko(n.stateNode); case 26: case 5: Qt(n, n.return), ui(n); break; case 22: n.memoizedState === null && ui(n); break; case 30: ui(n); break; default: ui(n) }e = e.sibling } } function mn(e, n, o) { for (o = o && (n.subtreeFlags & 8772) !== 0, n = n.child; n !== null;) { var s = n.alternate, f = e, h = n, S = h.flags; switch (h.tag) { case 0: case 11: case 15: mn(f, h, o), qo(4, h); break; case 1: if (mn(f, h, o), s = h, f = s.stateNode, typeof f.componentDidMount == "function") try { f.componentDidMount() } catch (R) { be(s, s.return, R) } if (s = h, f = s.updateQueue, f !== null) { var E = s.stateNode; try { var C = f.shared.hiddenCallbacks; if (C !== null) for (f.shared.hiddenCallbacks = null, f = 0; f < C.length; f++)cd(C[f], E) } catch (R) { be(s, s.return, R) } } o && S & 64 && _f(h), Ho(h, h.return); break; case 27: bf(h); case 26: case 5: mn(f, h, o), o && s === null && S & 4 && Af(h), Ho(h, h.return); break; case 12: mn(f, h, o); break; case 31: mn(f, h, o), o && S & 4 && If(f, h); break; case 13: mn(f, h, o), o && S & 4 && kf(f, h); break; case 22: h.memoizedState === null && mn(f, h, o), Ho(h, h.return); break; case 30: break; default: mn(f, h, o) }n = n.sibling } } function Mr(e, n) { var o = null; e !== null && e.memoizedState !== null && e.memoizedState.cachePool !== null && (o = e.memoizedState.cachePool.pool), e = null, n.memoizedState !== null && n.memoizedState.cachePool !== null && (e = n.memoizedState.cachePool.pool), e !== o && (e != null && e.refCount++, o != null && Co(o)) } function Rr(e, n) { e = null, n.alternate !== null && (e = n.alternate.memoizedState.cache), n = n.memoizedState.cache, n !== e && (n.refCount++, e != null && Co(e)) } function Ot(e, n, o, s) { if (n.subtreeFlags & 10256) for (n = n.child; n !== null;)Gf(e, n, o, s), n = n.sibling } function Gf(e, n, o, s) { var f = n.flags; switch (n.tag) { case 0: case 11: case 15: Ot(e, n, o, s), f & 2048 && qo(9, n); break; case 1: Ot(e, n, o, s); break; case 3: Ot(e, n, o, s), f & 2048 && (e = null, n.alternate !== null && (e = n.alternate.memoizedState.cache), n = n.memoizedState.cache, n !== e && (n.refCount++, e != null && Co(e))); break; case 12: if (f & 2048) { Ot(e, n, o, s), e = n.stateNode; try { var h = n.memoizedProps, S = h.id, E = h.onPostCommit; typeof E == "function" && E(S, n.alternate === null ? "mount" : "update", e.passiveEffectDuration, -0) } catch (C) { be(n, n.return, C) } } else Ot(e, n, o, s); break; case 31: Ot(e, n, o, s); break; case 13: Ot(e, n, o, s); break; case 23: break; case 22: h = n.stateNode, S = n.alternate, n.memoizedState !== null ? h._visibility & 2 ? Ot(e, n, o, s) : Po(e, n) : h._visibility & 2 ? Ot(e, n, o, s) : (h._visibility |= 2, Pi(e, n, o, s, (n.subtreeFlags & 10256) !== 0 || !1)), f & 2048 && Mr(S, n); break; case 24: Ot(e, n, o, s), f & 2048 && Rr(n.alternate, n); break; default: Ot(e, n, o, s) } } function Pi(e, n, o, s, f) { for (f = f && ((n.subtreeFlags & 10256) !== 0 || !1), n = n.child; n !== null;) { var h = e, S = n, E = o, C = s, R = S.flags; switch (S.tag) { case 0: case 11: case 15: Pi(h, S, E, C, f), qo(8, S); break; case 23: break; case 22: var z = S.stateNode; S.memoizedState !== null ? z._visibility & 2 ? Pi(h, S, E, C, f) : Po(h, S) : (z._visibility |= 2, Pi(h, S, E, C, f)), f && R & 2048 && Mr(S.alternate, S); break; case 24: Pi(h, S, E, C, f), f && R & 2048 && Rr(S.alternate, S); break; default: Pi(h, S, E, C, f) }n = n.sibling } } function Po(e, n) { if (n.subtreeFlags & 10256) for (n = n.child; n !== null;) { var o = e, s = n, f = s.flags; switch (s.tag) { case 22: Po(o, s), f & 2048 && Mr(s.alternate, s); break; case 24: Po(o, s), f & 2048 && Rr(s.alternate, s); break; default: Po(o, s) }n = n.sibling } } var Vo = 8192; function Vi(e, n, o) { if (e.subtreeFlags & Vo) for (e = e.child; e !== null;)Lf(e, n, o), e = e.sibling } function Lf(e, n, o) { switch (e.tag) { case 26: Vi(e, n, o), e.flags & Vo && e.memoizedState !== null && rv(o, Bt, e.memoizedState, e.memoizedProps); break; case 5: Vi(e, n, o); break; case 3: case 4: var s = Bt; Bt = fa(e.stateNode.containerInfo), Vi(e, n, o), Bt = s; break; case 22: e.memoizedState === null && (s = e.alternate, s !== null && s.memoizedState !== null ? (s = Vo, Vo = 16777216, Vi(e, n, o), Vo = s) : Vi(e, n, o)); break; default: Vi(e, n, o) } } function zf(e) { var n = e.alternate; if (n !== null && (e = n.child, e !== null)) { n.child = null; do n = e.sibling, e.sibling = null, e = n; while (e !== null) } } function Bo(e) { var n = e.deletions; if ((e.flags & 16) !== 0) { if (n !== null) for (var o = 0; o < n.length; o++) { var s = n[o]; Qe = s, Hf(s, e) } zf(e) } if (e.subtreeFlags & 10256) for (e = e.child; e !== null;)qf(e), e = e.sibling } function qf(e) { switch (e.tag) { case 0: case 11: case 15: Bo(e), e.flags & 2048 && kn(9, e, e.return); break; case 3: Bo(e); break; case 12: Bo(e); break; case 22: var n = e.stateNode; e.memoizedState !== null && n._visibility & 2 && (e.return === null || e.return.tag !== 13) ? (n._visibility &= -3, $l(e)) : Bo(e); break; default: Bo(e) } } function $l(e) { var n = e.deletions; if ((e.flags & 16) !== 0) { if (n !== null) for (var o = 0; o < n.length; o++) { var s = n[o]; Qe = s, Hf(s, e) } zf(e) } for (e = e.child; e !== null;) { switch (n = e, n.tag) { case 0: case 11: case 15: kn(8, n, n.return), $l(n); break; case 22: o = n.stateNode, o._visibility & 2 && (o._visibility &= -3, $l(n)); break; default: $l(n) }e = e.sibling } } function Hf(e, n) { for (; Qe !== null;) { var o = Qe; switch (o.tag) { case 0: case 11: case 15: kn(8, o, n); break; case 23: case 22: if (o.memoizedState !== null && o.memoizedState.cachePool !== null) { var s = o.memoizedState.cachePool.pool; s != null && s.refCount++ } break; case 24: Co(o.memoizedState.cache) }if (s = o.child, s !== null) s.return = o, Qe = s; else e: for (o = e; Qe !== null;) { s = Qe; var f = s.sibling, h = s.return; if (Mf(s), s === o) { Qe = null; break e } if (f !== null) { f.return = h, Qe = f; break e } Qe = h } } } var E0 = { getCacheForType: function (e) { var n = et(Fe), o = n.data.get(e); return o === void 0 && (o = e(), n.data.set(e, o)), o }, cacheSignal: function () { return et(Fe).controller.signal } }, A0 = typeof WeakMap == "function" ? WeakMap : Map, Te = 0, ke = null, de = null, he = 0, Ce = 0, At = null, Dn = !1, Bi = !1, Ir = !1, hn = 0, He = 0, Un = 0, ci = 0, kr = 0, Ct = 0, Oi = 0, Oo = null, pt = null, Dr = !1, ea = 0, Pf = 0, ta = 1 / 0, na = null, Gn = null, Ke = 0, Ln = null, Fi = null, pn = 0, Ur = 0, Gr = null, Vf = null, Fo = 0, Lr = null; function bt() { return (Te & 2) !== 0 && he !== 0 ? he & -he : L.T !== null ? Br() : nc() } function Bf() { if (Ct === 0) if ((he & 536870912) === 0 || ye) { var e = cl; cl <<= 1, (cl & 3932160) === 0 && (cl = 262144), Ct = e } else Ct = 536870912; return e = _t.current, e !== null && (e.flags |= 32), Ct } function gt(e, n, o) { (e === ke && (Ce === 2 || Ce === 9) || e.cancelPendingCommit !== null) && (Yi(e, 0), zn(e, he, Ct, !1)), co(e, o), ((Te & 2) === 0 || e !== ke) && (e === ke && ((Te & 2) === 0 && (ci |= o), He === 4 && zn(e, he, Ct, !1)), jt(e)) } function Of(e, n, o) { if ((Te & 6) !== 0) throw Error(a(327)); var s = !o && (n & 127) === 0 && (n & e.expiredLanes) === 0 || uo(e, n), f = s ? N0(e, n) : qr(e, n, !0), h = s; do { if (f === 0) { Bi && !s && zn(e, n, 0, !1); break } else { if (o = e.current.alternate, h && !C0(o)) { f = qr(e, n, !1), h = !1; continue } if (f === 2) { if (h = n, e.errorRecoveryDisabledLanes & h) var S = 0; else S = e.pendingLanes & -536870913, S = S !== 0 ? S : S & 536870912 ? 536870912 : 0; if (S !== 0) { n = S; e: { var E = e; f = Oo; var C = E.current.memoizedState.isDehydrated; if (C && (Yi(E, S).flags |= 256), S = qr(E, S, !1), S !== 2) { if (Ir && !C) { E.errorRecoveryDisabledLanes |= h, ci |= h, f = 4; break e } h = pt, pt = f, h !== null && (pt === null ? pt = h : pt.push.apply(pt, h)) } f = S } if (h = !1, f !== 2) continue } } if (f === 1) { Yi(e, 0), zn(e, n, 0, !0); break } e: { switch (s = e, h = f, h) { case 0: case 1: throw Error(a(345)); case 4: if ((n & 4194048) !== n) break; case 6: zn(s, n, Ct, !Dn); break e; case 2: pt = null; break; case 3: case 5: break; default: throw Error(a(329)) }if ((n & 62914560) === n && (f = ea + 300 - yt(), 10 < f)) { if (zn(s, n, Ct, !Dn), fl(s, 0, !0) !== 0) break e; pn = n, s.timeoutHandle = Sm(Ff.bind(null, s, o, pt, na, Dr, n, Ct, ci, Oi, Dn, h, "Throttled", -0, 0), f); break e } Ff(s, o, pt, na, Dr, n, Ct, ci, Oi, Dn, h, null, -0, 0) } } break } while (!0); jt(e) } function Ff(e, n, o, s, f, h, S, E, C, R, z, H, I, D) { if (e.timeoutHandle = -1, H = n.subtreeFlags, H & 8192 || (H & 16785408) === 16785408) { H = { stylesheets: null, count: 0, imgCount: 0, imgBytes: 0, suspenseyImages: [], waitingForImages: !0, waitingForViewTransition: !1, unsuspend: $t }, Lf(n, h, H); var X = (h & 62914560) === h ? ea - yt() : (h & 4194048) === h ? Pf - yt() : 0; if (X = uv(H, X), X !== null) { pn = h, e.cancelPendingCommit = X(Zf.bind(null, e, n, h, o, s, f, S, E, C, z, H, null, I, D)), zn(e, h, S, !R); return } } Zf(e, n, h, o, s, f, S, E, C) } function C0(e) { for (var n = e; ;) { var o = n.tag; if ((o === 0 || o === 11 || o === 15) && n.flags & 16384 && (o = n.updateQueue, o !== null && (o = o.stores, o !== null))) for (var s = 0; s < o.length; s++) { var f = o[s], h = f.getSnapshot; f = f.value; try { if (!St(h(), f)) return !1 } catch { return !1 } } if (o = n.child, n.subtreeFlags & 16384 && o !== null) o.return = n, n = o; else { if (n === e) break; for (; n.sibling === null;) { if (n.return === null || n.return === e) return !0; n = n.return } n.sibling.return = n.return, n = n.sibling } } return !0 } function zn(e, n, o, s) { n &= ~kr, n &= ~ci, e.suspendedLanes |= n, e.pingedLanes &= ~n, s && (e.warmLanes |= n), s = e.expirationTimes; for (var f = n; 0 < f;) { var h = 31 - xt(f), S = 1 << h; s[h] = -1, f &= ~S } o !== 0 && $u(e, o, n) } function ia() { return (Te & 6) === 0 ? (Yo(0), !1) : !0 } function zr() { if (de !== null) { if (Ce === 0) var e = de.return; else e = de, on = ti = null, $s(e), Gi = null, No = 0, e = de; for (; e !== null;)Tf(e.alternate, e), e = e.return; de = null } } function Yi(e, n) { var o = e.timeoutHandle; o !== -1 && (e.timeoutHandle = -1, Y0(o)), o = e.cancelPendingCommit, o !== null && (e.cancelPendingCommit = null, o()), pn = 0, zr(), ke = e, de = o = tn(e.current, null), he = n, Ce = 0, At = null, Dn = !1, Bi = uo(e, n), Ir = !1, Oi = Ct = kr = ci = Un = He = 0, pt = Oo = null, Dr = !1, (n & 8) !== 0 && (n |= n & 32); var s = e.entangledLanes; if (s !== 0) for (e = e.entanglements, s &= n; 0 < s;) { var f = 31 - xt(s), h = 1 << f; n |= e[f], s &= ~h } return hn = n, Al(), o } function Yf(e, n) { re = null, L.H = Go, n === Ui || n === kl ? (n = ad(), Ce = 3) : n === Vs ? (n = ad(), Ce = 4) : Ce = n === pr ? 8 : n !== null && typeof n == "object" && typeof n.then == "function" ? 6 : 1, At = n, de === null && (He = 1, Jl(e, Rt(n, e.current))) } function Jf() { var e = _t.current; return e === null ? !0 : (he & 4194048) === he ? Ut === null : (he & 62914560) === he || (he & 536870912) !== 0 ? e === Ut : !1 } function Wf() { var e = L.H; return L.H = Go, e === null ? Go : e } function Kf() { var e = L.A; return L.A = E0, e } function oa() { He = 4, Dn || (he & 4194048) !== he && _t.current !== null || (Bi = !0), (Un & 134217727) === 0 && (ci & 134217727) === 0 || ke === null || zn(ke, he, Ct, !1) } function qr(e, n, o) { var s = Te; Te |= 2; var f = Wf(), h = Kf(); (ke !== e || he !== n) && (na = null, Yi(e, n)), n = !1; var S = He; e: do try { if (Ce !== 0 && de !== null) { var E = de, C = At; switch (Ce) { case 8: zr(), S = 6; break e; case 3: case 2: case 9: case 6: _t.current === null && (n = !0); var R = Ce; if (Ce = 0, At = null, Ji(e, E, C, R), o && Bi) { S = 0; break e } break; default: R = Ce, Ce = 0, At = null, Ji(e, E, C, R) } } b0(), S = He; break } catch (z) { Yf(e, z) } while (!0); return n && e.shellSuspendCounter++, on = ti = null, Te = s, L.H = f, L.A = h, de === null && (ke = null, he = 0, Al()), S } function b0() { for (; de !== null;)Xf(de) } function N0(e, n) { var o = Te; Te |= 2; var s = Wf(), f = Kf(); ke !== e || he !== n ? (na = null, ta = yt() + 500, Yi(e, n)) : Bi = uo(e, n); e: do try { if (Ce !== 0 && de !== null) { n = de; var h = At; t: switch (Ce) { case 1: Ce = 0, At = null, Ji(e, n, h, 1); break; case 2: case 9: if (od(h)) { Ce = 0, At = null, Qf(n); break } n = function () { Ce !== 2 && Ce !== 9 || ke !== e || (Ce = 7), jt(e) }, h.then(n, n); break e; case 3: Ce = 7; break e; case 4: Ce = 5; break e; case 7: od(h) ? (Ce = 0, At = null, Qf(n)) : (Ce = 0, At = null, Ji(e, n, h, 7)); break; case 5: var S = null; switch (de.tag) { case 26: S = de.memoizedState; case 5: case 27: var E = de; if (S ? Gm(S) : E.stateNode.complete) { Ce = 0, At = null; var C = E.sibling; if (C !== null) de = C; else { var R = E.return; R !== null ? (de = R, la(R)) : de = null } break t } }Ce = 0, At = null, Ji(e, n, h, 5); break; case 6: Ce = 0, At = null, Ji(e, n, h, 6); break; case 8: zr(), He = 6; break e; default: throw Error(a(462)) } } w0(); break } catch (z) { Yf(e, z) } while (!0); return on = ti = null, L.H = s, L.A = f, Te = o, de !== null ? 0 : (ke = null, he = 0, Al(), He) } function w0() { for (; de !== null && !jg();)Xf(de) } function Xf(e) { var n = xf(e.alternate, e, hn); e.memoizedProps = e.pendingProps, n === null ? la(e) : de = n } function Qf(e) { var n = e, o = n.alternate; switch (n.tag) { case 15: case 0: n = mf(o, n, n.pendingProps, n.type, void 0, he); break; case 11: n = mf(o, n, n.pendingProps, n.type.render, n.ref, he); break; case 5: $s(n); default: Tf(o, n), n = de = Wc(n, hn), n = xf(o, n, hn) }e.memoizedProps = e.pendingProps, n === null ? la(e) : de = n } function Ji(e, n, o, s) { on = ti = null, $s(n), Gi = null, No = 0; var f = n.return; try { if (g0(e, f, n, o, he)) { He = 1, Jl(e, Rt(o, e.current)), de = null; return } } catch (h) { if (f !== null) throw de = f, h; He = 1, Jl(e, Rt(o, e.current)), de = null; return } n.flags & 32768 ? (ye || s === 1 ? e = !0 : Bi || (he & 536870912) !== 0 ? e = !1 : (Dn = e = !0, (s === 2 || s === 9 || s === 3 || s === 6) && (s = _t.current, s !== null && s.tag === 13 && (s.flags |= 16384))), jf(n, e)) : la(n) } function la(e) { var n = e; do { if ((n.flags & 32768) !== 0) { jf(n, Dn); return } e = n.return; var o = x0(n.alternate, n, hn); if (o !== null) { de = o; return } if (n = n.sibling, n !== null) { de = n; return } de = n = e } while (n !== null); He === 0 && (He = 5) } function jf(e, n) { do { var o = S0(e.alternate, e); if (o !== null) { o.flags &= 32767, de = o; return } if (o = e.return, o !== null && (o.flags |= 32768, o.subtreeFlags = 0, o.deletions = null), !n && (e = e.sibling, e !== null)) { de = e; return } de = e = o } while (e !== null); He = 6, de = null } function Zf(e, n, o, s, f, h, S, E, C) { e.cancelPendingCommit = null; do aa(); while (Ke !== 0); if ((Te & 6) !== 0) throw Error(a(327)); if (n !== null) { if (n === e.current) throw Error(a(177)); if (h = n.lanes | n.childLanes, h |= bs, sy(e, o, h, S, E, C), e === ke && (de = ke = null, he = 0), Fi = n, Ln = e, pn = o, Ur = h, Gr = f, Vf = s, (n.subtreeFlags & 10256) !== 0 || (n.flags & 10256) !== 0 ? (e.callbackNode = null, e.callbackPriority = 0, k0(rl, function () { return im(), null })) : (e.callbackNode = null, e.callbackPriority = 0), s = (n.flags & 13878) !== 0, (n.subtreeFlags & 13878) !== 0 || s) { s = L.T, L.T = null, f = O.p, O.p = 2, S = Te, Te |= 4; try { T0(e, n, o) } finally { Te = S, O.p = f, L.T = s } } Ke = 1, $f(), em(), tm() } } function $f() { if (Ke === 1) { Ke = 0; var e = Ln, n = Fi, o = (n.flags & 13878) !== 0; if ((n.subtreeFlags & 13878) !== 0 || o) { o = L.T, L.T = null; var s = O.p; O.p = 2; var f = Te; Te |= 4; try { Df(n, e); var h = Qr, S = qc(e.containerInfo), E = h.focusedElem, C = h.selectionRange; if (S !== E && E && E.ownerDocument && zc(E.ownerDocument.documentElement, E)) { if (C !== null && Ts(E)) { var R = C.start, z = C.end; if (z === void 0 && (z = R), "selectionStart" in E) E.selectionStart = R, E.selectionEnd = Math.min(z, E.value.length); else { var H = E.ownerDocument || document, I = H && H.defaultView || window; if (I.getSelection) { var D = I.getSelection(), X = E.textContent.length, ne = Math.min(C.start, X), Re = C.end === void 0 ? ne : Math.min(C.end, X); !D.extend && ne > Re && (S = Re, Re = ne, ne = S); var w = Lc(E, ne), b = Lc(E, Re); if (w && b && (D.rangeCount !== 1 || D.anchorNode !== w.node || D.anchorOffset !== w.offset || D.focusNode !== b.node || D.focusOffset !== b.offset)) { var M = H.createRange(); M.setStart(w.node, w.offset), D.removeAllRanges(), ne > Re ? (D.addRange(M), D.extend(b.node, b.offset)) : (M.setEnd(b.node, b.offset), D.addRange(M)) } } } } for (H = [], D = E; D = D.parentNode;)D.nodeType === 1 && H.push({ element: D, left: D.scrollLeft, top: D.scrollTop }); for (typeof E.focus == "function" && E.focus(), E = 0; E < H.length; E++) { var q = H[E]; q.element.scrollLeft = q.left, q.element.scrollTop = q.top } } va = !!Xr, Qr = Xr = null } finally { Te = f, O.p = s, L.T = o } } e.current = n, Ke = 2 } } function em() { if (Ke === 2) { Ke = 0; var e = Ln, n = Fi, o = (n.flags & 8772) !== 0; if ((n.subtreeFlags & 8772) !== 0 || o) { o = L.T, L.T = null; var s = O.p; O.p = 2; var f = Te; Te |= 4; try { wf(e, n.alternate, n) } finally { Te = f, O.p = s, L.T = o } } Ke = 3 } } function tm() { if (Ke === 4 || Ke === 3) { Ke = 0, Zg(); var e = Ln, n = Fi, o = pn, s = Vf; (n.subtreeFlags & 10256) !== 0 || (n.flags & 10256) !== 0 ? Ke = 5 : (Ke = 0, Fi = Ln = null, nm(e, e.pendingLanes)); var f = e.pendingLanes; if (f === 0 && (Gn = null), ns(o), n = n.stateNode, vt && typeof vt.onCommitFiberRoot == "function") try { vt.onCommitFiberRoot(ro, n, void 0, (n.current.flags & 128) === 128) } catch { } if (s !== null) { n = L.T, f = O.p, O.p = 2, L.T = null; try { for (var h = e.onRecoverableError, S = 0; S < s.length; S++) { var E = s[S]; h(E.value, { componentStack: E.stack }) } } finally { L.T = n, O.p = f } } (pn & 3) !== 0 && aa(), jt(e), f = e.pendingLanes, (o & 261930) !== 0 && (f & 42) !== 0 ? e === Lr ? Fo++ : (Fo = 0, Lr = e) : Fo = 0, Yo(0) } } function nm(e, n) { (e.pooledCacheLanes &= n) === 0 && (n = e.pooledCache, n != null && (e.pooledCache = null, Co(n))) } function aa() { return $f(), em(), tm(), im() } function im() { if (Ke !== 5) return !1; var e = Ln, n = Ur; Ur = 0; var o = ns(pn), s = L.T, f = O.p; try { O.p = 32 > o ? 32 : o, L.T = null, o = Gr, Gr = null; var h = Ln, S = pn; if (Ke = 0, Fi = Ln = null, pn = 0, (Te & 6) !== 0) throw Error(a(331)); var E = Te; if (Te |= 4, qf(h.current), Gf(h, h.current, S, o), Te = E, Yo(0, !1), vt && typeof vt.onPostCommitFiberRoot == "function") try { vt.onPostCommitFiberRoot(ro, h) } catch { } return !0 } finally { O.p = f, L.T = s, nm(e, n) } } function om(e, n, o) { n = Rt(o, n), n = hr(e.stateNode, n, 2), e = Mn(e, n, 2), e !== null && (co(e, 2), jt(e)) } function be(e, n, o) { if (e.tag === 3) om(e, e, o); else for (; n !== null;) { if (n.tag === 3) { om(n, e, o); break } else if (n.tag === 1) { var s = n.stateNode; if (typeof n.type.getDerivedStateFromError == "function" || typeof s.componentDidCatch == "function" && (Gn === null || !Gn.has(s))) { e = Rt(o, e), o = lf(2), s = Mn(n, o, 2), s !== null && (af(o, s, n, e), co(s, 2), jt(s)); break } } n = n.return } } function Hr(e, n, o) { var s = e.pingCache; if (s === null) { s = e.pingCache = new A0; var f = new Set; s.set(n, f) } else f = s.get(n), f === void 0 && (f = new Set, s.set(n, f)); f.has(o) || (Ir = !0, f.add(o), e = M0.bind(null, e, n, o), n.then(e, e)) } function M0(e, n, o) { var s = e.pingCache; s !== null && s.delete(n), e.pingedLanes |= e.suspendedLanes & o, e.warmLanes &= ~o, ke === e && (he & o) === o && (He === 4 || He === 3 && (he & 62914560) === he && 300 > yt() - ea ? (Te & 2) === 0 && Yi(e, 0) : kr |= o, Oi === he && (Oi = 0)), jt(e) } function lm(e, n) { n === 0 && (n = Zu()), e = Zn(e, n), e !== null && (co(e, n), jt(e)) } function R0(e) { var n = e.memoizedState, o = 0; n !== null && (o = n.retryLane), lm(e, o) } function I0(e, n) { var o = 0; switch (e.tag) { case 31: case 13: var s = e.stateNode, f = e.memoizedState; f !== null && (o = f.retryLane); break; case 19: s = e.stateNode; break; case 22: s = e.stateNode._retryCache; break; default: throw Error(a(314)) }s !== null && s.delete(n), lm(e, o) } function k0(e, n) { return Za(e, n) } var sa = null, Wi = null, Pr = !1, ra = !1, Vr = !1, qn = 0; function jt(e) { e !== Wi && e.next === null && (Wi === null ? sa = Wi = e : Wi = Wi.next = e), ra = !0, Pr || (Pr = !0, U0()) } function Yo(e, n) { if (!Vr && ra) { Vr = !0; do for (var o = !1, s = sa; s !== null;) { if (e !== 0) { var f = s.pendingLanes; if (f === 0) var h = 0; else { var S = s.suspendedLanes, E = s.pingedLanes; h = (1 << 31 - xt(42 | e) + 1) - 1, h &= f & ~(S & ~E), h = h & 201326741 ? h & 201326741 | 1 : h ? h | 2 : 0 } h !== 0 && (o = !0, um(s, h)) } else h = he, h = fl(s, s === ke ? h : 0, s.cancelPendingCommit !== null || s.timeoutHandle !== -1), (h & 3) === 0 || uo(s, h) || (o = !0, um(s, h)); s = s.next } while (o); Vr = !1 } } function D0() { am() } function am() { ra = Pr = !1; var e = 0; qn !== 0 && F0() && (e = qn); for (var n = yt(), o = null, s = sa; s !== null;) { var f = s.next, h = sm(s, n); h === 0 ? (s.next = null, o === null ? sa = f : o.next = f, f === null && (Wi = o)) : (o = s, (e !== 0 || (h & 3) !== 0) && (ra = !0)), s = f } Ke !== 0 && Ke !== 5 || Yo(e), qn !== 0 && (qn = 0) } function sm(e, n) { for (var o = e.suspendedLanes, s = e.pingedLanes, f = e.expirationTimes, h = e.pendingLanes & -62914561; 0 < h;) { var S = 31 - xt(h), E = 1 << S, C = f[S]; C === -1 ? ((E & o) === 0 || (E & s) !== 0) && (f[S] = ay(E, n)) : C <= n && (e.expiredLanes |= E), h &= ~E } if (n = ke, o = he, o = fl(e, e === n ? o : 0, e.cancelPendingCommit !== null || e.timeoutHandle !== -1), s = e.callbackNode, o === 0 || e === n && (Ce === 2 || Ce === 9) || e.cancelPendingCommit !== null) return s !== null && s !== null && $a(s), e.callbackNode = null, e.callbackPriority = 0; if ((o & 3) === 0 || uo(e, o)) { if (n = o & -o, n === e.callbackPriority) return n; switch (s !== null && $a(s), ns(o)) { case 2: case 8: o = Qu; break; case 32: o = rl; break; case 268435456: o = ju; break; default: o = rl }return s = rm.bind(null, e), o = Za(o, s), e.callbackPriority = n, e.callbackNode = o, n } return s !== null && s !== null && $a(s), e.callbackPriority = 2, e.callbackNode = null, 2 } function rm(e, n) { if (Ke !== 0 && Ke !== 5) return e.callbackNode = null, e.callbackPriority = 0, null; var o = e.callbackNode; if (aa() && e.callbackNode !== o) return null; var s = he; return s = fl(e, e === ke ? s : 0, e.cancelPendingCommit !== null || e.timeoutHandle !== -1), s === 0 ? null : (Of(e, s, n), sm(e, yt()), e.callbackNode != null && e.callbackNode === o ? rm.bind(null, e) : null) } function um(e, n) { if (aa()) return null; Of(e, n, !0) } function U0() { J0(function () { (Te & 6) !== 0 ? Za(Xu, D0) : am() }) } function Br() { if (qn === 0) { var e = ki; e === 0 && (e = ul, ul <<= 1, (ul & 261888) === 0 && (ul = 256)), qn = e } return qn } function cm(e) { return e == null || typeof e == "symbol" || typeof e == "boolean" ? null : typeof e == "function" ? e : gl("" + e) } function dm(e, n) { var o = n.ownerDocument.createElement("input"); return o.name = n.name, o.value = n.value, e.id && o.setAttribute("form", e.id), n.parentNode.insertBefore(o, n), e = new FormData(e), o.parentNode.removeChild(o), e } function G0(e, n, o, s, f) { if (n === "submit" && o && o.stateNode === f) { var h = cm((f[ct] || null).action), S = s.submitter; S && (n = (n = S[ct] || null) ? cm(n.formAction) : S.getAttribute("formAction"), n !== null && (h = n, S = null)); var E = new Sl("action", "action", null, s, f); e.push({ event: E, listeners: [{ instance: null, listener: function () { if (s.defaultPrevented) { if (qn !== 0) { var C = S ? dm(f, S) : new FormData(f); rr(o, { pending: !0, data: C, method: f.method, action: h }, null, C) } } else typeof h == "function" && (E.preventDefault(), C = S ? dm(f, S) : new FormData(f), rr(o, { pending: !0, data: C, method: f.method, action: h }, h, C)) }, currentTarget: f }] }) } } for (var Or = 0; Or < Cs.length; Or++) { var Fr = Cs[Or], L0 = Fr.toLowerCase(), z0 = Fr[0].toUpperCase() + Fr.slice(1); Vt(L0, "on" + z0) } Vt(Vc, "onAnimationEnd"), Vt(Bc, "onAnimationIteration"), Vt(Oc, "onAnimationStart"), Vt("dblclick", "onDoubleClick"), Vt("focusin", "onFocus"), Vt("focusout", "onBlur"), Vt($y, "onTransitionRun"), Vt(e0, "onTransitionStart"), Vt(t0, "onTransitionCancel"), Vt(Fc, "onTransitionEnd"), vi("onMouseEnter", ["mouseout", "mouseover"]), vi("onMouseLeave", ["mouseout", "mouseover"]), vi("onPointerEnter", ["pointerout", "pointerover"]), vi("onPointerLeave", ["pointerout", "pointerover"]), Kn("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), Kn("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), Kn("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), Kn("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), Kn("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), Kn("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Jo = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), q0 = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Jo)); function fm(e, n) { n = (n & 4) !== 0; for (var o = 0; o < e.length; o++) { var s = e[o], f = s.event; s = s.listeners; e: { var h = void 0; if (n) for (var S = s.length - 1; 0 <= S; S--) { var E = s[S], C = E.instance, R = E.currentTarget; if (E = E.listener, C !== h && f.isPropagationStopped()) break e; h = E, f.currentTarget = R; try { h(f) } catch (z) { El(z) } f.currentTarget = null, h = C } else for (S = 0; S < s.length; S++) { if (E = s[S], C = E.instance, R = E.currentTarget, E = E.listener, C !== h && f.isPropagationStopped()) break e; h = E, f.currentTarget = R; try { h(f) } catch (z) { El(z) } f.currentTarget = null, h = C } } } } function fe(e, n) { var o = n[is]; o === void 0 && (o = n[is] = new Set); var s = e + "__bubble"; o.has(s) || (mm(n, e, 2, !1), o.add(s)) } function Yr(e, n, o) { var s = 0; n && (s |= 4), mm(o, e, s, n) } var ua = "_reactListening" + Math.random().toString(36).slice(2); function Jr(e) { if (!e[ua]) { e[ua] = !0, lc.forEach(function (o) { o !== "selectionchange" && (q0.has(o) || Yr(o, !1, e), Yr(o, !0, e)) }); var n = e.nodeType === 9 ? e : e.ownerDocument; n === null || n[ua] || (n[ua] = !0, Yr("selectionchange", !1, n)) } } function mm(e, n, o, s) { switch (Bm(n)) { case 2: var f = fv; break; case 8: f = mv; break; default: f = su }o = f.bind(null, n, o, e), f = void 0, !fs || n !== "touchstart" && n !== "touchmove" && n !== "wheel" || (f = !0), s ? f !== void 0 ? e.addEventListener(n, o, { capture: !0, passive: f }) : e.addEventListener(n, o, !0) : f !== void 0 ? e.addEventListener(n, o, { passive: f }) : e.addEventListener(n, o, !1) } function Wr(e, n, o, s, f) { var h = s; if ((n & 1) === 0 && (n & 2) === 0 && s !== null) e: for (; ;) { if (s === null) return; var S = s.tag; if (S === 3 || S === 4) { var E = s.stateNode.containerInfo; if (E === f) break; if (S === 4) for (S = s.return; S !== null;) { var C = S.tag; if ((C === 3 || C === 4) && S.stateNode.containerInfo === f) return; S = S.return } for (; E !== null;) { if (S = pi(E), S === null) return; if (C = S.tag, C === 5 || C === 6 || C === 26 || C === 27) { s = h = S; continue e } E = E.parentNode } } s = s.return } yc(function () { var R = h, z = cs(o), H = []; e: { var I = Yc.get(e); if (I !== void 0) { var D = Sl, X = e; switch (e) { case "keypress": if (vl(o) === 0) break e; case "keydown": case "keyup": D = Iy; break; case "focusin": X = "focus", D = gs; break; case "focusout": X = "blur", D = gs; break; case "beforeblur": case "afterblur": D = gs; break; case "click": if (o.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": D = Sc; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": D = xy; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": D = Uy; break; case Vc: case Bc: case Oc: D = _y; break; case Fc: D = Ly; break; case "scroll": case "scrollend": D = yy; break; case "wheel": D = qy; break; case "copy": case "cut": case "paste": D = Ay; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": D = _c; break; case "toggle": case "beforetoggle": D = Py }var ne = (n & 4) !== 0, Re = !ne && (e === "scroll" || e === "scrollend"), w = ne ? I !== null ? I + "Capture" : null : I; ne = []; for (var b = R, M; b !== null;) { var q = b; if (M = q.stateNode, q = q.tag, q !== 5 && q !== 26 && q !== 27 || M === null || w === null || (q = ho(b, w), q != null && ne.push(Wo(b, q, M))), Re) break; b = b.return } 0 < ne.length && (I = new D(I, X, null, o, z), H.push({ event: I, listeners: ne })) } } if ((n & 7) === 0) { e: { if (I = e === "mouseover" || e === "pointerover", D = e === "mouseout" || e === "pointerout", I && o !== us && (X = o.relatedTarget || o.fromElement) && (pi(X) || X[hi])) break e; if ((D || I) && (I = z.window === z ? z : (I = z.ownerDocument) ? I.defaultView || I.parentWindow : window, D ? (X = o.relatedTarget || o.toElement, D = R, X = X ? pi(X) : null, X !== null && (Re = d(X), ne = X.tag, X !== Re || ne !== 5 && ne !== 27 && ne !== 6) && (X = null)) : (D = null, X = R), D !== X)) { if (ne = Sc, q = "onMouseLeave", w = "onMouseEnter", b = "mouse", (e === "pointerout" || e === "pointerover") && (ne = _c, q = "onPointerLeave", w = "onPointerEnter", b = "pointer"), Re = D == null ? I : mo(D), M = X == null ? I : mo(X), I = new ne(q, b + "leave", D, o, z), I.target = Re, I.relatedTarget = M, q = null, pi(z) === R && (ne = new ne(w, b + "enter", X, o, z), ne.target = M, ne.relatedTarget = Re, q = ne), Re = q, D && X) t: { for (ne = H0, w = D, b = X, M = 0, q = w; q; q = ne(q))M++; q = 0; for (var $ = b; $; $ = ne($))q++; for (; 0 < M - q;)w = ne(w), M--; for (; 0 < q - M;)b = ne(b), q--; for (; M--;) { if (w === b || b !== null && w === b.alternate) { ne = w; break t } w = ne(w), b = ne(b) } ne = null } else ne = null; D !== null && hm(H, I, D, ne, !1), X !== null && Re !== null && hm(H, Re, X, ne, !0) } } e: { if (I = R ? mo(R) : window, D = I.nodeName && I.nodeName.toLowerCase(), D === "select" || D === "input" && I.type === "file") var ve = Rc; else if (wc(I)) if (Ic) ve = Qy; else { ve = Ky; var j = Wy } else D = I.nodeName, !D || D.toLowerCase() !== "input" || I.type !== "checkbox" && I.type !== "radio" ? R && rs(R.elementType) && (ve = Rc) : ve = Xy; if (ve && (ve = ve(e, R))) { Mc(H, ve, o, z); break e } j && j(e, I, R), e === "focusout" && R && I.type === "number" && R.memoizedProps.value != null && ss(I, "number", I.value) } switch (j = R ? mo(R) : window, e) { case "focusin": (wc(j) || j.contentEditable === "true") && (Ai = j, _s = R, _o = null); break; case "focusout": _o = _s = Ai = null; break; case "mousedown": Es = !0; break; case "contextmenu": case "mouseup": case "dragend": Es = !1, Hc(H, o, z); break; case "selectionchange": if (Zy) break; case "keydown": case "keyup": Hc(H, o, z) }var ue; if (vs) e: { switch (e) { case "compositionstart": var pe = "onCompositionStart"; break e; case "compositionend": pe = "onCompositionEnd"; break e; case "compositionupdate": pe = "onCompositionUpdate"; break e }pe = void 0 } else Ei ? bc(e, o) && (pe = "onCompositionEnd") : e === "keydown" && o.keyCode === 229 && (pe = "onCompositionStart"); pe && (Ec && o.locale !== "ko" && (Ei || pe !== "onCompositionStart" ? pe === "onCompositionEnd" && Ei && (ue = vc()) : (_n = z, ms = "value" in _n ? _n.value : _n.textContent, Ei = !0)), j = ca(R, pe), 0 < j.length && (pe = new Tc(pe, e, null, o, z), H.push({ event: pe, listeners: j }), ue ? pe.data = ue : (ue = Nc(o), ue !== null && (pe.data = ue)))), (ue = By ? Oy(e, o) : Fy(e, o)) && (pe = ca(R, "onBeforeInput"), 0 < pe.length && (j = new Tc("onBeforeInput", "beforeinput", null, o, z), H.push({ event: j, listeners: pe }), j.data = ue)), G0(H, e, R, o, z) } fm(H, n) }) } function Wo(e, n, o) { return { instance: e, listener: n, currentTarget: o } } function ca(e, n) { for (var o = n + "Capture", s = []; e !== null;) { var f = e, h = f.stateNode; if (f = f.tag, f !== 5 && f !== 26 && f !== 27 || h === null || (f = ho(e, o), f != null && s.unshift(Wo(e, f, h)), f = ho(e, n), f != null && s.push(Wo(e, f, h))), e.tag === 3) return s; e = e.return } return [] } function H0(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5 && e.tag !== 27); return e || null } function hm(e, n, o, s, f) { for (var h = n._reactName, S = []; o !== null && o !== s;) { var E = o, C = E.alternate, R = E.stateNode; if (E = E.tag, C !== null && C === s) break; E !== 5 && E !== 26 && E !== 27 || R === null || (C = R, f ? (R = ho(o, h), R != null && S.unshift(Wo(o, R, C))) : f || (R = ho(o, h), R != null && S.push(Wo(o, R, C)))), o = o.return } S.length !== 0 && e.push({ event: n, listeners: S }) } var P0 = /\r\n?/g, V0 = /\u0000|\uFFFD/g; function pm(e) {
    return (typeof e == "string" ? e : "" + e).replace(P0, `
`).replace(V0, "")
  } function gm(e, n) { return n = pm(n), pm(e) === n } function Me(e, n, o, s, f, h) { switch (o) { case "children": typeof s == "string" ? n === "body" || n === "textarea" && s === "" || Si(e, s) : (typeof s == "number" || typeof s == "bigint") && n !== "body" && Si(e, "" + s); break; case "className": hl(e, "class", s); break; case "tabIndex": hl(e, "tabindex", s); break; case "dir": case "role": case "viewBox": case "width": case "height": hl(e, o, s); break; case "style": pc(e, s, h); break; case "data": if (n !== "object") { hl(e, "data", s); break } case "src": case "href": if (s === "" && (n !== "a" || o !== "href")) { e.removeAttribute(o); break } if (s == null || typeof s == "function" || typeof s == "symbol" || typeof s == "boolean") { e.removeAttribute(o); break } s = gl("" + s), e.setAttribute(o, s); break; case "action": case "formAction": if (typeof s == "function") { e.setAttribute(o, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"); break } else typeof h == "function" && (o === "formAction" ? (n !== "input" && Me(e, n, "name", f.name, f, null), Me(e, n, "formEncType", f.formEncType, f, null), Me(e, n, "formMethod", f.formMethod, f, null), Me(e, n, "formTarget", f.formTarget, f, null)) : (Me(e, n, "encType", f.encType, f, null), Me(e, n, "method", f.method, f, null), Me(e, n, "target", f.target, f, null))); if (s == null || typeof s == "symbol" || typeof s == "boolean") { e.removeAttribute(o); break } s = gl("" + s), e.setAttribute(o, s); break; case "onClick": s != null && (e.onclick = $t); break; case "onScroll": s != null && fe("scroll", e); break; case "onScrollEnd": s != null && fe("scrollend", e); break; case "dangerouslySetInnerHTML": if (s != null) { if (typeof s != "object" || !("__html" in s)) throw Error(a(61)); if (o = s.__html, o != null) { if (f.children != null) throw Error(a(60)); e.innerHTML = o } } break; case "multiple": e.multiple = s && typeof s != "function" && typeof s != "symbol"; break; case "muted": e.muted = s && typeof s != "function" && typeof s != "symbol"; break; case "suppressContentEditableWarning": case "suppressHydrationWarning": case "defaultValue": case "defaultChecked": case "innerHTML": case "ref": break; case "autoFocus": break; case "xlinkHref": if (s == null || typeof s == "function" || typeof s == "boolean" || typeof s == "symbol") { e.removeAttribute("xlink:href"); break } o = gl("" + s), e.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", o); break; case "contentEditable": case "spellCheck": case "draggable": case "value": case "autoReverse": case "externalResourcesRequired": case "focusable": case "preserveAlpha": s != null && typeof s != "function" && typeof s != "symbol" ? e.setAttribute(o, "" + s) : e.removeAttribute(o); break; case "inert": case "allowFullScreen": case "async": case "autoPlay": case "controls": case "default": case "defer": case "disabled": case "disablePictureInPicture": case "disableRemotePlayback": case "formNoValidate": case "hidden": case "loop": case "noModule": case "noValidate": case "open": case "playsInline": case "readOnly": case "required": case "reversed": case "scoped": case "seamless": case "itemScope": s && typeof s != "function" && typeof s != "symbol" ? e.setAttribute(o, "") : e.removeAttribute(o); break; case "capture": case "download": s === !0 ? e.setAttribute(o, "") : s !== !1 && s != null && typeof s != "function" && typeof s != "symbol" ? e.setAttribute(o, s) : e.removeAttribute(o); break; case "cols": case "rows": case "size": case "span": s != null && typeof s != "function" && typeof s != "symbol" && !isNaN(s) && 1 <= s ? e.setAttribute(o, s) : e.removeAttribute(o); break; case "rowSpan": case "start": s == null || typeof s == "function" || typeof s == "symbol" || isNaN(s) ? e.removeAttribute(o) : e.setAttribute(o, s); break; case "popover": fe("beforetoggle", e), fe("toggle", e), ml(e, "popover", s); break; case "xlinkActuate": Zt(e, "http://www.w3.org/1999/xlink", "xlink:actuate", s); break; case "xlinkArcrole": Zt(e, "http://www.w3.org/1999/xlink", "xlink:arcrole", s); break; case "xlinkRole": Zt(e, "http://www.w3.org/1999/xlink", "xlink:role", s); break; case "xlinkShow": Zt(e, "http://www.w3.org/1999/xlink", "xlink:show", s); break; case "xlinkTitle": Zt(e, "http://www.w3.org/1999/xlink", "xlink:title", s); break; case "xlinkType": Zt(e, "http://www.w3.org/1999/xlink", "xlink:type", s); break; case "xmlBase": Zt(e, "http://www.w3.org/XML/1998/namespace", "xml:base", s); break; case "xmlLang": Zt(e, "http://www.w3.org/XML/1998/namespace", "xml:lang", s); break; case "xmlSpace": Zt(e, "http://www.w3.org/XML/1998/namespace", "xml:space", s); break; case "is": ml(e, "is", s); break; case "innerText": case "textContent": break; default: (!(2 < o.length) || o[0] !== "o" && o[0] !== "O" || o[1] !== "n" && o[1] !== "N") && (o = py.get(o) || o, ml(e, o, s)) } } function Kr(e, n, o, s, f, h) { switch (o) { case "style": pc(e, s, h); break; case "dangerouslySetInnerHTML": if (s != null) { if (typeof s != "object" || !("__html" in s)) throw Error(a(61)); if (o = s.__html, o != null) { if (f.children != null) throw Error(a(60)); e.innerHTML = o } } break; case "children": typeof s == "string" ? Si(e, s) : (typeof s == "number" || typeof s == "bigint") && Si(e, "" + s); break; case "onScroll": s != null && fe("scroll", e); break; case "onScrollEnd": s != null && fe("scrollend", e); break; case "onClick": s != null && (e.onclick = $t); break; case "suppressContentEditableWarning": case "suppressHydrationWarning": case "innerHTML": case "ref": break; case "innerText": case "textContent": break; default: if (!ac.hasOwnProperty(o)) e: { if (o[0] === "o" && o[1] === "n" && (f = o.endsWith("Capture"), n = o.slice(2, f ? o.length - 7 : void 0), h = e[ct] || null, h = h != null ? h[o] : null, typeof h == "function" && e.removeEventListener(n, h, f), typeof s == "function")) { typeof h != "function" && h !== null && (o in e ? e[o] = null : e.hasAttribute(o) && e.removeAttribute(o)), e.addEventListener(n, s, f); break e } o in e ? e[o] = s : s === !0 ? e.setAttribute(o, "") : ml(e, o, s) } } } function nt(e, n, o) { switch (n) { case "div": case "span": case "svg": case "path": case "a": case "g": case "p": case "li": break; case "img": fe("error", e), fe("load", e); var s = !1, f = !1, h; for (h in o) if (o.hasOwnProperty(h)) { var S = o[h]; if (S != null) switch (h) { case "src": s = !0; break; case "srcSet": f = !0; break; case "children": case "dangerouslySetInnerHTML": throw Error(a(137, n)); default: Me(e, n, h, S, o, null) } } f && Me(e, n, "srcSet", o.srcSet, o, null), s && Me(e, n, "src", o.src, o, null); return; case "input": fe("invalid", e); var E = h = S = f = null, C = null, R = null; for (s in o) if (o.hasOwnProperty(s)) { var z = o[s]; if (z != null) switch (s) { case "name": f = z; break; case "type": S = z; break; case "checked": C = z; break; case "defaultChecked": R = z; break; case "value": h = z; break; case "defaultValue": E = z; break; case "children": case "dangerouslySetInnerHTML": if (z != null) throw Error(a(137, n)); break; default: Me(e, n, s, z, o, null) } } dc(e, h, E, C, R, S, f, !1); return; case "select": fe("invalid", e), s = S = h = null; for (f in o) if (o.hasOwnProperty(f) && (E = o[f], E != null)) switch (f) { case "value": h = E; break; case "defaultValue": S = E; break; case "multiple": s = E; default: Me(e, n, f, E, o, null) }n = h, o = S, e.multiple = !!s, n != null ? xi(e, !!s, n, !1) : o != null && xi(e, !!s, o, !0); return; case "textarea": fe("invalid", e), h = f = s = null; for (S in o) if (o.hasOwnProperty(S) && (E = o[S], E != null)) switch (S) { case "value": s = E; break; case "defaultValue": f = E; break; case "children": h = E; break; case "dangerouslySetInnerHTML": if (E != null) throw Error(a(91)); break; default: Me(e, n, S, E, o, null) }mc(e, s, f, h); return; case "option": for (C in o) if (o.hasOwnProperty(C) && (s = o[C], s != null)) switch (C) { case "selected": e.selected = s && typeof s != "function" && typeof s != "symbol"; break; default: Me(e, n, C, s, o, null) }return; case "dialog": fe("beforetoggle", e), fe("toggle", e), fe("cancel", e), fe("close", e); break; case "iframe": case "object": fe("load", e); break; case "video": case "audio": for (s = 0; s < Jo.length; s++)fe(Jo[s], e); break; case "image": fe("error", e), fe("load", e); break; case "details": fe("toggle", e); break; case "embed": case "source": case "link": fe("error", e), fe("load", e); case "area": case "base": case "br": case "col": case "hr": case "keygen": case "meta": case "param": case "track": case "wbr": case "menuitem": for (R in o) if (o.hasOwnProperty(R) && (s = o[R], s != null)) switch (R) { case "children": case "dangerouslySetInnerHTML": throw Error(a(137, n)); default: Me(e, n, R, s, o, null) }return; default: if (rs(n)) { for (z in o) o.hasOwnProperty(z) && (s = o[z], s !== void 0 && Kr(e, n, z, s, o, void 0)); return } }for (E in o) o.hasOwnProperty(E) && (s = o[E], s != null && Me(e, n, E, s, o, null)) } function B0(e, n, o, s) { switch (n) { case "div": case "span": case "svg": case "path": case "a": case "g": case "p": case "li": break; case "input": var f = null, h = null, S = null, E = null, C = null, R = null, z = null; for (D in o) { var H = o[D]; if (o.hasOwnProperty(D) && H != null) switch (D) { case "checked": break; case "value": break; case "defaultValue": C = H; default: s.hasOwnProperty(D) || Me(e, n, D, null, s, H) } } for (var I in s) { var D = s[I]; if (H = o[I], s.hasOwnProperty(I) && (D != null || H != null)) switch (I) { case "type": h = D; break; case "name": f = D; break; case "checked": R = D; break; case "defaultChecked": z = D; break; case "value": S = D; break; case "defaultValue": E = D; break; case "children": case "dangerouslySetInnerHTML": if (D != null) throw Error(a(137, n)); break; default: D !== H && Me(e, n, I, D, s, H) } } as(e, S, E, C, R, z, h, f); return; case "select": D = S = E = I = null; for (h in o) if (C = o[h], o.hasOwnProperty(h) && C != null) switch (h) { case "value": break; case "multiple": D = C; default: s.hasOwnProperty(h) || Me(e, n, h, null, s, C) }for (f in s) if (h = s[f], C = o[f], s.hasOwnProperty(f) && (h != null || C != null)) switch (f) { case "value": I = h; break; case "defaultValue": E = h; break; case "multiple": S = h; default: h !== C && Me(e, n, f, h, s, C) }n = E, o = S, s = D, I != null ? xi(e, !!o, I, !1) : !!s != !!o && (n != null ? xi(e, !!o, n, !0) : xi(e, !!o, o ? [] : "", !1)); return; case "textarea": D = I = null; for (E in o) if (f = o[E], o.hasOwnProperty(E) && f != null && !s.hasOwnProperty(E)) switch (E) { case "value": break; case "children": break; default: Me(e, n, E, null, s, f) }for (S in s) if (f = s[S], h = o[S], s.hasOwnProperty(S) && (f != null || h != null)) switch (S) { case "value": I = f; break; case "defaultValue": D = f; break; case "children": break; case "dangerouslySetInnerHTML": if (f != null) throw Error(a(91)); break; default: f !== h && Me(e, n, S, f, s, h) }fc(e, I, D); return; case "option": for (var X in o) if (I = o[X], o.hasOwnProperty(X) && I != null && !s.hasOwnProperty(X)) switch (X) { case "selected": e.selected = !1; break; default: Me(e, n, X, null, s, I) }for (C in s) if (I = s[C], D = o[C], s.hasOwnProperty(C) && I !== D && (I != null || D != null)) switch (C) { case "selected": e.selected = I && typeof I != "function" && typeof I != "symbol"; break; default: Me(e, n, C, I, s, D) }return; case "img": case "link": case "area": case "base": case "br": case "col": case "embed": case "hr": case "keygen": case "meta": case "param": case "source": case "track": case "wbr": case "menuitem": for (var ne in o) I = o[ne], o.hasOwnProperty(ne) && I != null && !s.hasOwnProperty(ne) && Me(e, n, ne, null, s, I); for (R in s) if (I = s[R], D = o[R], s.hasOwnProperty(R) && I !== D && (I != null || D != null)) switch (R) { case "children": case "dangerouslySetInnerHTML": if (I != null) throw Error(a(137, n)); break; default: Me(e, n, R, I, s, D) }return; default: if (rs(n)) { for (var Re in o) I = o[Re], o.hasOwnProperty(Re) && I !== void 0 && !s.hasOwnProperty(Re) && Kr(e, n, Re, void 0, s, I); for (z in s) I = s[z], D = o[z], !s.hasOwnProperty(z) || I === D || I === void 0 && D === void 0 || Kr(e, n, z, I, s, D); return } }for (var w in o) I = o[w], o.hasOwnProperty(w) && I != null && !s.hasOwnProperty(w) && Me(e, n, w, null, s, I); for (H in s) I = s[H], D = o[H], !s.hasOwnProperty(H) || I === D || I == null && D == null || Me(e, n, H, I, s, D) } function ym(e) { switch (e) { case "css": case "script": case "font": case "img": case "image": case "input": case "link": return !0; default: return !1 } } function O0() { if (typeof performance.getEntriesByType == "function") { for (var e = 0, n = 0, o = performance.getEntriesByType("resource"), s = 0; s < o.length; s++) { var f = o[s], h = f.transferSize, S = f.initiatorType, E = f.duration; if (h && E && ym(S)) { for (S = 0, E = f.responseEnd, s += 1; s < o.length; s++) { var C = o[s], R = C.startTime; if (R > E) break; var z = C.transferSize, H = C.initiatorType; z && ym(H) && (C = C.responseEnd, S += z * (C < E ? 1 : (E - R) / (C - R))) } if (--s, n += 8 * (h + S) / (f.duration / 1e3), e++, 10 < e) break } } if (0 < e) return n / e / 1e6 } return navigator.connection && (e = navigator.connection.downlink, typeof e == "number") ? e : 5 } var Xr = null, Qr = null; function da(e) { return e.nodeType === 9 ? e : e.ownerDocument } function vm(e) { switch (e) { case "http://www.w3.org/2000/svg": return 1; case "http://www.w3.org/1998/Math/MathML": return 2; default: return 0 } } function xm(e, n) { if (e === 0) switch (n) { case "svg": return 1; case "math": return 2; default: return 0 }return e === 1 && n === "foreignObject" ? 0 : e } function jr(e, n) { return e === "textarea" || e === "noscript" || typeof n.children == "string" || typeof n.children == "number" || typeof n.children == "bigint" || typeof n.dangerouslySetInnerHTML == "object" && n.dangerouslySetInnerHTML !== null && n.dangerouslySetInnerHTML.__html != null } var Zr = null; function F0() { var e = window.event; return e && e.type === "popstate" ? e === Zr ? !1 : (Zr = e, !0) : (Zr = null, !1) } var Sm = typeof setTimeout == "function" ? setTimeout : void 0, Y0 = typeof clearTimeout == "function" ? clearTimeout : void 0, Tm = typeof Promise == "function" ? Promise : void 0, J0 = typeof queueMicrotask == "function" ? queueMicrotask : typeof Tm < "u" ? function (e) { return Tm.resolve(null).then(e).catch(W0) } : Sm; function W0(e) { setTimeout(function () { throw e }) } function Hn(e) { return e === "head" } function _m(e, n) { var o = n, s = 0; do { var f = o.nextSibling; if (e.removeChild(o), f && f.nodeType === 8) if (o = f.data, o === "/$" || o === "/&") { if (s === 0) { e.removeChild(f), ji(n); return } s-- } else if (o === "$" || o === "$?" || o === "$~" || o === "$!" || o === "&") s++; else if (o === "html") Ko(e.ownerDocument.documentElement); else if (o === "head") { o = e.ownerDocument.head, Ko(o); for (var h = o.firstChild; h;) { var S = h.nextSibling, E = h.nodeName; h[fo] || E === "SCRIPT" || E === "STYLE" || E === "LINK" && h.rel.toLowerCase() === "stylesheet" || o.removeChild(h), h = S } } else o === "body" && Ko(e.ownerDocument.body); o = f } while (o); ji(n) } function Em(e, n) { var o = e; e = 0; do { var s = o.nextSibling; if (o.nodeType === 1 ? n ? (o._stashedDisplay = o.style.display, o.style.display = "none") : (o.style.display = o._stashedDisplay || "", o.getAttribute("style") === "" && o.removeAttribute("style")) : o.nodeType === 3 && (n ? (o._stashedText = o.nodeValue, o.nodeValue = "") : o.nodeValue = o._stashedText || ""), s && s.nodeType === 8) if (o = s.data, o === "/$") { if (e === 0) break; e-- } else o !== "$" && o !== "$?" && o !== "$~" && o !== "$!" || e++; o = s } while (o) } function $r(e) { var n = e.firstChild; for (n && n.nodeType === 10 && (n = n.nextSibling); n;) { var o = n; switch (n = n.nextSibling, o.nodeName) { case "HTML": case "HEAD": case "BODY": $r(o), os(o); continue; case "SCRIPT": case "STYLE": continue; case "LINK": if (o.rel.toLowerCase() === "stylesheet") continue }e.removeChild(o) } } function K0(e, n, o, s) { for (; e.nodeType === 1;) { var f = o; if (e.nodeName.toLowerCase() !== n.toLowerCase()) { if (!s && (e.nodeName !== "INPUT" || e.type !== "hidden")) break } else if (s) { if (!e[fo]) switch (n) { case "meta": if (!e.hasAttribute("itemprop")) break; return e; case "link": if (h = e.getAttribute("rel"), h === "stylesheet" && e.hasAttribute("data-precedence")) break; if (h !== f.rel || e.getAttribute("href") !== (f.href == null || f.href === "" ? null : f.href) || e.getAttribute("crossorigin") !== (f.crossOrigin == null ? null : f.crossOrigin) || e.getAttribute("title") !== (f.title == null ? null : f.title)) break; return e; case "style": if (e.hasAttribute("data-precedence")) break; return e; case "script": if (h = e.getAttribute("src"), (h !== (f.src == null ? null : f.src) || e.getAttribute("type") !== (f.type == null ? null : f.type) || e.getAttribute("crossorigin") !== (f.crossOrigin == null ? null : f.crossOrigin)) && h && e.hasAttribute("async") && !e.hasAttribute("itemprop")) break; return e; default: return e } } else if (n === "input" && e.type === "hidden") { var h = f.name == null ? null : "" + f.name; if (f.type === "hidden" && e.getAttribute("name") === h) return e } else return e; if (e = Gt(e.nextSibling), e === null) break } return null } function X0(e, n, o) { if (n === "") return null; for (; e.nodeType !== 3;)if ((e.nodeType !== 1 || e.nodeName !== "INPUT" || e.type !== "hidden") && !o || (e = Gt(e.nextSibling), e === null)) return null; return e } function Am(e, n) { for (; e.nodeType !== 8;)if ((e.nodeType !== 1 || e.nodeName !== "INPUT" || e.type !== "hidden") && !n || (e = Gt(e.nextSibling), e === null)) return null; return e } function eu(e) { return e.data === "$?" || e.data === "$~" } function tu(e) { return e.data === "$!" || e.data === "$?" && e.ownerDocument.readyState !== "loading" } function Q0(e, n) { var o = e.ownerDocument; if (e.data === "$~") e._reactRetry = n; else if (e.data !== "$?" || o.readyState !== "loading") n(); else { var s = function () { n(), o.removeEventListener("DOMContentLoaded", s) }; o.addEventListener("DOMContentLoaded", s), e._reactRetry = s } } function Gt(e) { for (; e != null; e = e.nextSibling) { var n = e.nodeType; if (n === 1 || n === 3) break; if (n === 8) { if (n = e.data, n === "$" || n === "$!" || n === "$?" || n === "$~" || n === "&" || n === "F!" || n === "F") break; if (n === "/$" || n === "/&") return null } } return e } var nu = null; function Cm(e) { e = e.nextSibling; for (var n = 0; e;) { if (e.nodeType === 8) { var o = e.data; if (o === "/$" || o === "/&") { if (n === 0) return Gt(e.nextSibling); n-- } else o !== "$" && o !== "$!" && o !== "$?" && o !== "$~" && o !== "&" || n++ } e = e.nextSibling } return null } function bm(e) { e = e.previousSibling; for (var n = 0; e;) { if (e.nodeType === 8) { var o = e.data; if (o === "$" || o === "$!" || o === "$?" || o === "$~" || o === "&") { if (n === 0) return e; n-- } else o !== "/$" && o !== "/&" || n++ } e = e.previousSibling } return null } function Nm(e, n, o) { switch (n = da(o), e) { case "html": if (e = n.documentElement, !e) throw Error(a(452)); return e; case "head": if (e = n.head, !e) throw Error(a(453)); return e; case "body": if (e = n.body, !e) throw Error(a(454)); return e; default: throw Error(a(451)) } } function Ko(e) { for (var n = e.attributes; n.length;)e.removeAttributeNode(n[0]); os(e) } var Lt = new Map, wm = new Set; function fa(e) { return typeof e.getRootNode == "function" ? e.getRootNode() : e.nodeType === 9 ? e : e.ownerDocument } var gn = O.d; O.d = { f: j0, r: Z0, D: $0, C: ev, L: tv, m: nv, X: ov, S: iv, M: lv }; function j0() { var e = gn.f(), n = ia(); return e || n } function Z0(e) { var n = gi(e); n !== null && n.tag === 5 && n.type === "form" ? Fd(n) : gn.r(e) } var Ki = typeof document > "u" ? null : document; function Mm(e, n, o) { var s = Ki; if (s && typeof n == "string" && n) { var f = wt(n); f = 'link[rel="' + e + '"][href="' + f + '"]', typeof o == "string" && (f += '[crossorigin="' + o + '"]'), wm.has(f) || (wm.add(f), e = { rel: e, crossOrigin: o, href: n }, s.querySelector(f) === null && (n = s.createElement("link"), nt(n, "link", e), Xe(n), s.head.appendChild(n))) } } function $0(e) { gn.D(e), Mm("dns-prefetch", e, null) } function ev(e, n) { gn.C(e, n), Mm("preconnect", e, n) } function tv(e, n, o) { gn.L(e, n, o); var s = Ki; if (s && e && n) { var f = 'link[rel="preload"][as="' + wt(n) + '"]'; n === "image" && o && o.imageSrcSet ? (f += '[imagesrcset="' + wt(o.imageSrcSet) + '"]', typeof o.imageSizes == "string" && (f += '[imagesizes="' + wt(o.imageSizes) + '"]')) : f += '[href="' + wt(e) + '"]'; var h = f; switch (n) { case "style": h = Xi(e); break; case "script": h = Qi(e) }Lt.has(h) || (e = T({ rel: "preload", href: n === "image" && o && o.imageSrcSet ? void 0 : e, as: n }, o), Lt.set(h, e), s.querySelector(f) !== null || n === "style" && s.querySelector(Xo(h)) || n === "script" && s.querySelector(Qo(h)) || (n = s.createElement("link"), nt(n, "link", e), Xe(n), s.head.appendChild(n))) } } function nv(e, n) { gn.m(e, n); var o = Ki; if (o && e) { var s = n && typeof n.as == "string" ? n.as : "script", f = 'link[rel="modulepreload"][as="' + wt(s) + '"][href="' + wt(e) + '"]', h = f; switch (s) { case "audioworklet": case "paintworklet": case "serviceworker": case "sharedworker": case "worker": case "script": h = Qi(e) }if (!Lt.has(h) && (e = T({ rel: "modulepreload", href: e }, n), Lt.set(h, e), o.querySelector(f) === null)) { switch (s) { case "audioworklet": case "paintworklet": case "serviceworker": case "sharedworker": case "worker": case "script": if (o.querySelector(Qo(h))) return }s = o.createElement("link"), nt(s, "link", e), Xe(s), o.head.appendChild(s) } } } function iv(e, n, o) { gn.S(e, n, o); var s = Ki; if (s && e) { var f = yi(s).hoistableStyles, h = Xi(e); n = n || "default"; var S = f.get(h); if (!S) { var E = { loading: 0, preload: null }; if (S = s.querySelector(Xo(h))) E.loading = 5; else { e = T({ rel: "stylesheet", href: e, "data-precedence": n }, o), (o = Lt.get(h)) && iu(e, o); var C = S = s.createElement("link"); Xe(C), nt(C, "link", e), C._p = new Promise(function (R, z) { C.onload = R, C.onerror = z }), C.addEventListener("load", function () { E.loading |= 1 }), C.addEventListener("error", function () { E.loading |= 2 }), E.loading |= 4, ma(S, n, s) } S = { type: "stylesheet", instance: S, count: 1, state: E }, f.set(h, S) } } } function ov(e, n) { gn.X(e, n); var o = Ki; if (o && e) { var s = yi(o).hoistableScripts, f = Qi(e), h = s.get(f); h || (h = o.querySelector(Qo(f)), h || (e = T({ src: e, async: !0 }, n), (n = Lt.get(f)) && ou(e, n), h = o.createElement("script"), Xe(h), nt(h, "link", e), o.head.appendChild(h)), h = { type: "script", instance: h, count: 1, state: null }, s.set(f, h)) } } function lv(e, n) { gn.M(e, n); var o = Ki; if (o && e) { var s = yi(o).hoistableScripts, f = Qi(e), h = s.get(f); h || (h = o.querySelector(Qo(f)), h || (e = T({ src: e, async: !0, type: "module" }, n), (n = Lt.get(f)) && ou(e, n), h = o.createElement("script"), Xe(h), nt(h, "link", e), o.head.appendChild(h)), h = { type: "script", instance: h, count: 1, state: null }, s.set(f, h)) } } function Rm(e, n, o, s) { var f = (f = ce.current) ? fa(f) : null; if (!f) throw Error(a(446)); switch (e) { case "meta": case "title": return null; case "style": return typeof o.precedence == "string" && typeof o.href == "string" ? (n = Xi(o.href), o = yi(f).hoistableStyles, s = o.get(n), s || (s = { type: "style", instance: null, count: 0, state: null }, o.set(n, s)), s) : { type: "void", instance: null, count: 0, state: null }; case "link": if (o.rel === "stylesheet" && typeof o.href == "string" && typeof o.precedence == "string") { e = Xi(o.href); var h = yi(f).hoistableStyles, S = h.get(e); if (S || (f = f.ownerDocument || f, S = { type: "stylesheet", instance: null, count: 0, state: { loading: 0, preload: null } }, h.set(e, S), (h = f.querySelector(Xo(e))) && !h._p && (S.instance = h, S.state.loading = 5), Lt.has(e) || (o = { rel: "preload", as: "style", href: o.href, crossOrigin: o.crossOrigin, integrity: o.integrity, media: o.media, hrefLang: o.hrefLang, referrerPolicy: o.referrerPolicy }, Lt.set(e, o), h || av(f, e, o, S.state))), n && s === null) throw Error(a(528, "")); return S } if (n && s !== null) throw Error(a(529, "")); return null; case "script": return n = o.async, o = o.src, typeof o == "string" && n && typeof n != "function" && typeof n != "symbol" ? (n = Qi(o), o = yi(f).hoistableScripts, s = o.get(n), s || (s = { type: "script", instance: null, count: 0, state: null }, o.set(n, s)), s) : { type: "void", instance: null, count: 0, state: null }; default: throw Error(a(444, e)) } } function Xi(e) { return 'href="' + wt(e) + '"' } function Xo(e) { return 'link[rel="stylesheet"][' + e + "]" } function Im(e) { return T({}, e, { "data-precedence": e.precedence, precedence: null }) } function av(e, n, o, s) { e.querySelector('link[rel="preload"][as="style"][' + n + "]") ? s.loading = 1 : (n = e.createElement("link"), s.preload = n, n.addEventListener("load", function () { return s.loading |= 1 }), n.addEventListener("error", function () { return s.loading |= 2 }), nt(n, "link", o), Xe(n), e.head.appendChild(n)) } function Qi(e) { return '[src="' + wt(e) + '"]' } function Qo(e) { return "script[async]" + e } function km(e, n, o) { if (n.count++, n.instance === null) switch (n.type) { case "style": var s = e.querySelector('style[data-href~="' + wt(o.href) + '"]'); if (s) return n.instance = s, Xe(s), s; var f = T({}, o, { "data-href": o.href, "data-precedence": o.precedence, href: null, precedence: null }); return s = (e.ownerDocument || e).createElement("style"), Xe(s), nt(s, "style", f), ma(s, o.precedence, e), n.instance = s; case "stylesheet": f = Xi(o.href); var h = e.querySelector(Xo(f)); if (h) return n.state.loading |= 4, n.instance = h, Xe(h), h; s = Im(o), (f = Lt.get(f)) && iu(s, f), h = (e.ownerDocument || e).createElement("link"), Xe(h); var S = h; return S._p = new Promise(function (E, C) { S.onload = E, S.onerror = C }), nt(h, "link", s), n.state.loading |= 4, ma(h, o.precedence, e), n.instance = h; case "script": return h = Qi(o.src), (f = e.querySelector(Qo(h))) ? (n.instance = f, Xe(f), f) : (s = o, (f = Lt.get(h)) && (s = T({}, o), ou(s, f)), e = e.ownerDocument || e, f = e.createElement("script"), Xe(f), nt(f, "link", s), e.head.appendChild(f), n.instance = f); case "void": return null; default: throw Error(a(443, n.type)) } else n.type === "stylesheet" && (n.state.loading & 4) === 0 && (s = n.instance, n.state.loading |= 4, ma(s, o.precedence, e)); return n.instance } function ma(e, n, o) { for (var s = o.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), f = s.length ? s[s.length - 1] : null, h = f, S = 0; S < s.length; S++) { var E = s[S]; if (E.dataset.precedence === n) h = E; else if (h !== f) break } h ? h.parentNode.insertBefore(e, h.nextSibling) : (n = o.nodeType === 9 ? o.head : o, n.insertBefore(e, n.firstChild)) } function iu(e, n) { e.crossOrigin == null && (e.crossOrigin = n.crossOrigin), e.referrerPolicy == null && (e.referrerPolicy = n.referrerPolicy), e.title == null && (e.title = n.title) } function ou(e, n) { e.crossOrigin == null && (e.crossOrigin = n.crossOrigin), e.referrerPolicy == null && (e.referrerPolicy = n.referrerPolicy), e.integrity == null && (e.integrity = n.integrity) } var ha = null; function Dm(e, n, o) { if (ha === null) { var s = new Map, f = ha = new Map; f.set(o, s) } else f = ha, s = f.get(o), s || (s = new Map, f.set(o, s)); if (s.has(e)) return s; for (s.set(e, null), o = o.getElementsByTagName(e), f = 0; f < o.length; f++) { var h = o[f]; if (!(h[fo] || h[Ze] || e === "link" && h.getAttribute("rel") === "stylesheet") && h.namespaceURI !== "http://www.w3.org/2000/svg") { var S = h.getAttribute(n) || ""; S = e + S; var E = s.get(S); E ? E.push(h) : s.set(S, [h]) } } return s } function Um(e, n, o) { e = e.ownerDocument || e, e.head.insertBefore(o, n === "title" ? e.querySelector("head > title") : null) } function sv(e, n, o) { if (o === 1 || n.itemProp != null) return !1; switch (e) { case "meta": case "title": return !0; case "style": if (typeof n.precedence != "string" || typeof n.href != "string" || n.href === "") break; return !0; case "link": if (typeof n.rel != "string" || typeof n.href != "string" || n.href === "" || n.onLoad || n.onError) break; switch (n.rel) { case "stylesheet": return e = n.disabled, typeof n.precedence == "string" && e == null; default: return !0 }case "script": if (n.async && typeof n.async != "function" && typeof n.async != "symbol" && !n.onLoad && !n.onError && n.src && typeof n.src == "string") return !0 }return !1 } function Gm(e) { return !(e.type === "stylesheet" && (e.state.loading & 3) === 0) } function rv(e, n, o, s) { if (o.type === "stylesheet" && (typeof s.media != "string" || matchMedia(s.media).matches !== !1) && (o.state.loading & 4) === 0) { if (o.instance === null) { var f = Xi(s.href), h = n.querySelector(Xo(f)); if (h) { n = h._p, n !== null && typeof n == "object" && typeof n.then == "function" && (e.count++, e = pa.bind(e), n.then(e, e)), o.state.loading |= 4, o.instance = h, Xe(h); return } h = n.ownerDocument || n, s = Im(s), (f = Lt.get(f)) && iu(s, f), h = h.createElement("link"), Xe(h); var S = h; S._p = new Promise(function (E, C) { S.onload = E, S.onerror = C }), nt(h, "link", s), o.instance = h } e.stylesheets === null && (e.stylesheets = new Map), e.stylesheets.set(o, n), (n = o.state.preload) && (o.state.loading & 3) === 0 && (e.count++, o = pa.bind(e), n.addEventListener("load", o), n.addEventListener("error", o)) } } var lu = 0; function uv(e, n) { return e.stylesheets && e.count === 0 && ya(e, e.stylesheets), 0 < e.count || 0 < e.imgCount ? function (o) { var s = setTimeout(function () { if (e.stylesheets && ya(e, e.stylesheets), e.unsuspend) { var h = e.unsuspend; e.unsuspend = null, h() } }, 6e4 + n); 0 < e.imgBytes && lu === 0 && (lu = 62500 * O0()); var f = setTimeout(function () { if (e.waitingForImages = !1, e.count === 0 && (e.stylesheets && ya(e, e.stylesheets), e.unsuspend)) { var h = e.unsuspend; e.unsuspend = null, h() } }, (e.imgBytes > lu ? 50 : 800) + n); return e.unsuspend = o, function () { e.unsuspend = null, clearTimeout(s), clearTimeout(f) } } : null } function pa() { if (this.count--, this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) { if (this.stylesheets) ya(this, this.stylesheets); else if (this.unsuspend) { var e = this.unsuspend; this.unsuspend = null, e() } } } var ga = null; function ya(e, n) { e.stylesheets = null, e.unsuspend !== null && (e.count++, ga = new Map, n.forEach(cv, e), ga = null, pa.call(e)) } function cv(e, n) { if (!(n.state.loading & 4)) { var o = ga.get(e); if (o) var s = o.get(null); else { o = new Map, ga.set(e, o); for (var f = e.querySelectorAll("link[data-precedence],style[data-precedence]"), h = 0; h < f.length; h++) { var S = f[h]; (S.nodeName === "LINK" || S.getAttribute("media") !== "not all") && (o.set(S.dataset.precedence, S), s = S) } s && o.set(null, s) } f = n.instance, S = f.getAttribute("data-precedence"), h = o.get(S) || s, h === s && o.set(null, f), o.set(S, f), this.count++, s = pa.bind(this), f.addEventListener("load", s), f.addEventListener("error", s), h ? h.parentNode.insertBefore(f, h.nextSibling) : (e = e.nodeType === 9 ? e.head : e, e.insertBefore(f, e.firstChild)), n.state.loading |= 4 } } var jo = { $$typeof: B, Provider: null, Consumer: null, _currentValue: ie, _currentValue2: ie, _threadCount: 0 }; function dv(e, n, o, s, f, h, S, E, C) { this.tag = 1, this.containerInfo = e, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = es(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = es(0), this.hiddenUpdates = es(null), this.identifierPrefix = s, this.onUncaughtError = f, this.onCaughtError = h, this.onRecoverableError = S, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = C, this.incompleteTransitions = new Map } function Lm(e, n, o, s, f, h, S, E, C, R, z, H) { return e = new dv(e, n, o, S, C, R, z, H, E), n = 1, h === !0 && (n |= 24), h = Tt(3, null, null, n), e.current = h, h.stateNode = e, n = qs(), n.refCount++, e.pooledCache = n, n.refCount++, h.memoizedState = { element: s, isDehydrated: o, cache: n }, Bs(h), e } function zm(e) { return e ? (e = Ni, e) : Ni } function qm(e, n, o, s, f, h) { f = zm(f), s.context === null ? s.context = f : s.pendingContext = f, s = wn(n), s.payload = { element: o }, h = h === void 0 ? null : h, h !== null && (s.callback = h), o = Mn(e, s, n), o !== null && (gt(o, e, n), Mo(o, e, n)) } function Hm(e, n) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var o = e.retryLane; e.retryLane = o !== 0 && o < n ? o : n } } function au(e, n) { Hm(e, n), (e = e.alternate) && Hm(e, n) } function Pm(e) { if (e.tag === 13 || e.tag === 31) { var n = Zn(e, 67108864); n !== null && gt(n, e, 67108864), au(e, 67108864) } } function Vm(e) { if (e.tag === 13 || e.tag === 31) { var n = bt(); n = ts(n); var o = Zn(e, n); o !== null && gt(o, e, n), au(e, n) } } var va = !0; function fv(e, n, o, s) { var f = L.T; L.T = null; var h = O.p; try { O.p = 2, su(e, n, o, s) } finally { O.p = h, L.T = f } } function mv(e, n, o, s) { var f = L.T; L.T = null; var h = O.p; try { O.p = 8, su(e, n, o, s) } finally { O.p = h, L.T = f } } function su(e, n, o, s) { if (va) { var f = ru(s); if (f === null) Wr(e, n, s, xa, o), Om(e, s); else if (pv(f, e, n, o, s)) s.stopPropagation(); else if (Om(e, s), n & 4 && -1 < hv.indexOf(e)) { for (; f !== null;) { var h = gi(f); if (h !== null) switch (h.tag) { case 3: if (h = h.stateNode, h.current.memoizedState.isDehydrated) { var S = Wn(h.pendingLanes); if (S !== 0) { var E = h; for (E.pendingLanes |= 2, E.entangledLanes |= 2; S;) { var C = 1 << 31 - xt(S); E.entanglements[1] |= C, S &= ~C } jt(h), (Te & 6) === 0 && (ta = yt() + 500, Yo(0)) } } break; case 31: case 13: E = Zn(h, 2), E !== null && gt(E, h, 2), ia(), au(h, 2) }if (h = ru(s), h === null && Wr(e, n, s, xa, o), h === f) break; f = h } f !== null && s.stopPropagation() } else Wr(e, n, s, null, o) } } function ru(e) { return e = cs(e), uu(e) } var xa = null; function uu(e) { if (xa = null, e = pi(e), e !== null) { var n = d(e); if (n === null) e = null; else { var o = n.tag; if (o === 13) { if (e = m(n), e !== null) return e; e = null } else if (o === 31) { if (e = g(n), e !== null) return e; e = null } else if (o === 3) { if (n.stateNode.current.memoizedState.isDehydrated) return n.tag === 3 ? n.stateNode.containerInfo : null; e = null } else n !== e && (e = null) } } return xa = e, null } function Bm(e) { switch (e) { case "beforetoggle": case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "toggle": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 2; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 8; case "message": switch ($g()) { case Xu: return 2; case Qu: return 8; case rl: case ey: return 32; case ju: return 268435456; default: return 32 }default: return 32 } } var cu = !1, Pn = null, Vn = null, Bn = null, Zo = new Map, $o = new Map, On = [], hv = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" "); function Om(e, n) { switch (e) { case "focusin": case "focusout": Pn = null; break; case "dragenter": case "dragleave": Vn = null; break; case "mouseover": case "mouseout": Bn = null; break; case "pointerover": case "pointerout": Zo.delete(n.pointerId); break; case "gotpointercapture": case "lostpointercapture": $o.delete(n.pointerId) } } function el(e, n, o, s, f, h) { return e === null || e.nativeEvent !== h ? (e = { blockedOn: n, domEventName: o, eventSystemFlags: s, nativeEvent: h, targetContainers: [f] }, n !== null && (n = gi(n), n !== null && Pm(n)), e) : (e.eventSystemFlags |= s, n = e.targetContainers, f !== null && n.indexOf(f) === -1 && n.push(f), e) } function pv(e, n, o, s, f) { switch (n) { case "focusin": return Pn = el(Pn, e, n, o, s, f), !0; case "dragenter": return Vn = el(Vn, e, n, o, s, f), !0; case "mouseover": return Bn = el(Bn, e, n, o, s, f), !0; case "pointerover": var h = f.pointerId; return Zo.set(h, el(Zo.get(h) || null, e, n, o, s, f)), !0; case "gotpointercapture": return h = f.pointerId, $o.set(h, el($o.get(h) || null, e, n, o, s, f)), !0 }return !1 } function Fm(e) { var n = pi(e.target); if (n !== null) { var o = d(n); if (o !== null) { if (n = o.tag, n === 13) { if (n = m(o), n !== null) { e.blockedOn = n, ic(e.priority, function () { Vm(o) }); return } } else if (n === 31) { if (n = g(o), n !== null) { e.blockedOn = n, ic(e.priority, function () { Vm(o) }); return } } else if (n === 3 && o.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = o.tag === 3 ? o.stateNode.containerInfo : null; return } } } e.blockedOn = null } function Sa(e) { if (e.blockedOn !== null) return !1; for (var n = e.targetContainers; 0 < n.length;) { var o = ru(e.nativeEvent); if (o === null) { o = e.nativeEvent; var s = new o.constructor(o.type, o); us = s, o.target.dispatchEvent(s), us = null } else return n = gi(o), n !== null && Pm(n), e.blockedOn = o, !1; n.shift() } return !0 } function Ym(e, n, o) { Sa(e) && o.delete(n) } function gv() { cu = !1, Pn !== null && Sa(Pn) && (Pn = null), Vn !== null && Sa(Vn) && (Vn = null), Bn !== null && Sa(Bn) && (Bn = null), Zo.forEach(Ym), $o.forEach(Ym) } function Ta(e, n) { e.blockedOn === n && (e.blockedOn = null, cu || (cu = !0, i.unstable_scheduleCallback(i.unstable_NormalPriority, gv))) } var _a = null; function Jm(e) { _a !== e && (_a = e, i.unstable_scheduleCallback(i.unstable_NormalPriority, function () { _a === e && (_a = null); for (var n = 0; n < e.length; n += 3) { var o = e[n], s = e[n + 1], f = e[n + 2]; if (typeof s != "function") { if (uu(s || o) === null) continue; break } var h = gi(o); h !== null && (e.splice(n, 3), n -= 3, rr(h, { pending: !0, data: f, method: o.method, action: s }, s, f)) } })) } function ji(e) { function n(C) { return Ta(C, e) } Pn !== null && Ta(Pn, e), Vn !== null && Ta(Vn, e), Bn !== null && Ta(Bn, e), Zo.forEach(n), $o.forEach(n); for (var o = 0; o < On.length; o++) { var s = On[o]; s.blockedOn === e && (s.blockedOn = null) } for (; 0 < On.length && (o = On[0], o.blockedOn === null);)Fm(o), o.blockedOn === null && On.shift(); if (o = (e.ownerDocument || e).$$reactFormReplay, o != null) for (s = 0; s < o.length; s += 3) { var f = o[s], h = o[s + 1], S = f[ct] || null; if (typeof h == "function") S || Jm(o); else if (S) { var E = null; if (h && h.hasAttribute("formAction")) { if (f = h, S = h[ct] || null) E = S.formAction; else if (uu(f) !== null) continue } else E = S.action; typeof E == "function" ? o[s + 1] = E : (o.splice(s, 3), s -= 3), Jm(o) } } } function Wm() { function e(h) { h.canIntercept && h.info === "react-transition" && h.intercept({ handler: function () { return new Promise(function (S) { return f = S }) }, focusReset: "manual", scroll: "manual" }) } function n() { f !== null && (f(), f = null), s || setTimeout(o, 20) } function o() { if (!s && !navigation.transition) { var h = navigation.currentEntry; h && h.url != null && navigation.navigate(h.url, { state: h.getState(), info: "react-transition", history: "replace" }) } } if (typeof navigation == "object") { var s = !1, f = null; return navigation.addEventListener("navigate", e), navigation.addEventListener("navigatesuccess", n), navigation.addEventListener("navigateerror", n), setTimeout(o, 100), function () { s = !0, navigation.removeEventListener("navigate", e), navigation.removeEventListener("navigatesuccess", n), navigation.removeEventListener("navigateerror", n), f !== null && (f(), f = null) } } } function du(e) { this._internalRoot = e } Ea.prototype.render = du.prototype.render = function (e) { var n = this._internalRoot; if (n === null) throw Error(a(409)); var o = n.current, s = bt(); qm(o, s, e, n, null, null) }, Ea.prototype.unmount = du.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var n = e.containerInfo; qm(e.current, 2, null, e, null, null), ia(), n[hi] = null } }; function Ea(e) { this._internalRoot = e } Ea.prototype.unstable_scheduleHydration = function (e) { if (e) { var n = nc(); e = { blockedOn: null, target: e, priority: n }; for (var o = 0; o < On.length && n !== 0 && n < On[o].priority; o++); On.splice(o, 0, e), o === 0 && Fm(e) } }; var Km = t.version; if (Km !== "19.2.3") throw Error(a(527, Km, "19.2.3")); O.findDOMNode = function (e) { var n = e._reactInternals; if (n === void 0) throw typeof e.render == "function" ? Error(a(188)) : (e = Object.keys(e).join(","), Error(a(268, e))); return e = p(n), e = e !== null ? x(e) : null, e = e === null ? null : e.stateNode, e }; var yv = { bundleType: 0, version: "19.2.3", rendererPackageName: "react-dom", currentDispatcherRef: L, reconcilerVersion: "19.2.3" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Aa = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Aa.isDisabled && Aa.supportsFiber) try { ro = Aa.inject(yv), vt = Aa } catch { } } return nl.createRoot = function (e, n) { if (!r(e)) throw Error(a(299)); var o = !1, s = "", f = ef, h = tf, S = nf; return n != null && (n.unstable_strictMode === !0 && (o = !0), n.identifierPrefix !== void 0 && (s = n.identifierPrefix), n.onUncaughtError !== void 0 && (f = n.onUncaughtError), n.onCaughtError !== void 0 && (h = n.onCaughtError), n.onRecoverableError !== void 0 && (S = n.onRecoverableError)), n = Lm(e, 1, !1, null, null, o, s, null, f, h, S, Wm), e[hi] = n.current, Jr(e), new du(n) }, nl.hydrateRoot = function (e, n, o) { if (!r(e)) throw Error(a(299)); var s = !1, f = "", h = ef, S = tf, E = nf, C = null; return o != null && (o.unstable_strictMode === !0 && (s = !0), o.identifierPrefix !== void 0 && (f = o.identifierPrefix), o.onUncaughtError !== void 0 && (h = o.onUncaughtError), o.onCaughtError !== void 0 && (S = o.onCaughtError), o.onRecoverableError !== void 0 && (E = o.onRecoverableError), o.formState !== void 0 && (C = o.formState)), n = Lm(e, 1, !0, n, o ?? null, s, f, C, h, S, E, Wm), n.context = zm(null), o = n.current, s = bt(), s = ts(s), f = wn(s), f.callback = null, Mn(o, f, s), o = s, n.current.lanes = o, co(n, o), jt(n), e[hi] = n.current, Jr(e), new Ea(n) }, nl.version = "19.2.3", nl
} var oh; function Nv() { if (oh) return hu.exports; oh = 1; function i() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(i) } catch (t) { console.error(t) } } return i(), hu.exports = bv(), hu.exports } var wv = Nv(); const Mv = Fp(wv);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Rv = i => i.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), Iv = i => i.replace(/^([A-Z])|[\s-_]+(\w)/g, (t, l, a) => a ? a.toUpperCase() : l.toLowerCase()), lh = i => { const t = Iv(i); return t.charAt(0).toUpperCase() + t.slice(1) }, Yp = (...i) => i.filter((t, l, a) => !!t && t.trim() !== "" && a.indexOf(t) === l).join(" ").trim(), kv = i => { for (const t in i) if (t.startsWith("aria-") || t === "role" || t === "title") return !0 };/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var Dv = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Uv = ze.forwardRef(({ color: i = "currentColor", size: t = 24, strokeWidth: l = 2, absoluteStrokeWidth: a, className: r = "", children: d, iconNode: m, ...g }, v) => ze.createElement("svg", { ref: v, ...Dv, width: t, height: t, stroke: i, strokeWidth: a ? Number(l) * 24 / Number(t) : l, className: Yp("lucide", r), ...!d && !kv(g) && { "aria-hidden": "true" }, ...g }, [...m.map(([p, x]) => ze.createElement(p, x)), ...Array.isArray(d) ? d : [d]]));/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const oe = (i, t) => { const l = ze.forwardRef(({ className: a, ...r }, d) => ze.createElement(Uv, { ref: d, iconNode: t, className: Yp(`lucide-${Rv(lh(i))}`, `lucide-${i}`, a), ...r })); return l.displayName = lh(i), l };/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Gv = [["path", { d: "m12 19-7-7 7-7", key: "1l729n" }], ["path", { d: "M19 12H5", key: "x3x0zl" }]], Lv = oe("arrow-left", Gv);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const zv = [["path", { d: "M5 12h14", key: "1ays0h" }], ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]], Jp = oe("arrow-right", zv);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const qv = [["path", { d: "M12 7v14", key: "1akyts" }], ["path", { d: "M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z", key: "ruj8y" }]], Hv = oe("book-open", qv);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Pv = [["path", { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20", key: "k3hazp" }]], Vv = oe("book", Pv);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Bv = [["path", { d: "M8 2v4", key: "1cmpym" }], ["path", { d: "M16 2v4", key: "4m81vk" }], ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }], ["path", { d: "M3 10h18", key: "8toen8" }]], Ov = oe("calendar", Bv);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Fv = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], zt = oe("check", Fv);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Yv = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]], Jv = oe("chevron-down", Yv);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Wv = [["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]], Kv = oe("chevron-left", Wv);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Xv = [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]], Wp = oe("chevron-right", Xv);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Qv = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }], ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]], jv = oe("circle-alert", Qv);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Zv = [["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }], ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]], $v = oe("circle-check-big", Zv);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ex = [["path", { d: "M12 6v6l4 2", key: "mmk7yg" }], ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]], ah = oe("clock", ex);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const tx = [["path", { d: "M10 2v2", key: "7u0qdc" }], ["path", { d: "M14 2v2", key: "6buw04" }], ["path", { d: "M16 8a1 1 0 0 1 1 1v8a4 4 0 0 1-4 4H7a4 4 0 0 1-4-4V9a1 1 0 0 1 1-1h14a4 4 0 1 1 0 8h-1", key: "pwadti" }], ["path", { d: "M6 2v2", key: "colzsn" }]], nx = oe("coffee", tx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ix = [["path", { d: "M12 2a10 10 0 1 0 10 10 4 4 0 0 1-5-5 4 4 0 0 1-5-5", key: "laymnq" }], ["path", { d: "M8.5 8.5v.01", key: "ue8clq" }], ["path", { d: "M16 15.5v.01", key: "14dtrp" }], ["path", { d: "M12 12v.01", key: "u5ubse" }], ["path", { d: "M11 17v.01", key: "1hyl5a" }], ["path", { d: "M7 14v.01", key: "uct60s" }]], ox = oe("cookie", ix);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const lx = [["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }], ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]], ax = oe("copy", lx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const sx = [["path", { d: "M12 15V3", key: "m9g1x1" }], ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }], ["path", { d: "m7 10 5 5 5-5", key: "brsn70" }]], Kp = oe("download", sx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const rx = [["path", { d: "M15 3h6v6", key: "1q9fwt" }], ["path", { d: "M10 14 21 3", key: "gplh6r" }], ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]], ux = oe("external-link", rx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const cx = [["path", { d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0", key: "1nclc0" }], ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]], dx = oe("eye", cx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const fx = [["path", { d: "M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z", key: "1oefj6" }], ["path", { d: "M14 2v5a1 1 0 0 0 1 1h5", key: "wfsgrz" }], ["circle", { cx: "10", cy: "12", r: "2", key: "737tya" }], ["path", { d: "m20 17-1.296-1.296a2.41 2.41 0 0 0-3.408 0L9 22", key: "wt3hpn" }]], mx = oe("file-image", fx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const hx = [["path", { d: "M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z", key: "1oefj6" }], ["path", { d: "M14 2v5a1 1 0 0 0 1 1h5", key: "wfsgrz" }], ["path", { d: "M10 9H8", key: "b1mrlr" }], ["path", { d: "M16 13H8", key: "t4e002" }], ["path", { d: "M16 17H8", key: "z1uh3a" }]], Xp = oe("file-text", hx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const px = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl" }], ["path", { d: "M2 12h20", key: "9i4pu4" }]], Qp = oe("globe", px);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const gx = [["path", { d: "M2 9.5a5.5 5.5 0 0 1 9.591-3.676.56.56 0 0 0 .818 0A5.49 5.49 0 0 1 22 9.5c0 2.29-1.5 4-3 5.5l-5.492 5.313a2 2 0 0 1-3 .019L5 15c-1.5-1.5-3-3.2-3-5.5", key: "mvr1a0" }]], yx = oe("heart", gx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const vx = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "M12 16v-4", key: "1dtifu" }], ["path", { d: "M12 8h.01", key: "e9boi3" }]], xx = oe("info", vx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Sx = [["path", { d: "M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z", key: "zw3jo" }], ["path", { d: "M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12", key: "1wduqc" }], ["path", { d: "M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17", key: "kqbvx6" }]], Tx = oe("layers", Sx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const _x = [["rect", { width: "7", height: "7", x: "3", y: "3", rx: "1", key: "1g98yp" }], ["rect", { width: "7", height: "7", x: "14", y: "3", rx: "1", key: "6d4xhi" }], ["rect", { width: "7", height: "7", x: "14", y: "14", rx: "1", key: "nxv5o0" }], ["rect", { width: "7", height: "7", x: "3", y: "14", rx: "1", key: "1bb6yr" }]], Ex = oe("layout-grid", _x);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Ax = [["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2", key: "1w4ew1" }], ["path", { d: "M7 11V7a5 5 0 0 1 10 0v4", key: "fwvmzm" }]], Cx = oe("lock", Ax);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const bx = [["path", { d: "m22 7-8.991 5.727a2 2 0 0 1-2.009 0L2 7", key: "132q7q" }], ["rect", { x: "2", y: "4", width: "20", height: "16", rx: "2", key: "izxlao" }]], Nx = oe("mail", bx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const wx = [["path", { d: "M4 5h16", key: "1tepv9" }], ["path", { d: "M4 12h16", key: "1lakjw" }], ["path", { d: "M4 19h16", key: "1djgab" }]], Mx = oe("menu", wx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Rx = [["path", { d: "M2.992 16.342a2 2 0 0 1 .094 1.167l-1.065 3.29a1 1 0 0 0 1.236 1.168l3.413-.998a2 2 0 0 1 1.099.092 10 10 0 1 0-4.777-4.719", key: "1sd12s" }]], Ix = oe("message-circle", Rx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const kx = [["path", { d: "M22 17a2 2 0 0 1-2 2H6.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 2 21.286V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2z", key: "18887p" }]], Dx = oe("message-square", kx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Ux = [["path", { d: "M4.037 4.688a.495.495 0 0 1 .651-.651l16 6.5a.5.5 0 0 1-.063.947l-6.124 1.58a2 2 0 0 0-1.438 1.435l-1.579 6.126a.5.5 0 0 1-.947.063z", key: "edeuup" }]], Gx = oe("mouse-pointer-2", Ux);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Lx = [["path", { d: "M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z", key: "10ikf1" }]], zx = oe("play", Lx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const qx = [["path", { d: "M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "14sxne" }], ["path", { d: "M3 3v5h5", key: "1xhq8a" }], ["path", { d: "M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16", key: "1hlbsb" }], ["path", { d: "M16 16h5v5", key: "ccwih5" }]], Hx = oe("refresh-ccw", qx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Px = [["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }], ["path", { d: "M21 3v5h-5", key: "1q7to0" }], ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }], ["path", { d: "M8 16H3v5", key: "1cv678" }]], Vx = oe("refresh-cw", Px);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Bx = [["path", { d: "M12 3v18", key: "108xh3" }], ["path", { d: "m19 8 3 8a5 5 0 0 1-6 0zV7", key: "zcdpyk" }], ["path", { d: "M3 7h1a17 17 0 0 0 8-2 17 17 0 0 0 8 2h1", key: "1yorad" }], ["path", { d: "m5 8 3 8a5 5 0 0 1-6 0zV7", key: "eua70x" }], ["path", { d: "M7 21h10", key: "1b0cd5" }]], Ox = oe("scale", Bx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Fx = [["rect", { width: "20", height: "8", x: "2", y: "2", rx: "2", ry: "2", key: "ngkwjq" }], ["rect", { width: "20", height: "8", x: "2", y: "14", rx: "2", ry: "2", key: "iecqi9" }], ["line", { x1: "6", x2: "6.01", y1: "6", y2: "6", key: "16zg32" }], ["line", { x1: "6", x2: "6.01", y1: "18", y2: "18", key: "nzw8ys" }]], Yx = oe("server", Fx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Jx = [["path", { d: "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915", key: "1i5ecw" }], ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]], jp = oe("settings", Jx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Wx = [["path", { d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z", key: "oel41y" }], ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]], Zp = oe("shield-check", Wx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Kx = [["path", { d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z", key: "oel41y" }]], Lu = oe("shield", Kx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Xx = [["path", { d: "M11.017 2.814a1 1 0 0 1 1.966 0l1.051 5.558a2 2 0 0 0 1.594 1.594l5.558 1.051a1 1 0 0 1 0 1.966l-5.558 1.051a2 2 0 0 0-1.594 1.594l-1.051 5.558a1 1 0 0 1-1.966 0l-1.051-5.558a2 2 0 0 0-1.594-1.594l-5.558-1.051a1 1 0 0 1 0-1.966l5.558-1.051a2 2 0 0 0 1.594-1.594z", key: "1s2grr" }], ["path", { d: "M20 2v4", key: "1rf3ol" }], ["path", { d: "M22 4h-4", key: "gwowj6" }], ["circle", { cx: "4", cy: "20", r: "2", key: "6kqj1y" }]], $p = oe("sparkles", Xx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Qx = [["path", { d: "M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z", key: "r04s7s" }]], jx = oe("star", Qx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Zx = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["circle", { cx: "12", cy: "12", r: "6", key: "1vlfrh" }], ["circle", { cx: "12", cy: "12", r: "2", key: "1c9p78" }]], $x = oe("target", Zx);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const eS = [["path", { d: "M12 19h8", key: "baeox8" }], ["path", { d: "m4 17 6-6-6-6", key: "1yngyt" }]], tS = oe("terminal", eS);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const nS = [["path", { d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3", key: "wmoenq" }], ["path", { d: "M12 9v4", key: "juzpu7" }], ["path", { d: "M12 17h.01", key: "p32p05" }]], iS = oe("triangle-alert", nS);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const oS = [["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }], ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]], lS = oe("user", oS);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const aS = [["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }], ["path", { d: "M16 3.128a4 4 0 0 1 0 7.744", key: "16gr8j" }], ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }], ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }]], sS = oe("users", aS);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const rS = [["path", { d: "M18 6 6 18", key: "1bl5f8" }], ["path", { d: "m6 6 12 12", key: "d8bk6v" }]], ka = oe("x", rS);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const uS = [["path", { d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z", key: "1xq2db" }]], il = oe("zap", uS), Ft = ({ variant: i = "primary", size: t = "md", className: l = "", children: a, ...r }) => { const d = "inline-flex items-center justify-center font-bold transition-all duration-300 rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-black disabled:opacity-50 disabled:cursor-not-allowed", m = { primary: "bg-primary text-black hover:scale-105 cta-glow", secondary: "bg-surface border border-primary/30 text-white hover:bg-white/5 cta-glow", ghost: "text-slate-400 hover:text-primary bg-transparent" }, g = { sm: "px-5 py-2 text-xs uppercase tracking-wide", md: "px-8 py-3.5 text-base", lg: "px-12 py-6 text-xl" }; return y.jsx("button", { className: `${d} ${m[i]} ${g[t]} ${l}`, ...r, children: a }) }, eg = { en: { meta: { title: "MetaAi Automator - Bulk Generate & Download Images", description: "The ultimate Meta Ai   auto downloader. Automate prompts and batch process images." }, nav: { home: "Home", features: "Features", pricing: "Pricing", docs: "Docs", blog: "Blog", support: "Support", about: "About Us", privacy: "Privacy", install: "Install Extension" }, hero: { badge: "Meta Ai  Automator Alternative v2.0", titlePrefix: "How to Bulk Generate", titleMiddle: "Images in", titleSuffix: "Meta Ai  .", subtitle: "Automate Meta Ai   prompts and download all images instantly. The comprehensive Meta Ai   workflow automation tool for professionals.", ctaPrimary: "Add to Chrome", ctaSecondary: "Watch Workflow" }, comparison: { title: "Free Tools vs", manual: "MANUAL PROCESS", automated: "MetaAi Automator", manualEffort: "High Stress + 6h/day", autoEffort: "0 Interaction + 5m Setup" }, pricing: { title: "Simple Pricing", monthly: "Monthly", yearly: "Yearly", lifetime: "Lifetime", mostPopular: "Most Popular", save: "Save an extra 20%", oneTime: "One-time payment" }, faq: { title: "Meta Ai   FAQ", items: [{ q: "How to bulk generate images?", a: "Simply upload a CSV of your prompts, set your persona, and click start." }, { q: "Why is Meta Ai   slow?", a: "MetaAi Automator manages the queue for you, ensuring the fastest generation times." }, { q: "Is there an auto downloader?", a: "Yes! Every generated image is automatically downloaded to your folder." }, { q: "Does it handle rate limits?", a: "Our 'Human-Flow' system manages pacing to prevent bans." }] }, cta: { title: "Start Bulk Generation Today.", subtitle: "Join thousands who use us for Meta Ai   workflow automation." } }, zh: { meta: { title: "MetaAi Automator -  Meta Ai   ", description: " Meta Ai    AI " }, nav: { home: "", features: "", pricing: "", docs: "", blog: "", support: "", about: "", privacy: "", install: "" }, hero: { badge: "Meta Ai  Automator  v2.0", titlePrefix: "", titleMiddle: "Meta Ai   ", titleSuffix: "", subtitle: " Meta Ai    Meta Ai   ", ctaPrimary: " Chrome", ctaSecondary: "" }, comparison: { title: " vs", manual: "", automated: "Meta Ai   ", manualEffort: " + 6", autoEffort: "0  + 5" }, pricing: { title: "", monthly: "", yearly: "", lifetime: "", mostPopular: "", save: " 20%", oneTime: "" }, faq: { title: "", items: [{ q: "", a: " CSV " }, { q: " Meta Ai   ", a: "MetaAi Automator " }, { q: "", a: "" }, { q: "", a: " 'Human-Flow' " }] }, cta: { title: "", subtitle: " Meta Ai   " } }, es: { meta: { title: "MetaAi Automator - Generacin y Descarga Masiva en Meta Ai  ", description: "El descargador automtico definitivo para Meta Ai  . Automatiza prompts y procesa imgenes por lotes." }, nav: { home: "Inicio", features: "Caractersticas", pricing: "Precios", docs: "Docs", blog: "Blog", support: "Soporte", about: "Nosotros", privacy: "Privacidad", install: "Instalar Extensin" }, hero: { badge: "Alternativa Meta Ai  Automator v2.0", titlePrefix: "Cmo Generar", titleMiddle: "Imgenes Masivas en", titleSuffix: "Meta Ai  .", subtitle: "Automatiza los prompts de Meta Ai   y descarga todas las imgenes al instante. La herramienta profesional de automatizacin.", ctaPrimary: "Aadir a Chrome", ctaSecondary: "Ver Flujo" }, comparison: { title: "Herramientas Gratuitas vs", manual: "PROCESO MANUAL", automated: "MetaAi Automator", manualEffort: "Alto Estrs + 6h/da", autoEffort: "0 Interaccin + 5m Config" }, pricing: { title: "Precios Simples", monthly: "Mensual", yearly: "Anual", lifetime: "De por vida", mostPopular: "Ms Popular", save: "Ahorra un 20% extra", oneTime: "Pago nico" }, faq: { title: "Preguntas Frecuentes", items: [{ q: "Cmo generar imgenes masivamente?", a: "Sube un CSV con tus prompts, configura tu persona y haz clic en iniciar." }, { q: "Por qu es lento Meta Ai  ?", a: "MetaAi Automator gestiona la cola por ti, asegurando tiempos rpidos." }, { q: "Incluye descarga automtica?", a: "S! Cada imagen generada se descarga automticamente." }, { q: "Maneja los lmites de tasa?", a: "Nuestro sistema 'Human-Flow' gestiona el ritmo para evitar bloqueos." }] }, cta: { title: "Empieza a Generar Hoy.", subtitle: "nete a miles que automatizan su flujo de trabajo en Meta Ai  ." } }, de: { meta: { title: "MetaAi Automator - Massengenerierung & Download in Meta Ai  ", description: "Der ultimative Meta Ai   Auto-Downloader. Automatisieren Sie Prompts und verarbeiten Sie Bilder im Batch." }, nav: { home: "Startseite", features: "Funktionen", pricing: "Preise", docs: "Doku", blog: "Blog", support: "Hilfe", about: "ber Uns", privacy: "Datenschutz", install: "Erweiterung installieren" }, hero: { badge: "Meta Ai  Automator Alternative v2.0", titlePrefix: "So generieren Sie", titleMiddle: "Massenbilder in", titleSuffix: "Meta Ai  .", subtitle: "Automatisieren Sie Meta Ai   Prompts und laden Sie alle Bilder sofort herunter. Das professionelle Tool zur Workflow-Automatisierung.", ctaPrimary: "Zu Chrome hinzufgen", ctaSecondary: "Workflow ansehen" }, comparison: { title: "Kostenlose Tools vs", manual: "MANUELLER PROZESS", automated: "MetaAi Automator", manualEffort: "Hoher Stress + 6h/Tag", autoEffort: "0 Interaktion + 5m Setup" }, pricing: { title: "Einfache Preise", monthly: "Monatlich", yearly: "Jhrlich", lifetime: "Lebenslang", mostPopular: "Beliebteste", save: "Sparen Sie extra 20%", oneTime: "Einmalige Zahlung" }, faq: { title: "Hufige Fragen", items: [{ q: "Wie generiere ich Massenbilder?", a: "Laden Sie einfach eine CSV Ihrer Prompts hoch und klicken Sie auf Start." }, { q: "Warum ist Meta Ai   langsam?", a: "MetaAi Automator verwaltet die Warteschlange fr maximale Geschwindigkeit." }, { q: "Gibt es einen Auto-Downloader?", a: "Ja! Jedes generierte Bild wird automatisch heruntergeladen." }, { q: "Was ist mit Ratenbegrenzungen?", a: "Unser 'Human-Flow'-System steuert das Tempo, um Sperren zu vermeiden." }] }, cta: { title: "Starten Sie heute.", subtitle: "Schlieen Sie sich Tausenden an, die ihren Meta Ai   Workflow automatisieren." } }, pt: { meta: { title: "MetaAi Automator - Gerao e Download em Massa no Meta Ai  ", description: "O downloader automtico definitivo para Meta Ai  . Automatize prompts e processe imagens em lote." }, nav: { home: "Incio", features: "Recursos", pricing: "Preos", docs: "Docs", blog: "Blog", support: "Suporte", about: "Sobre", privacy: "Privacidade", install: "Instalar Extenso" }, hero: { badge: "Alternativa Meta Ai  Automator v2.0", titlePrefix: "Como Gerar", titleMiddle: "Imagens em Massa no", titleSuffix: "Meta Ai  .", subtitle: "Automatize prompts do Meta Ai   e baixe todas as imagens instantaneamente. Ferramenta profissional de automao.", ctaPrimary: "Adicionar ao Chrome", ctaSecondary: "Ver Workflow" }, comparison: { title: "Ferramentas Grtis vs", manual: "PROCESSO MANUAL", automated: "MetaAi Automator", manualEffort: "Alto Estresse + 6h/dia", autoEffort: "0 Interao + 5m Setup" }, pricing: { title: "Preos Simples", monthly: "Mensal", yearly: "Anual", lifetime: "Vitalcio", mostPopular: "Mais Popular", save: "Economize 20% extra", oneTime: "Pagamento nico" }, faq: { title: "Perguntas Frequentes", items: [{ q: "Como gerar imagens em massa?", a: "Basta enviar um CSV dos seus prompts e clicar em iniciar." }, { q: "Por que o Meta Ai    lento?", a: "O MetaAi Automator gerencia a fila para voc, garantindo rapidez." }, { q: "Existe um downloader automtico?", a: "Sim! Cada imagem gerada  baixada automaticamente." }, { q: "Lida com limites de taxa?", a: "Nosso sistema 'Human-Flow' gerencia o ritmo para evitar banimentos." }] }, cta: { title: "Comece a Gerar Hoje.", subtitle: "Junte-se a milhares que usam nossa automao de fluxo de trabalho." } }, ar: { meta: { title: "MetaAi Automator -      Meta Ai  ", description: "     Meta Ai  .      ." }, nav: { home: "", features: "", pricing: "", docs: "", blog: "", support: "", about: " ", privacy: "", install: " " }, hero: { badge: " Meta Ai  Automator v2.0", titlePrefix: " ", titleMiddle: "  ", titleSuffix: "Meta Ai  .", subtitle: "  Meta Ai      .      .", ctaPrimary: "  Chrome", ctaSecondary: "  " }, comparison: { title: "  ", manual: " ", automated: " Meta Ai  ", manualEffort: "  + 6 /", autoEffort: "0  + 5  " }, pricing: { title: " ", monthly: "", yearly: "", lifetime: " ", mostPopular: " ", save: " 20% ", oneTime: "  " }, faq: { title: " ", items: [{ q: "   ", a: "    CSV     ." }, { q: " Meta Ai   ", a: " MetaAi Automator      ." }, { q: "   ", a: "!       ." }, { q: "    ", a: "  'Human-Flow'   ." }] }, cta: { title: "   .", subtitle: "        ." } }, ja: { meta: { title: "MetaAi Automator - Meta Ai   ", description: " Meta Ai   " }, nav: { home: "", features: "", pricing: "", docs: "", blog: "", support: "", about: "", privacy: "", install: "" }, hero: { badge: "Meta Ai  Automator  v2.0", titlePrefix: "", titleMiddle: "", titleSuffix: "Meta Ai  ", subtitle: "Meta Ai    Meta Ai   ", ctaPrimary: "Chrome", ctaSecondary: "" }, comparison: { title: " vs", manual: "", automated: "Meta Ai   ", manualEffort: " + 16", autoEffort: "0  + 5" }, pricing: { title: "", monthly: "", yearly: "", lifetime: "", mostPopular: "", save: "20%", oneTime: "" }, faq: { title: "", items: [{ q: "", a: "CSV" }, { q: " Meta Ai   ", a: "MetaAi Automator " }, { q: "", a: "" }, { q: "", a: " 'Human-Flow' " }] }, cta: { title: "", subtitle: "Meta Ai   " } }, ko: { meta: { title: "MetaAi Automator - Meta Ai       ", description: " Meta Ai    .     ." }, nav: { home: "", features: "", pricing: "", docs: "", blog: "", support: "", about: " ", privacy: " ", install: "  " }, hero: { badge: "Meta Ai  Automator  v2.0", titlePrefix: "  ", titleMiddle: " ", titleSuffix: "Meta Ai  .", subtitle: "Meta Ai        .    Meta Ai     .", ctaPrimary: "Chrome ", ctaSecondary: " " }, comparison: { title: "  vs", manual: " ", automated: "Meta Ai   ", manualEffort: "  +  6", autoEffort: "0  + 5 " }, pricing: { title: " ", monthly: "", yearly: "", lifetime: "", mostPopular: " ", save: " 20% ", oneTime: " " }, faq: { title: "  ", items: [{ q: "  ?", a: " CSV      ." }, { q: "Meta Ai    ?", a: "MetaAi Automator       ." }, { q: "  ?", a: "!      ." }, { q: "  ?", a: "'Human-Flow'      ." }] }, cta: { title: "   .", subtitle: "Meta Ai         ." } }, nl: { meta: { title: "MetaAi Automator - Bulk afbeeldingen genereren en downloaden in Meta Ai  ", description: "De ultieme Meta Ai   auto-downloader. Automatiseer prompts en verwerk afbeeldingen in batch." }, nav: { home: "Home", features: "Functies", pricing: "Prijzen", docs: "Docs", blog: "Blog", support: "Support", about: "Over ons", privacy: "Privacy", install: "Extensie installeren" }, hero: { badge: "Meta Ai  Automator Alternatief v2.0", titlePrefix: "Hoe Bulk Genereren", titleMiddle: "Afbeeldingen in", titleSuffix: "Meta Ai  .", subtitle: "Automatiseer Meta Ai   prompts en download alle afbeeldingen direct. De uitgebreide Meta Ai   workflow automatiseringstool voor professionals.", ctaPrimary: "Toevoegen aan Chrome", ctaSecondary: "Bekijk Workflow" }, comparison: { title: "Gratis Tools vs", manual: "HANDMATIG PROCES", automated: "Meta Ai   AUTOMATISERING", manualEffort: "Hoge Stress + 6u/dag", autoEffort: "0 Interactie + 5m Setup" }, pricing: { title: "Eenvoudige Prijzen", monthly: "Maandelijks", yearly: "Jaarlijks", lifetime: "Levenslang", mostPopular: "Meest Populair", save: "Bespaar extra 20%", oneTime: "Eenmalige betaling" }, faq: { title: "Veelgestelde Vragen", items: [{ q: "Hoe bulk afbeeldingen genereren?", a: "Upload simpelweg een CSV van je prompts, stel je persona in en klik op start." }, { q: "Waarom is Meta Ai   traag?", a: "MetaAi Automator beheert de wachtrij voor je, wat zorgt voor de snelste generatietijden." }, { q: "Is er een auto-downloader?", a: "Ja! Elke gegenereerde afbeelding wordt automatisch gedownload naar je map." }, { q: "Handelt het snelheidslimieten af?", a: "Ons 'Human-Flow' systeem beheert het tempo om bans te voorkomen." }] }, cta: { title: "Begin Vandaag met Bulk Genereren.", subtitle: "Sluit je aan bij duizenden die ons gebruiken voor Meta Ai   workflow automatisering." } }, vi: { meta: { title: "MetaAi Automator - To v Ti xung Hng lot Hnh nh trn Meta Ai  ", description: "Trnh ti xung t ng Meta Ai   ti u. T ng ha li nhc v x l hng lot hnh nh." }, nav: { home: "Trang ch", features: "Tnh nng", pricing: "Bng gi", docs: "Ti liu", blog: "Blog", support: "H tr", about: "V chng ti", privacy: "Ring t", install: "Ci t tin ch" }, hero: { badge: "Thay th Meta Ai  Automator v2.0", titlePrefix: "Cch to hng lot", titleMiddle: "Hnh nh trong", titleSuffix: "Meta Ai  .", subtitle: "T ng ha cc li nhc Meta Ai   v ti xung tt c hnh nh ngay lp tc. Cng c t ng ha quy trnh lm vic Meta Ai   ton din cho cc chuyn gia.", ctaPrimary: "Thm vo Chrome", ctaSecondary: "Xem quy trnh" }, comparison: { title: "Cng c min ph vs", manual: "QUY TRNH TH CNG", automated: "T NG HA Meta Ai  ", manualEffort: "Cng thng cao + 6h/ngy", autoEffort: "0 Tng tc + 5p Ci t" }, pricing: { title: "Gi n gin", monthly: "Hng thng", yearly: "Hng nm", lifetime: "Trn i", mostPopular: "Ph bin nht", save: "Tit kim thm 20%", oneTime: "Thanh ton mt ln" }, faq: { title: "Cu hi thng gp", items: [{ q: "Lm th no  to hnh nh hng lot?", a: "Ch cn ti ln tp CSV cc li nhc ca bn, t tnh cch v nhp bt u." }, { q: "Ti sao Meta Ai   chm?", a: "MetaAi Automator qun l hng i cho bn, m bo thi gian to nhanh nht." }, { q: "C trnh ti xung t ng khng?", a: "C! Mi hnh nh c to u c t ng ti xung th mc ca bn." }, { q: "N c x l gii hn tc  khng?", a: "H thng 'Human-Flow' ca chng ti qun l tc   ngn chn lnh cm." }] }, cta: { title: "Bt u to hng lot ngay hm nay.", subtitle: "Tham gia cng hng ngn ngi s dng chng ti  t ng ha quy trnh lm vic Meta Ai  ." } }, tr: { meta: { title: "MetaAi Automator - Meta Ai  'te Toplu Grnt Oluturma ve ndirme", description: "Nihai Meta Ai   otomatik indiricisi. stemleri otomatikletirin ve grntleri toplu ileyin." }, nav: { home: "Ana Sayfa", features: "zellikler", pricing: "Fiyatlandrma", docs: "Dokmanlar", blog: "Blog", support: "Destek", about: "Hakkmzda", privacy: "Gizlilik", install: "Uzanty Ykle" }, hero: { badge: "Meta Ai  Automator Alternatifi v2.0", titlePrefix: "Toplu Oluturma", titleMiddle: "Resimleri", titleSuffix: "Meta Ai  'te.", subtitle: "Meta Ai   istemlerini otomatikletirin ve tm grntleri annda indirin. Profesyoneller iin kapsaml Meta Ai   i ak otomasyon arac.", ctaPrimary: "Chrome'a Ekle", ctaSecondary: " Akn zle" }, comparison: { title: "cretsiz Aralar vs", manual: "MANUEL SRE", automated: "Meta Ai   OTOMASYONU", manualEffort: "Yksek Stres + 6s/gn", autoEffort: "0 Etkileim + 5dk Kurulum" }, pricing: { title: "Basit Fiyatlandrma", monthly: "Aylk", yearly: "Yllk", lifetime: "mr Boyu", mostPopular: "En Popler", save: "Ekstra %20 tasarruf et", oneTime: "Tek seferlik deme" }, faq: { title: "Ska Sorulan Sorular", items: [{ q: "Toplu grnt nasl oluturulur?", a: "stemlerinizin bir CSV dosyasn ykleyin, personanz ayarlayn ve balata tklayn." }, { q: "Meta Ai   neden yava?", a: "MetaAi Automator kuyruu sizin iin ynetir, en hzl oluturma srelerini salar." }, { q: "Otomatik indirici var m?", a: "Evet! Oluturulan her grnt otomatik olarak klasrnze indirilir." }, { q: "Hz snrlarn hallediyor mu?", a: "'Human-Flow' sistemimiz yasaklanmalar nlemek iin tempoyu ynetir." }] }, cta: { title: "Bugn Toplu Oluturmaya Balayn.", subtitle: "Meta Ai   i ak otomasyonu iin bizi kullanan binlerce kiiye katln." } }, bn: { meta: { title: "MetaAi Automator - Meta Ai  -     ", description: " Meta Ai           " }, nav: { home: "", features: "", pricing: "", docs: "", blog: "", support: "", about: " ", privacy: "", install: "  " }, hero: { badge: "Meta Ai  Automator  v2.0", titlePrefix: "   ", titleMiddle: "", titleSuffix: "Meta Ai  -", subtitle: "Meta Ai               Meta Ai     ", ctaPrimary: "Chrome-  ", ctaSecondary: " " }, comparison: { title: "  ", manual: " ", automated: "Meta Ai   ", manualEffort: "  +  /", autoEffort: "  +   " }, pricing: { title: " ", monthly: "", yearly: "", lifetime: "", mostPopular: " ", save: " %  ", oneTime: " " }, faq: { title: "  ", items: [{ q: "    ?", a: "    CSV  ,    ,    " }, { q: " Meta Ai   ?", a: "MetaAi Automator     ,     " }, { q: "   ?", a: "!         " }, { q: "     ?", a: " 'Human-Flow'       " }] }, cta: { title: "    ", subtitle: "       Meta Ai        " } }, th: { meta: { title: "MetaAi Automator -  Meta Ai  ", description: " Meta Ai    " }, nav: { home: "", features: "", pricing: "", docs: "", blog: "", support: "", about: "", privacy: "", install: "" }, hero: { badge: " Meta Ai  Automator v2.0", titlePrefix: "", titleMiddle: "", titleSuffix: "Meta Ai  .", subtitle: " Meta Ai   prompts   Meta Ai   ", ctaPrimary: " Chrome", ctaSecondary: "" }, comparison: { title: " vs", manual: "", automated: "Meta Ai   ", manualEffort: " + 6 ./", autoEffort: "0  +  5 " }, pricing: { title: "", monthly: "", yearly: "", lifetime: "", mostPopular: "", save: " 20%", oneTime: "" }, faq: { title: "", items: [{ q: "?", a: " CSV  prompts   persona " }, { q: " Meta Ai   ?", a: "MetaAi Automator  " }, { q: "?", a: "! " }, { q: "?", a: " 'Human-Flow' " }] }, cta: { title: "", subtitle: " Meta Ai  " } }, pl: { meta: { title: "MetaAi Automator - Masowe generowanie i pobieranie obrazw w Meta Ai  ", description: "Najlepszy automatyczny downloader Meta Ai  . Automatyzuj podpowiedzi i przetwarzaj obrazy wsadowo." }, nav: { home: "Strona gwna", features: "Funkcje", pricing: "Cennik", docs: "Dokumentacja", blog: "Blog", support: "Wsparcie", about: "O nas", privacy: "Prywatno", install: "Zainstaluj rozszerzenie" }, hero: { badge: "Alternatywa Meta Ai  Automator v2.0", titlePrefix: "Jak masowo generowa", titleMiddle: "Obrazy w", titleSuffix: "Meta Ai  .", subtitle: "Automatyzuj podpowiedzi Meta Ai   i natychmiast pobieraj wszystkie obrazy. Kompleksowe narzdzie do automatyzacji pracy w Meta Ai   dla profesjonalistw.", ctaPrimary: "Dodaj do Chrome", ctaSecondary: "Zobacz Workflow" }, comparison: { title: "Darmowe narzdzia vs", manual: "PROCES RCZNY", automated: "AUTOMATYZACJA Meta Ai  ", manualEffort: "Wysoki stres + 6h/dzie", autoEffort: "0 Interakcji + 5m Konfiguracji" }, pricing: { title: "Prosty cennik", monthly: "Miesiczny", yearly: "Roczny", lifetime: "Doywotni", mostPopular: "Najpopularniejszy", save: "Zaoszczd dodatkowe 20%", oneTime: "Jednorazowa patno" }, faq: { title: "Czsto zadawane pytania", items: [{ q: "Jak masowo generowa obrazy?", a: "Po prostu przelij CSV ze swoimi podpowiedziami, ustaw person i kliknij start." }, { q: "Dlaczego Meta Ai   jest wolny?", a: "MetaAi Automator zarzdza kolejk za Ciebie, zapewniajc najszybszy czas generowania." }, { q: "Czy jest automatyczny downloader?", a: "Tak! Kady wygenerowany obraz jest automatycznie pobierany do Twojego folderu." }, { q: "Czy obsuguje limity szybkoci?", a: "Nasz system 'Human-Flow' zarzdza tempem, aby zapobiec blokadom." }] }, cta: { title: "Rozpocznij masowe generowanie ju dzi.", subtitle: "Docz do tysicy osb, ktre uywaj nas do automatyzacji pracy w Meta Ai  ." } }, ru: { meta: { title: "MetaAi Automator -       Meta Ai  ", description: "   Meta Ai  .      ." }, nav: { home: "", features: "", pricing: "", docs: "", blog: "", support: "", about: " ", privacy: "", install: " " }, hero: { badge: " Meta Ai  Automator v2.0", titlePrefix: "  ", titleMiddle: " ", titleSuffix: "Meta Ai  .", subtitle: "  Meta Ai       .      Meta Ai    .", ctaPrimary: "  Chrome", ctaSecondary: "  " }, comparison: { title: "  vs", manual: " ", automated: "Meta Ai   ", manualEffort: "  + 6/", autoEffort: "0  + 5 " }, pricing: { title: " ", monthly: "", yearly: "", lifetime: "", mostPopular: " ", save: "  20%", oneTime: " " }, faq: { title: "  ", items: [{ q: "   ?", a: "  CSV   ,     ." }, { q: " Meta Ai   ?", a: "MetaAi Automator    ,     ." }, { q: "  ?", a: "!        ." }, { q: "    ?", a: "  'Human-Flow'  ,   ." }] }, cta: { title: "   .", subtitle: "  ,        Meta Ai  ." } } }, cS = [{ icon: Tx, title: "Meta Ai   AI Batch Processing", desc: "Upload thousands of prompts at once. The ultimate answer to how to bulk generate images in Meta Ai  ." }, { icon: Kp, title: "Meta Ai   Auto Downloader", desc: "Automatically detects and downloads every generated image. Export Meta Ai   AI images in bulk instantly." }, { icon: Gx, title: "Automate Meta Ai   Prompts", desc: "Natural timing patterns prevent rate limits. Truly streamline Meta Ai   workflows." }, { icon: Ex, title: "Real-Time Queue Dashboard", desc: "Monitor progress, remaining prompts, and success rates live." }, { icon: Hx, title: "Background Auto-Recovery", desc: "Automatically resumes if interrupted  perfect for Meta Ai   workflow automation." }, { icon: mx, title: "Multi-Format Image Export", desc: "Save as PNG, JPG, or WebP. The best way to export Meta Ai   AI images in bulk." }, { icon: $p, title: "Meta Ai   AI for Power Users", desc: "Smart compression and tagging. Designed for high-volume studios and agencies." }], tg = ze.createContext({ lang: "en", setLang: () => { }, t: eg.en, isRTL: !1 }); var dS = {};/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */let fS, mS; function hS() { return { geminiUrl: fS, vertexUrl: mS } } function pS(i, t, l, a) { var r, d; if (!(i != null && i.baseUrl)) { const m = hS(); return t ? (r = m.vertexUrl) !== null && r !== void 0 ? r : l : (d = m.geminiUrl) !== null && d !== void 0 ? d : a } return i.baseUrl }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class vn { } function J(i, t) { const l = /\{([^}]+)\}/g; return i.replace(l, (a, r) => { if (Object.prototype.hasOwnProperty.call(t, r)) { const d = t[r]; return d != null ? String(d) : "" } else throw new Error(`Key '${r}' not found in valueMap.`) }) } function c(i, t, l) { for (let d = 0; d < t.length - 1; d++) { const m = t[d]; if (m.endsWith("[]")) { const g = m.slice(0, -2); if (!(g in i)) if (Array.isArray(l)) i[g] = Array.from({ length: l.length }, () => ({})); else throw new Error(`Value must be a list given an array path ${m}`); if (Array.isArray(i[g])) { const v = i[g]; if (Array.isArray(l)) for (let p = 0; p < v.length; p++) { const x = v[p]; c(x, t.slice(d + 1), l[p]) } else for (const p of v) c(p, t.slice(d + 1), l) } return } else if (m.endsWith("[0]")) { const g = m.slice(0, -3); g in i || (i[g] = [{}]); const v = i[g]; c(v[0], t.slice(d + 1), l); return } (!i[m] || typeof i[m] != "object") && (i[m] = {}), i = i[m] } const a = t[t.length - 1], r = i[a]; if (r !== void 0) { if (!l || typeof l == "object" && Object.keys(l).length === 0 || l === r) return; if (typeof r == "object" && typeof l == "object" && r !== null && l !== null) Object.assign(r, l); else throw new Error(`Cannot set value for an existing key. Key: ${a}`) } else a === "_self" && typeof l == "object" && l !== null && !Array.isArray(l) ? Object.assign(i, l) : i[a] = l } function u(i, t, l = void 0) { try { if (t.length === 1 && t[0] === "_self") return i; for (let a = 0; a < t.length; a++) { if (typeof i != "object" || i === null) return l; const r = t[a]; if (r.endsWith("[]")) { const d = r.slice(0, -2); if (d in i) { const m = i[d]; return Array.isArray(m) ? m.map(g => u(g, t.slice(a + 1), l)) : l } else return l } else i = i[r] } return i } catch (a) { if (a instanceof TypeError) return l; throw a } } function gS(i, t) { for (const [l, a] of Object.entries(t)) { const r = l.split("."), d = a.split("."), m = new Set; let g = -1; for (let v = 0; v < r.length; v++)if (r[v] === "*") { g = v; break } if (g !== -1 && d.length > g) for (let v = g; v < d.length; v++) { const p = d[v]; p !== "*" && !p.endsWith("[]") && !p.endsWith("[0]") && m.add(p) } Tu(i, r, d, 0, m) } } function Tu(i, t, l, a, r) { if (a >= t.length || typeof i != "object" || i === null) return; const d = t[a]; if (d.endsWith("[]")) { const m = d.slice(0, -2), g = i; if (m in g && Array.isArray(g[m])) for (const v of g[m]) Tu(v, t, l, a + 1, r) } else if (d === "*") { if (typeof i == "object" && i !== null && !Array.isArray(i)) { const m = i, g = Object.keys(m).filter(p => !p.startsWith("_") && !r.has(p)), v = {}; for (const p of g) v[p] = m[p]; for (const [p, x] of Object.entries(v)) { const T = []; for (const _ of l.slice(a)) _ === "*" ? T.push(p) : T.push(_); c(m, T, x) } for (const p of g) delete m[p] } } else { const m = i; d in m && Tu(m[d], t, l, a + 1, r) } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function zu(i) { if (typeof i != "string") throw new Error("fromImageBytes must be a string"); return i }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function yS(i) { const t = {}, l = u(i, ["operationName"]); l != null && c(t, ["operationName"], l); const a = u(i, ["resourceName"]); return a != null && c(t, ["_url", "resourceName"], a), t } function vS(i) { const t = {}, l = u(i, ["name"]); l != null && c(t, ["name"], l); const a = u(i, ["metadata"]); a != null && c(t, ["metadata"], a); const r = u(i, ["done"]); r != null && c(t, ["done"], r); const d = u(i, ["error"]); d != null && c(t, ["error"], d); const m = u(i, ["response", "generateVideoResponse"]); return m != null && c(t, ["response"], SS(m)), t } function xS(i) { const t = {}, l = u(i, ["name"]); l != null && c(t, ["name"], l); const a = u(i, ["metadata"]); a != null && c(t, ["metadata"], a); const r = u(i, ["done"]); r != null && c(t, ["done"], r); const d = u(i, ["error"]); d != null && c(t, ["error"], d); const m = u(i, ["response"]); return m != null && c(t, ["response"], TS(m)), t } function SS(i) { const t = {}, l = u(i, ["generatedSamples"]); if (l != null) { let d = l; Array.isArray(d) && (d = d.map(m => _S(m))), c(t, ["generatedVideos"], d) } const a = u(i, ["raiMediaFilteredCount"]); a != null && c(t, ["raiMediaFilteredCount"], a); const r = u(i, ["raiMediaFilteredReasons"]); return r != null && c(t, ["raiMediaFilteredReasons"], r), t } function TS(i) { const t = {}, l = u(i, ["videos"]); if (l != null) { let d = l; Array.isArray(d) && (d = d.map(m => ES(m))), c(t, ["generatedVideos"], d) } const a = u(i, ["raiMediaFilteredCount"]); a != null && c(t, ["raiMediaFilteredCount"], a); const r = u(i, ["raiMediaFilteredReasons"]); return r != null && c(t, ["raiMediaFilteredReasons"], r), t } function _S(i) { const t = {}, l = u(i, ["video"]); return l != null && c(t, ["video"], MS(l)), t } function ES(i) { const t = {}, l = u(i, ["_self"]); return l != null && c(t, ["video"], RS(l)), t } function AS(i) { const t = {}, l = u(i, ["operationName"]); return l != null && c(t, ["_url", "operationName"], l), t } function CS(i) { const t = {}, l = u(i, ["operationName"]); return l != null && c(t, ["_url", "operationName"], l), t } function bS(i) { const t = {}, l = u(i, ["name"]); l != null && c(t, ["name"], l); const a = u(i, ["metadata"]); a != null && c(t, ["metadata"], a); const r = u(i, ["done"]); r != null && c(t, ["done"], r); const d = u(i, ["error"]); d != null && c(t, ["error"], d); const m = u(i, ["response"]); return m != null && c(t, ["response"], NS(m)), t } function NS(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["parent"]); a != null && c(t, ["parent"], a); const r = u(i, ["documentName"]); return r != null && c(t, ["documentName"], r), t } function ng(i) { const t = {}, l = u(i, ["name"]); l != null && c(t, ["name"], l); const a = u(i, ["metadata"]); a != null && c(t, ["metadata"], a); const r = u(i, ["done"]); r != null && c(t, ["done"], r); const d = u(i, ["error"]); d != null && c(t, ["error"], d); const m = u(i, ["response"]); return m != null && c(t, ["response"], wS(m)), t } function wS(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["parent"]); a != null && c(t, ["parent"], a); const r = u(i, ["documentName"]); return r != null && c(t, ["documentName"], r), t } function MS(i) { const t = {}, l = u(i, ["uri"]); l != null && c(t, ["uri"], l); const a = u(i, ["encodedVideo"]); a != null && c(t, ["videoBytes"], zu(a)); const r = u(i, ["encoding"]); return r != null && c(t, ["mimeType"], r), t } function RS(i) { const t = {}, l = u(i, ["gcsUri"]); l != null && c(t, ["uri"], l); const a = u(i, ["bytesBase64Encoded"]); a != null && c(t, ["videoBytes"], zu(a)); const r = u(i, ["mimeType"]); return r != null && c(t, ["mimeType"], r), t }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */var sh; (function (i) { i.OUTCOME_UNSPECIFIED = "OUTCOME_UNSPECIFIED", i.OUTCOME_OK = "OUTCOME_OK", i.OUTCOME_FAILED = "OUTCOME_FAILED", i.OUTCOME_DEADLINE_EXCEEDED = "OUTCOME_DEADLINE_EXCEEDED" })(sh || (sh = {})); var rh; (function (i) { i.LANGUAGE_UNSPECIFIED = "LANGUAGE_UNSPECIFIED", i.PYTHON = "PYTHON" })(rh || (rh = {})); var uh; (function (i) { i.SCHEDULING_UNSPECIFIED = "SCHEDULING_UNSPECIFIED", i.SILENT = "SILENT", i.WHEN_IDLE = "WHEN_IDLE", i.INTERRUPT = "INTERRUPT" })(uh || (uh = {})); var qt; (function (i) { i.TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED", i.STRING = "STRING", i.NUMBER = "NUMBER", i.INTEGER = "INTEGER", i.BOOLEAN = "BOOLEAN", i.ARRAY = "ARRAY", i.OBJECT = "OBJECT", i.NULL = "NULL" })(qt || (qt = {})); var ch; (function (i) { i.API_SPEC_UNSPECIFIED = "API_SPEC_UNSPECIFIED", i.SIMPLE_SEARCH = "SIMPLE_SEARCH", i.ELASTIC_SEARCH = "ELASTIC_SEARCH" })(ch || (ch = {})); var dh; (function (i) { i.AUTH_TYPE_UNSPECIFIED = "AUTH_TYPE_UNSPECIFIED", i.NO_AUTH = "NO_AUTH", i.API_KEY_AUTH = "API_KEY_AUTH", i.HTTP_BASIC_AUTH = "HTTP_BASIC_AUTH", i.GOOGLE_SERVICE_ACCOUNT_AUTH = "GOOGLE_SERVICE_ACCOUNT_AUTH", i.OAUTH = "OAUTH", i.OIDC_AUTH = "OIDC_AUTH" })(dh || (dh = {})); var fh; (function (i) { i.HTTP_IN_UNSPECIFIED = "HTTP_IN_UNSPECIFIED", i.HTTP_IN_QUERY = "HTTP_IN_QUERY", i.HTTP_IN_HEADER = "HTTP_IN_HEADER", i.HTTP_IN_PATH = "HTTP_IN_PATH", i.HTTP_IN_BODY = "HTTP_IN_BODY", i.HTTP_IN_COOKIE = "HTTP_IN_COOKIE" })(fh || (fh = {})); var mh; (function (i) { i.PHISH_BLOCK_THRESHOLD_UNSPECIFIED = "PHISH_BLOCK_THRESHOLD_UNSPECIFIED", i.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE", i.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE", i.BLOCK_HIGH_AND_ABOVE = "BLOCK_HIGH_AND_ABOVE", i.BLOCK_HIGHER_AND_ABOVE = "BLOCK_HIGHER_AND_ABOVE", i.BLOCK_VERY_HIGH_AND_ABOVE = "BLOCK_VERY_HIGH_AND_ABOVE", i.BLOCK_ONLY_EXTREMELY_HIGH = "BLOCK_ONLY_EXTREMELY_HIGH" })(mh || (mh = {})); var hh; (function (i) { i.UNSPECIFIED = "UNSPECIFIED", i.BLOCKING = "BLOCKING", i.NON_BLOCKING = "NON_BLOCKING" })(hh || (hh = {})); var ph; (function (i) { i.MODE_UNSPECIFIED = "MODE_UNSPECIFIED", i.MODE_DYNAMIC = "MODE_DYNAMIC" })(ph || (ph = {})); var gh; (function (i) { i.MODE_UNSPECIFIED = "MODE_UNSPECIFIED", i.AUTO = "AUTO", i.ANY = "ANY", i.NONE = "NONE", i.VALIDATED = "VALIDATED" })(gh || (gh = {})); var yh; (function (i) { i.THINKING_LEVEL_UNSPECIFIED = "THINKING_LEVEL_UNSPECIFIED", i.LOW = "LOW", i.MEDIUM = "MEDIUM", i.HIGH = "HIGH", i.MINIMAL = "MINIMAL" })(yh || (yh = {})); var vh; (function (i) { i.HARM_CATEGORY_UNSPECIFIED = "HARM_CATEGORY_UNSPECIFIED", i.HARM_CATEGORY_HARASSMENT = "HARM_CATEGORY_HARASSMENT", i.HARM_CATEGORY_HATE_SPEECH = "HARM_CATEGORY_HATE_SPEECH", i.HARM_CATEGORY_SEXUALLY_EXPLICIT = "HARM_CATEGORY_SEXUALLY_EXPLICIT", i.HARM_CATEGORY_DANGEROUS_CONTENT = "HARM_CATEGORY_DANGEROUS_CONTENT", i.HARM_CATEGORY_CIVIC_INTEGRITY = "HARM_CATEGORY_CIVIC_INTEGRITY", i.HARM_CATEGORY_IMAGE_HATE = "HARM_CATEGORY_IMAGE_HATE", i.HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT = "HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT", i.HARM_CATEGORY_IMAGE_HARASSMENT = "HARM_CATEGORY_IMAGE_HARASSMENT", i.HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT = "HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT", i.HARM_CATEGORY_JAILBREAK = "HARM_CATEGORY_JAILBREAK" })(vh || (vh = {})); var xh; (function (i) { i.HARM_BLOCK_METHOD_UNSPECIFIED = "HARM_BLOCK_METHOD_UNSPECIFIED", i.SEVERITY = "SEVERITY", i.PROBABILITY = "PROBABILITY" })(xh || (xh = {})); var Sh; (function (i) { i.HARM_BLOCK_THRESHOLD_UNSPECIFIED = "HARM_BLOCK_THRESHOLD_UNSPECIFIED", i.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE", i.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE", i.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH", i.BLOCK_NONE = "BLOCK_NONE", i.OFF = "OFF" })(Sh || (Sh = {})); var Th; (function (i) { i.FINISH_REASON_UNSPECIFIED = "FINISH_REASON_UNSPECIFIED", i.STOP = "STOP", i.MAX_TOKENS = "MAX_TOKENS", i.SAFETY = "SAFETY", i.RECITATION = "RECITATION", i.LANGUAGE = "LANGUAGE", i.OTHER = "OTHER", i.BLOCKLIST = "BLOCKLIST", i.PROHIBITED_CONTENT = "PROHIBITED_CONTENT", i.SPII = "SPII", i.MALFORMED_FUNCTION_CALL = "MALFORMED_FUNCTION_CALL", i.IMAGE_SAFETY = "IMAGE_SAFETY", i.UNEXPECTED_TOOL_CALL = "UNEXPECTED_TOOL_CALL", i.IMAGE_PROHIBITED_CONTENT = "IMAGE_PROHIBITED_CONTENT", i.NO_IMAGE = "NO_IMAGE", i.IMAGE_RECITATION = "IMAGE_RECITATION", i.IMAGE_OTHER = "IMAGE_OTHER" })(Th || (Th = {})); var _h; (function (i) { i.HARM_PROBABILITY_UNSPECIFIED = "HARM_PROBABILITY_UNSPECIFIED", i.NEGLIGIBLE = "NEGLIGIBLE", i.LOW = "LOW", i.MEDIUM = "MEDIUM", i.HIGH = "HIGH" })(_h || (_h = {})); var Eh; (function (i) { i.HARM_SEVERITY_UNSPECIFIED = "HARM_SEVERITY_UNSPECIFIED", i.HARM_SEVERITY_NEGLIGIBLE = "HARM_SEVERITY_NEGLIGIBLE", i.HARM_SEVERITY_LOW = "HARM_SEVERITY_LOW", i.HARM_SEVERITY_MEDIUM = "HARM_SEVERITY_MEDIUM", i.HARM_SEVERITY_HIGH = "HARM_SEVERITY_HIGH" })(Eh || (Eh = {})); var Ah; (function (i) { i.URL_RETRIEVAL_STATUS_UNSPECIFIED = "URL_RETRIEVAL_STATUS_UNSPECIFIED", i.URL_RETRIEVAL_STATUS_SUCCESS = "URL_RETRIEVAL_STATUS_SUCCESS", i.URL_RETRIEVAL_STATUS_ERROR = "URL_RETRIEVAL_STATUS_ERROR", i.URL_RETRIEVAL_STATUS_PAYWALL = "URL_RETRIEVAL_STATUS_PAYWALL", i.URL_RETRIEVAL_STATUS_UNSAFE = "URL_RETRIEVAL_STATUS_UNSAFE" })(Ah || (Ah = {})); var Ch; (function (i) { i.BLOCKED_REASON_UNSPECIFIED = "BLOCKED_REASON_UNSPECIFIED", i.SAFETY = "SAFETY", i.OTHER = "OTHER", i.BLOCKLIST = "BLOCKLIST", i.PROHIBITED_CONTENT = "PROHIBITED_CONTENT", i.IMAGE_SAFETY = "IMAGE_SAFETY", i.MODEL_ARMOR = "MODEL_ARMOR", i.JAILBREAK = "JAILBREAK" })(Ch || (Ch = {})); var bh; (function (i) { i.TRAFFIC_TYPE_UNSPECIFIED = "TRAFFIC_TYPE_UNSPECIFIED", i.ON_DEMAND = "ON_DEMAND", i.PROVISIONED_THROUGHPUT = "PROVISIONED_THROUGHPUT" })(bh || (bh = {})); var Ga; (function (i) { i.MODALITY_UNSPECIFIED = "MODALITY_UNSPECIFIED", i.TEXT = "TEXT", i.IMAGE = "IMAGE", i.AUDIO = "AUDIO" })(Ga || (Ga = {})); var Nh; (function (i) { i.MEDIA_RESOLUTION_UNSPECIFIED = "MEDIA_RESOLUTION_UNSPECIFIED", i.MEDIA_RESOLUTION_LOW = "MEDIA_RESOLUTION_LOW", i.MEDIA_RESOLUTION_MEDIUM = "MEDIA_RESOLUTION_MEDIUM", i.MEDIA_RESOLUTION_HIGH = "MEDIA_RESOLUTION_HIGH" })(Nh || (Nh = {})); var wh; (function (i) { i.TUNING_MODE_UNSPECIFIED = "TUNING_MODE_UNSPECIFIED", i.TUNING_MODE_FULL = "TUNING_MODE_FULL", i.TUNING_MODE_PEFT_ADAPTER = "TUNING_MODE_PEFT_ADAPTER" })(wh || (wh = {})); var Mh; (function (i) { i.ADAPTER_SIZE_UNSPECIFIED = "ADAPTER_SIZE_UNSPECIFIED", i.ADAPTER_SIZE_ONE = "ADAPTER_SIZE_ONE", i.ADAPTER_SIZE_TWO = "ADAPTER_SIZE_TWO", i.ADAPTER_SIZE_FOUR = "ADAPTER_SIZE_FOUR", i.ADAPTER_SIZE_EIGHT = "ADAPTER_SIZE_EIGHT", i.ADAPTER_SIZE_SIXTEEN = "ADAPTER_SIZE_SIXTEEN", i.ADAPTER_SIZE_THIRTY_TWO = "ADAPTER_SIZE_THIRTY_TWO" })(Mh || (Mh = {})); var _u; (function (i) { i.JOB_STATE_UNSPECIFIED = "JOB_STATE_UNSPECIFIED", i.JOB_STATE_QUEUED = "JOB_STATE_QUEUED", i.JOB_STATE_PENDING = "JOB_STATE_PENDING", i.JOB_STATE_RUNNING = "JOB_STATE_RUNNING", i.JOB_STATE_SUCCEEDED = "JOB_STATE_SUCCEEDED", i.JOB_STATE_FAILED = "JOB_STATE_FAILED", i.JOB_STATE_CANCELLING = "JOB_STATE_CANCELLING", i.JOB_STATE_CANCELLED = "JOB_STATE_CANCELLED", i.JOB_STATE_PAUSED = "JOB_STATE_PAUSED", i.JOB_STATE_EXPIRED = "JOB_STATE_EXPIRED", i.JOB_STATE_UPDATING = "JOB_STATE_UPDATING", i.JOB_STATE_PARTIALLY_SUCCEEDED = "JOB_STATE_PARTIALLY_SUCCEEDED" })(_u || (_u = {})); var Rh; (function (i) { i.TUNING_TASK_UNSPECIFIED = "TUNING_TASK_UNSPECIFIED", i.TUNING_TASK_I2V = "TUNING_TASK_I2V", i.TUNING_TASK_T2V = "TUNING_TASK_T2V", i.TUNING_TASK_R2V = "TUNING_TASK_R2V" })(Rh || (Rh = {})); var Ih; (function (i) { i.MEDIA_RESOLUTION_UNSPECIFIED = "MEDIA_RESOLUTION_UNSPECIFIED", i.MEDIA_RESOLUTION_LOW = "MEDIA_RESOLUTION_LOW", i.MEDIA_RESOLUTION_MEDIUM = "MEDIA_RESOLUTION_MEDIUM", i.MEDIA_RESOLUTION_HIGH = "MEDIA_RESOLUTION_HIGH", i.MEDIA_RESOLUTION_ULTRA_HIGH = "MEDIA_RESOLUTION_ULTRA_HIGH" })(Ih || (Ih = {})); var kh; (function (i) { i.FEATURE_SELECTION_PREFERENCE_UNSPECIFIED = "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED", i.PRIORITIZE_QUALITY = "PRIORITIZE_QUALITY", i.BALANCED = "BALANCED", i.PRIORITIZE_COST = "PRIORITIZE_COST" })(kh || (kh = {})); var Dh; (function (i) { i.ENVIRONMENT_UNSPECIFIED = "ENVIRONMENT_UNSPECIFIED", i.ENVIRONMENT_BROWSER = "ENVIRONMENT_BROWSER" })(Dh || (Dh = {})); var Uh; (function (i) { i.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE", i.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE", i.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH", i.BLOCK_NONE = "BLOCK_NONE" })(Uh || (Uh = {})); var Gh; (function (i) { i.DONT_ALLOW = "DONT_ALLOW", i.ALLOW_ADULT = "ALLOW_ADULT", i.ALLOW_ALL = "ALLOW_ALL" })(Gh || (Gh = {})); var Lh; (function (i) { i.auto = "auto", i.en = "en", i.ja = "ja", i.ko = "ko", i.hi = "hi", i.zh = "zh", i.pt = "pt", i.es = "es" })(Lh || (Lh = {})); var zh; (function (i) { i.MASK_MODE_DEFAULT = "MASK_MODE_DEFAULT", i.MASK_MODE_USER_PROVIDED = "MASK_MODE_USER_PROVIDED", i.MASK_MODE_BACKGROUND = "MASK_MODE_BACKGROUND", i.MASK_MODE_FOREGROUND = "MASK_MODE_FOREGROUND", i.MASK_MODE_SEMANTIC = "MASK_MODE_SEMANTIC" })(zh || (zh = {})); var qh; (function (i) { i.CONTROL_TYPE_DEFAULT = "CONTROL_TYPE_DEFAULT", i.CONTROL_TYPE_CANNY = "CONTROL_TYPE_CANNY", i.CONTROL_TYPE_SCRIBBLE = "CONTROL_TYPE_SCRIBBLE", i.CONTROL_TYPE_FACE_MESH = "CONTROL_TYPE_FACE_MESH" })(qh || (qh = {})); var Hh; (function (i) { i.SUBJECT_TYPE_DEFAULT = "SUBJECT_TYPE_DEFAULT", i.SUBJECT_TYPE_PERSON = "SUBJECT_TYPE_PERSON", i.SUBJECT_TYPE_ANIMAL = "SUBJECT_TYPE_ANIMAL", i.SUBJECT_TYPE_PRODUCT = "SUBJECT_TYPE_PRODUCT" })(Hh || (Hh = {})); var Ph; (function (i) { i.EDIT_MODE_DEFAULT = "EDIT_MODE_DEFAULT", i.EDIT_MODE_INPAINT_REMOVAL = "EDIT_MODE_INPAINT_REMOVAL", i.EDIT_MODE_INPAINT_INSERTION = "EDIT_MODE_INPAINT_INSERTION", i.EDIT_MODE_OUTPAINT = "EDIT_MODE_OUTPAINT", i.EDIT_MODE_CONTROLLED_EDITING = "EDIT_MODE_CONTROLLED_EDITING", i.EDIT_MODE_STYLE = "EDIT_MODE_STYLE", i.EDIT_MODE_BGSWAP = "EDIT_MODE_BGSWAP", i.EDIT_MODE_PRODUCT_IMAGE = "EDIT_MODE_PRODUCT_IMAGE" })(Ph || (Ph = {})); var Vh; (function (i) { i.FOREGROUND = "FOREGROUND", i.BACKGROUND = "BACKGROUND", i.PROMPT = "PROMPT", i.SEMANTIC = "SEMANTIC", i.INTERACTIVE = "INTERACTIVE" })(Vh || (Vh = {})); var Bh; (function (i) { i.ASSET = "ASSET", i.STYLE = "STYLE" })(Bh || (Bh = {})); var Oh; (function (i) { i.INSERT = "INSERT", i.REMOVE = "REMOVE", i.REMOVE_STATIC = "REMOVE_STATIC", i.OUTPAINT = "OUTPAINT" })(Oh || (Oh = {})); var Fh; (function (i) { i.OPTIMIZED = "OPTIMIZED", i.LOSSLESS = "LOSSLESS" })(Fh || (Fh = {})); var Yh; (function (i) { i.SUPERVISED_FINE_TUNING = "SUPERVISED_FINE_TUNING", i.PREFERENCE_TUNING = "PREFERENCE_TUNING" })(Yh || (Yh = {})); var Jh; (function (i) { i.STATE_UNSPECIFIED = "STATE_UNSPECIFIED", i.STATE_PENDING = "STATE_PENDING", i.STATE_ACTIVE = "STATE_ACTIVE", i.STATE_FAILED = "STATE_FAILED" })(Jh || (Jh = {})); var Wh; (function (i) { i.STATE_UNSPECIFIED = "STATE_UNSPECIFIED", i.PROCESSING = "PROCESSING", i.ACTIVE = "ACTIVE", i.FAILED = "FAILED" })(Wh || (Wh = {})); var Kh; (function (i) { i.SOURCE_UNSPECIFIED = "SOURCE_UNSPECIFIED", i.UPLOADED = "UPLOADED", i.GENERATED = "GENERATED", i.REGISTERED = "REGISTERED" })(Kh || (Kh = {})); var Xh; (function (i) { i.TURN_COMPLETE_REASON_UNSPECIFIED = "TURN_COMPLETE_REASON_UNSPECIFIED", i.MALFORMED_FUNCTION_CALL = "MALFORMED_FUNCTION_CALL", i.RESPONSE_REJECTED = "RESPONSE_REJECTED", i.NEED_MORE_INPUT = "NEED_MORE_INPUT" })(Xh || (Xh = {})); var Qh; (function (i) { i.MODALITY_UNSPECIFIED = "MODALITY_UNSPECIFIED", i.TEXT = "TEXT", i.IMAGE = "IMAGE", i.VIDEO = "VIDEO", i.AUDIO = "AUDIO", i.DOCUMENT = "DOCUMENT" })(Qh || (Qh = {})); var jh; (function (i) { i.VAD_SIGNAL_TYPE_UNSPECIFIED = "VAD_SIGNAL_TYPE_UNSPECIFIED", i.VAD_SIGNAL_TYPE_SOS = "VAD_SIGNAL_TYPE_SOS", i.VAD_SIGNAL_TYPE_EOS = "VAD_SIGNAL_TYPE_EOS" })(jh || (jh = {})); var Zh; (function (i) { i.START_SENSITIVITY_UNSPECIFIED = "START_SENSITIVITY_UNSPECIFIED", i.START_SENSITIVITY_HIGH = "START_SENSITIVITY_HIGH", i.START_SENSITIVITY_LOW = "START_SENSITIVITY_LOW" })(Zh || (Zh = {})); var $h; (function (i) { i.END_SENSITIVITY_UNSPECIFIED = "END_SENSITIVITY_UNSPECIFIED", i.END_SENSITIVITY_HIGH = "END_SENSITIVITY_HIGH", i.END_SENSITIVITY_LOW = "END_SENSITIVITY_LOW" })($h || ($h = {})); var ep; (function (i) { i.ACTIVITY_HANDLING_UNSPECIFIED = "ACTIVITY_HANDLING_UNSPECIFIED", i.START_OF_ACTIVITY_INTERRUPTS = "START_OF_ACTIVITY_INTERRUPTS", i.NO_INTERRUPTION = "NO_INTERRUPTION" })(ep || (ep = {})); var tp; (function (i) { i.TURN_COVERAGE_UNSPECIFIED = "TURN_COVERAGE_UNSPECIFIED", i.TURN_INCLUDES_ONLY_ACTIVITY = "TURN_INCLUDES_ONLY_ACTIVITY", i.TURN_INCLUDES_ALL_INPUT = "TURN_INCLUDES_ALL_INPUT" })(tp || (tp = {})); var np; (function (i) { i.SCALE_UNSPECIFIED = "SCALE_UNSPECIFIED", i.C_MAJOR_A_MINOR = "C_MAJOR_A_MINOR", i.D_FLAT_MAJOR_B_FLAT_MINOR = "D_FLAT_MAJOR_B_FLAT_MINOR", i.D_MAJOR_B_MINOR = "D_MAJOR_B_MINOR", i.E_FLAT_MAJOR_C_MINOR = "E_FLAT_MAJOR_C_MINOR", i.E_MAJOR_D_FLAT_MINOR = "E_MAJOR_D_FLAT_MINOR", i.F_MAJOR_D_MINOR = "F_MAJOR_D_MINOR", i.G_FLAT_MAJOR_E_FLAT_MINOR = "G_FLAT_MAJOR_E_FLAT_MINOR", i.G_MAJOR_E_MINOR = "G_MAJOR_E_MINOR", i.A_FLAT_MAJOR_F_MINOR = "A_FLAT_MAJOR_F_MINOR", i.A_MAJOR_G_FLAT_MINOR = "A_MAJOR_G_FLAT_MINOR", i.B_FLAT_MAJOR_G_MINOR = "B_FLAT_MAJOR_G_MINOR", i.B_MAJOR_A_FLAT_MINOR = "B_MAJOR_A_FLAT_MINOR" })(np || (np = {})); var ip; (function (i) { i.MUSIC_GENERATION_MODE_UNSPECIFIED = "MUSIC_GENERATION_MODE_UNSPECIFIED", i.QUALITY = "QUALITY", i.DIVERSITY = "DIVERSITY", i.VOCALIZATION = "VOCALIZATION" })(ip || (ip = {})); var eo; (function (i) { i.PLAYBACK_CONTROL_UNSPECIFIED = "PLAYBACK_CONTROL_UNSPECIFIED", i.PLAY = "PLAY", i.PAUSE = "PAUSE", i.STOP = "STOP", i.RESET_CONTEXT = "RESET_CONTEXT" })(eo || (eo = {})); class Eu { constructor(t) { const l = {}; for (const a of t.headers.entries()) l[a[0]] = a[1]; this.headers = l, this.responseInternal = t } json() { return this.responseInternal.json() } } class ol { get text() { var t, l, a, r, d, m, g, v; if (((r = (a = (l = (t = this.candidates) === null || t === void 0 ? void 0 : t[0]) === null || l === void 0 ? void 0 : l.content) === null || a === void 0 ? void 0 : a.parts) === null || r === void 0 ? void 0 : r.length) === 0) return; this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning text from the first one."); let p = "", x = !1; const T = []; for (const _ of (v = (g = (m = (d = this.candidates) === null || d === void 0 ? void 0 : d[0]) === null || m === void 0 ? void 0 : m.content) === null || g === void 0 ? void 0 : g.parts) !== null && v !== void 0 ? v : []) { for (const [A, k] of Object.entries(_)) A !== "text" && A !== "thought" && A !== "thoughtSignature" && (k !== null || k !== void 0) && T.push(A); if (typeof _.text == "string") { if (typeof _.thought == "boolean" && _.thought) continue; x = !0, p += _.text } } return T.length > 0 && console.warn(`there are non-text parts ${T} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`), x ? p : void 0 } get data() { var t, l, a, r, d, m, g, v; if (((r = (a = (l = (t = this.candidates) === null || t === void 0 ? void 0 : t[0]) === null || l === void 0 ? void 0 : l.content) === null || a === void 0 ? void 0 : a.parts) === null || r === void 0 ? void 0 : r.length) === 0) return; this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning data from the first one."); let p = ""; const x = []; for (const T of (v = (g = (m = (d = this.candidates) === null || d === void 0 ? void 0 : d[0]) === null || m === void 0 ? void 0 : m.content) === null || g === void 0 ? void 0 : g.parts) !== null && v !== void 0 ? v : []) { for (const [_, A] of Object.entries(T)) _ !== "inlineData" && (A !== null || A !== void 0) && x.push(_); T.inlineData && typeof T.inlineData.data == "string" && (p += atob(T.inlineData.data)) } return x.length > 0 && console.warn(`there are non-data parts ${x} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`), p.length > 0 ? btoa(p) : void 0 } get functionCalls() { var t, l, a, r, d, m, g, v; if (((r = (a = (l = (t = this.candidates) === null || t === void 0 ? void 0 : t[0]) === null || l === void 0 ? void 0 : l.content) === null || a === void 0 ? void 0 : a.parts) === null || r === void 0 ? void 0 : r.length) === 0) return; this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning function calls from the first one."); const p = (v = (g = (m = (d = this.candidates) === null || d === void 0 ? void 0 : d[0]) === null || m === void 0 ? void 0 : m.content) === null || g === void 0 ? void 0 : g.parts) === null || v === void 0 ? void 0 : v.filter(x => x.functionCall).map(x => x.functionCall).filter(x => x !== void 0); if ((p == null ? void 0 : p.length) !== 0) return p } get executableCode() { var t, l, a, r, d, m, g, v, p; if (((r = (a = (l = (t = this.candidates) === null || t === void 0 ? void 0 : t[0]) === null || l === void 0 ? void 0 : l.content) === null || a === void 0 ? void 0 : a.parts) === null || r === void 0 ? void 0 : r.length) === 0) return; this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning executable code from the first one."); const x = (v = (g = (m = (d = this.candidates) === null || d === void 0 ? void 0 : d[0]) === null || m === void 0 ? void 0 : m.content) === null || g === void 0 ? void 0 : g.parts) === null || v === void 0 ? void 0 : v.filter(T => T.executableCode).map(T => T.executableCode).filter(T => T !== void 0); if ((x == null ? void 0 : x.length) !== 0) return (p = x == null ? void 0 : x[0]) === null || p === void 0 ? void 0 : p.code } get codeExecutionResult() { var t, l, a, r, d, m, g, v, p; if (((r = (a = (l = (t = this.candidates) === null || t === void 0 ? void 0 : t[0]) === null || l === void 0 ? void 0 : l.content) === null || a === void 0 ? void 0 : a.parts) === null || r === void 0 ? void 0 : r.length) === 0) return; this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning code execution result from the first one."); const x = (v = (g = (m = (d = this.candidates) === null || d === void 0 ? void 0 : d[0]) === null || m === void 0 ? void 0 : m.content) === null || g === void 0 ? void 0 : g.parts) === null || v === void 0 ? void 0 : v.filter(T => T.codeExecutionResult).map(T => T.codeExecutionResult).filter(T => T !== void 0); if ((x == null ? void 0 : x.length) !== 0) return (p = x == null ? void 0 : x[0]) === null || p === void 0 ? void 0 : p.output } } class op { } class lp { } class IS { } class kS { } class DS { } class US { } class ap { } class sp { } class rp { } class GS { } class La { _fromAPIResponse({ apiResponse: t, _isVertexAI: l }) { const a = new La; let r; const d = t; return l ? r = xS(d) : r = vS(d), Object.assign(a, r), a } } class up { } class cp { } class dp { } class fp { } class LS { } class zS { } class qS { } class qu { _fromAPIResponse({ apiResponse: t, _isVertexAI: l }) { const a = new qu, d = bS(t); return Object.assign(a, d), a } } class HS { } class PS { } class VS { } class mp { } class BS { get text() { var t, l, a; let r = "", d = !1; const m = []; for (const g of (a = (l = (t = this.serverContent) === null || t === void 0 ? void 0 : t.modelTurn) === null || l === void 0 ? void 0 : l.parts) !== null && a !== void 0 ? a : []) { for (const [v, p] of Object.entries(g)) v !== "text" && v !== "thought" && p !== null && m.push(v); if (typeof g.text == "string") { if (typeof g.thought == "boolean" && g.thought) continue; d = !0, r += g.text } } return m.length > 0 && console.warn(`there are non-text parts ${m} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`), d ? r : void 0 } get data() { var t, l, a; let r = ""; const d = []; for (const m of (a = (l = (t = this.serverContent) === null || t === void 0 ? void 0 : t.modelTurn) === null || l === void 0 ? void 0 : l.parts) !== null && a !== void 0 ? a : []) { for (const [g, v] of Object.entries(m)) g !== "inlineData" && v !== null && d.push(g); m.inlineData && typeof m.inlineData.data == "string" && (r += atob(m.inlineData.data)) } return d.length > 0 && console.warn(`there are non-data parts ${d} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`), r.length > 0 ? btoa(r) : void 0 } } class OS { get audioChunk() { if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0) return this.serverContent.audioChunks[0] } } class Hu { _fromAPIResponse({ apiResponse: t, _isVertexAI: l }) { const a = new Hu, d = ng(t); return Object.assign(a, d), a } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Se(i, t) { if (!t || typeof t != "string") throw new Error("model is required and must be a string"); if (t.includes("..") || t.includes("?") || t.includes("&")) throw new Error("invalid model parameter"); if (i.isVertexAI()) { if (t.startsWith("publishers/") || t.startsWith("projects/") || t.startsWith("models/")) return t; if (t.indexOf("/") >= 0) { const l = t.split("/", 2); return `publishers/${l[0]}/models/${l[1]}` } else return `publishers/google/models/${t}` } else return t.startsWith("models/") || t.startsWith("tunedModels/") ? t : `models/${t}` } function ig(i, t) { const l = Se(i, t); return l ? l.startsWith("publishers/") && i.isVertexAI() ? `projects/${i.getProject()}/locations/${i.getLocation()}/${l}` : l.startsWith("models/") && i.isVertexAI() ? `projects/${i.getProject()}/locations/${i.getLocation()}/publishers/google/${l}` : l : "" } function og(i) { return Array.isArray(i) ? i.map(t => za(t)) : [za(i)] } function za(i) { if (typeof i == "object" && i !== null) return i; throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof i}`) } function lg(i) { const t = za(i); if (t.mimeType && t.mimeType.startsWith("image/")) return t; throw new Error(`Unsupported mime type: ${t.mimeType}`) } function ag(i) { const t = za(i); if (t.mimeType && t.mimeType.startsWith("audio/")) return t; throw new Error(`Unsupported mime type: ${t.mimeType}`) } function hp(i) { if (i == null) throw new Error("PartUnion is required"); if (typeof i == "object") return i; if (typeof i == "string") return { text: i }; throw new Error(`Unsupported part type: ${typeof i}`) } function sg(i) { if (i == null || Array.isArray(i) && i.length === 0) throw new Error("PartListUnion is required"); return Array.isArray(i) ? i.map(t => hp(t)) : [hp(i)] } function Au(i) { return i != null && typeof i == "object" && "parts" in i && Array.isArray(i.parts) } function pp(i) { return i != null && typeof i == "object" && "functionCall" in i } function gp(i) { return i != null && typeof i == "object" && "functionResponse" in i } function ot(i) { if (i == null) throw new Error("ContentUnion is required"); return Au(i) ? i : { role: "user", parts: sg(i) } } function Pu(i, t) { if (!t) return []; if (i.isVertexAI() && Array.isArray(t)) return t.flatMap(l => { const a = ot(l); return a.parts && a.parts.length > 0 && a.parts[0].text !== void 0 ? [a.parts[0].text] : [] }); if (i.isVertexAI()) { const l = ot(t); return l.parts && l.parts.length > 0 && l.parts[0].text !== void 0 ? [l.parts[0].text] : [] } return Array.isArray(t) ? t.map(l => ot(l)) : [ot(t)] } function Ht(i) { if (i == null || Array.isArray(i) && i.length === 0) throw new Error("contents are required"); if (!Array.isArray(i)) { if (pp(i) || gp(i)) throw new Error("To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them"); return [ot(i)] } const t = [], l = [], a = Au(i[0]); for (const r of i) { const d = Au(r); if (d != a) throw new Error("Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them"); if (d) t.push(r); else { if (pp(r) || gp(r)) throw new Error("To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them"); l.push(r) } } return a || t.push({ role: "user", parts: sg(l) }), t } function FS(i, t) { i.includes("null") && (t.nullable = !0); const l = i.filter(a => a !== "null"); if (l.length === 1) t.type = Object.values(qt).includes(l[0].toUpperCase()) ? l[0].toUpperCase() : qt.TYPE_UNSPECIFIED; else { t.anyOf = []; for (const a of l) t.anyOf.push({ type: Object.values(qt).includes(a.toUpperCase()) ? a.toUpperCase() : qt.TYPE_UNSPECIFIED }) } } function no(i) { const t = {}, l = ["items"], a = ["anyOf"], r = ["properties"]; if (i.type && i.anyOf) throw new Error("type and anyOf cannot be both populated."); const d = i.anyOf; d != null && d.length == 2 && (d[0].type === "null" ? (t.nullable = !0, i = d[1]) : d[1].type === "null" && (t.nullable = !0, i = d[0])), i.type instanceof Array && FS(i.type, t); for (const [m, g] of Object.entries(i)) if (g != null) if (m == "type") { if (g === "null") throw new Error("type: null can not be the only possible type for the field."); if (g instanceof Array) continue; t.type = Object.values(qt).includes(g.toUpperCase()) ? g.toUpperCase() : qt.TYPE_UNSPECIFIED } else if (l.includes(m)) t[m] = no(g); else if (a.includes(m)) { const v = []; for (const p of g) { if (p.type == "null") { t.nullable = !0; continue } v.push(no(p)) } t[m] = v } else if (r.includes(m)) { const v = {}; for (const [p, x] of Object.entries(g)) v[p] = no(x); t[m] = v } else { if (m === "additionalProperties") continue; t[m] = g } return t } function Vu(i) { return no(i) } function Bu(i) { if (typeof i == "object") return i; if (typeof i == "string") return { voiceConfig: { prebuiltVoiceConfig: { voiceName: i } } }; throw new Error(`Unsupported speechConfig type: ${typeof i}`) } function Ou(i) { if ("multiSpeakerVoiceConfig" in i) throw new Error("multiSpeakerVoiceConfig is not supported in the live API."); return i } function oo(i) { if (i.functionDeclarations) for (const t of i.functionDeclarations) t.parameters && (Object.keys(t.parameters).includes("$schema") ? t.parametersJsonSchema || (t.parametersJsonSchema = t.parameters, delete t.parameters) : t.parameters = no(t.parameters)), t.response && (Object.keys(t.response).includes("$schema") ? t.responseJsonSchema || (t.responseJsonSchema = t.response, delete t.response) : t.response = no(t.response)); return i } function lo(i) { if (i == null) throw new Error("tools is required"); if (!Array.isArray(i)) throw new Error("tools is required and must be an array of Tools"); const t = []; for (const l of i) t.push(l); return t } function YS(i, t, l, a = 1) { const r = !t.startsWith(`${l}/`) && t.split("/").length === a; return i.isVertexAI() ? t.startsWith("projects/") ? t : t.startsWith("locations/") ? `projects/${i.getProject()}/${t}` : t.startsWith(`${l}/`) ? `projects/${i.getProject()}/locations/${i.getLocation()}/${t}` : r ? `projects/${i.getProject()}/locations/${i.getLocation()}/${l}/${t}` : t : r ? `${l}/${t}` : t } function xn(i, t) { if (typeof t != "string") throw new Error("name must be a string"); return YS(i, t, "cachedContents") } function rg(i) { switch (i) { case "STATE_UNSPECIFIED": return "JOB_STATE_UNSPECIFIED"; case "CREATING": return "JOB_STATE_RUNNING"; case "ACTIVE": return "JOB_STATE_SUCCEEDED"; case "FAILED": return "JOB_STATE_FAILED"; default: return i } } function Yn(i) { return zu(i) } function JS(i) { return i != null && typeof i == "object" && "name" in i } function WS(i) { return i != null && typeof i == "object" && "video" in i } function KS(i) { return i != null && typeof i == "object" && "uri" in i } function ug(i) { var t; let l; if (JS(i) && (l = i.name), !(KS(i) && (l = i.uri, l === void 0)) && !(WS(i) && (l = (t = i.video) === null || t === void 0 ? void 0 : t.uri, l === void 0))) { if (typeof i == "string" && (l = i), l === void 0) throw new Error("Could not extract file name from the provided input."); if (l.startsWith("https://")) { const r = l.split("files/")[1].match(/[a-z0-9]+/); if (r === null) throw new Error(`Could not extract file name from URI ${l}`); l = r[0] } else l.startsWith("files/") && (l = l.split("files/")[1]); return l } } function cg(i, t) { let l; return i.isVertexAI() ? l = t ? "publishers/google/models" : "models" : l = t ? "models" : "tunedModels", l } function dg(i) { for (const t of ["models", "tunedModels", "publisherModels"]) if (XS(i, t)) return i[t]; return [] } function XS(i, t) { return i !== null && typeof i == "object" && t in i } function QS(i, t = {}) { const l = i, a = { name: l.name, description: l.description, parametersJsonSchema: l.inputSchema }; return l.outputSchema && (a.responseJsonSchema = l.outputSchema), t.behavior && (a.behavior = t.behavior), { functionDeclarations: [a] } } function jS(i, t = {}) { const l = [], a = new Set; for (const r of i) { const d = r.name; if (a.has(d)) throw new Error(`Duplicate function name ${d} found in MCP tools. Please ensure function names are unique.`); a.add(d); const m = QS(r, t); m.functionDeclarations && l.push(...m.functionDeclarations) } return { functionDeclarations: l } } function fg(i, t) { let l; if (typeof t == "string") if (i.isVertexAI()) if (t.startsWith("gs://")) l = { format: "jsonl", gcsUri: [t] }; else if (t.startsWith("bq://")) l = { format: "bigquery", bigqueryUri: t }; else throw new Error(`Unsupported string source for Vertex AI: ${t}`); else if (t.startsWith("files/")) l = { fileName: t }; else throw new Error(`Unsupported string source for Gemini API: ${t}`); else if (Array.isArray(t)) { if (i.isVertexAI()) throw new Error("InlinedRequest[] is not supported in Vertex AI."); l = { inlinedRequests: t } } else l = t; const a = [l.gcsUri, l.bigqueryUri].filter(Boolean).length, r = [l.inlinedRequests, l.fileName].filter(Boolean).length; if (i.isVertexAI()) { if (r > 0 || a !== 1) throw new Error("Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.") } else if (a > 0 || r !== 1) throw new Error("Exactly one of `inlinedRequests`, `fileName`, must be set for Gemini API."); return l } function ZS(i) { if (typeof i != "string") return i; const t = i; if (t.startsWith("gs://")) return { format: "jsonl", gcsUri: t }; if (t.startsWith("bq://")) return { format: "bigquery", bigqueryUri: t }; throw new Error(`Unsupported destination: ${t}`) } function mg(i) { if (typeof i != "object" || i === null) return {}; const t = i, l = t.inlinedResponses; if (typeof l != "object" || l === null) return i; const r = l.inlinedResponses; if (!Array.isArray(r) || r.length === 0) return i; let d = !1; for (const m of r) { if (typeof m != "object" || m === null) continue; const v = m.response; if (typeof v != "object" || v === null) continue; if (v.embedding !== void 0) { d = !0; break } } return d && (t.inlinedEmbedContentResponses = t.inlinedResponses, delete t.inlinedResponses), i } function ao(i, t) { const l = t; if (!i.isVertexAI()) { if (/batches\/[^/]+$/.test(l)) return l.split("/").pop(); throw new Error(`Invalid batch job name: ${l}.`) } if (/^projects\/[^/]+\/locations\/[^/]+\/batchPredictionJobs\/[^/]+$/.test(l)) return l.split("/").pop(); if (/^\d+$/.test(l)) return l; throw new Error(`Invalid batch job name: ${l}.`) } function hg(i) { const t = i; return t === "BATCH_STATE_UNSPECIFIED" ? "JOB_STATE_UNSPECIFIED" : t === "BATCH_STATE_PENDING" ? "JOB_STATE_PENDING" : t === "BATCH_STATE_RUNNING" ? "JOB_STATE_RUNNING" : t === "BATCH_STATE_SUCCEEDED" ? "JOB_STATE_SUCCEEDED" : t === "BATCH_STATE_FAILED" ? "JOB_STATE_FAILED" : t === "BATCH_STATE_CANCELLED" ? "JOB_STATE_CANCELLED" : t === "BATCH_STATE_EXPIRED" ? "JOB_STATE_EXPIRED" : t }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function $S(i) { const t = {}, l = u(i, ["responsesFile"]); l != null && c(t, ["fileName"], l); const a = u(i, ["inlinedResponses", "inlinedResponses"]); if (a != null) { let d = a; Array.isArray(d) && (d = d.map(m => DT(m))), c(t, ["inlinedResponses"], d) } const r = u(i, ["inlinedEmbedContentResponses", "inlinedResponses"]); if (r != null) { let d = r; Array.isArray(d) && (d = d.map(m => m)), c(t, ["inlinedEmbedContentResponses"], d) } return t } function eT(i) { const t = {}, l = u(i, ["predictionsFormat"]); l != null && c(t, ["format"], l); const a = u(i, ["gcsDestination", "outputUriPrefix"]); a != null && c(t, ["gcsUri"], a); const r = u(i, ["bigqueryDestination", "outputUri"]); return r != null && c(t, ["bigqueryUri"], r), t } function tT(i) { const t = {}, l = u(i, ["format"]); l != null && c(t, ["predictionsFormat"], l); const a = u(i, ["gcsUri"]); a != null && c(t, ["gcsDestination", "outputUriPrefix"], a); const r = u(i, ["bigqueryUri"]); if (r != null && c(t, ["bigqueryDestination", "outputUri"], r), u(i, ["fileName"]) !== void 0) throw new Error("fileName parameter is not supported in Vertex AI."); if (u(i, ["inlinedResponses"]) !== void 0) throw new Error("inlinedResponses parameter is not supported in Vertex AI."); if (u(i, ["inlinedEmbedContentResponses"]) !== void 0) throw new Error("inlinedEmbedContentResponses parameter is not supported in Vertex AI."); return t } function Da(i) { const t = {}, l = u(i, ["name"]); l != null && c(t, ["name"], l); const a = u(i, ["metadata", "displayName"]); a != null && c(t, ["displayName"], a); const r = u(i, ["metadata", "state"]); r != null && c(t, ["state"], hg(r)); const d = u(i, ["metadata", "createTime"]); d != null && c(t, ["createTime"], d); const m = u(i, ["metadata", "endTime"]); m != null && c(t, ["endTime"], m); const g = u(i, ["metadata", "updateTime"]); g != null && c(t, ["updateTime"], g); const v = u(i, ["metadata", "model"]); v != null && c(t, ["model"], v); const p = u(i, ["metadata", "output"]); return p != null && c(t, ["dest"], $S(mg(p))), t } function Cu(i) { const t = {}, l = u(i, ["name"]); l != null && c(t, ["name"], l); const a = u(i, ["displayName"]); a != null && c(t, ["displayName"], a); const r = u(i, ["state"]); r != null && c(t, ["state"], hg(r)); const d = u(i, ["error"]); d != null && c(t, ["error"], d); const m = u(i, ["createTime"]); m != null && c(t, ["createTime"], m); const g = u(i, ["startTime"]); g != null && c(t, ["startTime"], g); const v = u(i, ["endTime"]); v != null && c(t, ["endTime"], v); const p = u(i, ["updateTime"]); p != null && c(t, ["updateTime"], p); const x = u(i, ["model"]); x != null && c(t, ["model"], x); const T = u(i, ["inputConfig"]); T != null && c(t, ["src"], nT(T)); const _ = u(i, ["outputConfig"]); _ != null && c(t, ["dest"], eT(mg(_))); const A = u(i, ["completionStats"]); return A != null && c(t, ["completionStats"], A), t } function nT(i) { const t = {}, l = u(i, ["instancesFormat"]); l != null && c(t, ["format"], l); const a = u(i, ["gcsSource", "uris"]); a != null && c(t, ["gcsUri"], a); const r = u(i, ["bigquerySource", "inputUri"]); return r != null && c(t, ["bigqueryUri"], r), t } function iT(i, t) { const l = {}; if (u(t, ["format"]) !== void 0) throw new Error("format parameter is not supported in Gemini API."); if (u(t, ["gcsUri"]) !== void 0) throw new Error("gcsUri parameter is not supported in Gemini API."); if (u(t, ["bigqueryUri"]) !== void 0) throw new Error("bigqueryUri parameter is not supported in Gemini API."); const a = u(t, ["fileName"]); a != null && c(l, ["fileName"], a); const r = u(t, ["inlinedRequests"]); if (r != null) { let d = r; Array.isArray(d) && (d = d.map(m => kT(i, m))), c(l, ["requests", "requests"], d) } return l } function oT(i) { const t = {}, l = u(i, ["format"]); l != null && c(t, ["instancesFormat"], l); const a = u(i, ["gcsUri"]); a != null && c(t, ["gcsSource", "uris"], a); const r = u(i, ["bigqueryUri"]); if (r != null && c(t, ["bigquerySource", "inputUri"], r), u(i, ["fileName"]) !== void 0) throw new Error("fileName parameter is not supported in Vertex AI."); if (u(i, ["inlinedRequests"]) !== void 0) throw new Error("inlinedRequests parameter is not supported in Vertex AI."); return t } function lT(i) { const t = {}, l = u(i, ["data"]); if (l != null && c(t, ["data"], l), u(i, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const a = u(i, ["mimeType"]); return a != null && c(t, ["mimeType"], a), t } function aT(i, t) { const l = {}, a = u(t, ["name"]); return a != null && c(l, ["_url", "name"], ao(i, a)), l } function sT(i, t) { const l = {}, a = u(t, ["name"]); return a != null && c(l, ["_url", "name"], ao(i, a)), l } function rT(i) { const t = {}, l = u(i, ["content"]); l != null && c(t, ["content"], l); const a = u(i, ["citationMetadata"]); a != null && c(t, ["citationMetadata"], uT(a)); const r = u(i, ["tokenCount"]); r != null && c(t, ["tokenCount"], r); const d = u(i, ["finishReason"]); d != null && c(t, ["finishReason"], d); const m = u(i, ["avgLogprobs"]); m != null && c(t, ["avgLogprobs"], m); const g = u(i, ["groundingMetadata"]); g != null && c(t, ["groundingMetadata"], g); const v = u(i, ["index"]); v != null && c(t, ["index"], v); const p = u(i, ["logprobsResult"]); p != null && c(t, ["logprobsResult"], p); const x = u(i, ["safetyRatings"]); if (x != null) { let _ = x; Array.isArray(_) && (_ = _.map(A => A)), c(t, ["safetyRatings"], _) } const T = u(i, ["urlContextMetadata"]); return T != null && c(t, ["urlContextMetadata"], T), t } function uT(i) { const t = {}, l = u(i, ["citationSources"]); if (l != null) { let a = l; Array.isArray(a) && (a = a.map(r => r)), c(t, ["citations"], a) } return t } function pg(i) { const t = {}, l = u(i, ["parts"]); if (l != null) { let r = l; Array.isArray(r) && (r = r.map(d => PT(d))), c(t, ["parts"], r) } const a = u(i, ["role"]); return a != null && c(t, ["role"], a), t } function cT(i, t) { const l = {}, a = u(i, ["displayName"]); if (t !== void 0 && a != null && c(t, ["batch", "displayName"], a), u(i, ["dest"]) !== void 0) throw new Error("dest parameter is not supported in Gemini API."); return l } function dT(i, t) { const l = {}, a = u(i, ["displayName"]); t !== void 0 && a != null && c(t, ["displayName"], a); const r = u(i, ["dest"]); return t !== void 0 && r != null && c(t, ["outputConfig"], tT(ZS(r))), l } function yp(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["_url", "model"], Se(i, a)); const r = u(t, ["src"]); r != null && c(l, ["batch", "inputConfig"], iT(i, fg(i, r))); const d = u(t, ["config"]); return d != null && cT(d, l), l } function fT(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["model"], Se(i, a)); const r = u(t, ["src"]); r != null && c(l, ["inputConfig"], oT(fg(i, r))); const d = u(t, ["config"]); return d != null && dT(d, l), l } function mT(i, t) { const l = {}, a = u(i, ["displayName"]); return t !== void 0 && a != null && c(t, ["batch", "displayName"], a), l } function hT(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["_url", "model"], Se(i, a)); const r = u(t, ["src"]); r != null && c(l, ["batch", "inputConfig"], TT(i, r)); const d = u(t, ["config"]); return d != null && mT(d, l), l } function pT(i, t) { const l = {}, a = u(t, ["name"]); return a != null && c(l, ["_url", "name"], ao(i, a)), l } function gT(i, t) { const l = {}, a = u(t, ["name"]); return a != null && c(l, ["_url", "name"], ao(i, a)), l } function yT(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["name"]); a != null && c(t, ["name"], a); const r = u(i, ["done"]); r != null && c(t, ["done"], r); const d = u(i, ["error"]); return d != null && c(t, ["error"], d), t } function vT(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["name"]); a != null && c(t, ["name"], a); const r = u(i, ["done"]); r != null && c(t, ["done"], r); const d = u(i, ["error"]); return d != null && c(t, ["error"], d), t } function xT(i, t) { const l = {}, a = u(t, ["contents"]); if (a != null) { let d = Pu(i, a); Array.isArray(d) && (d = d.map(m => m)), c(l, ["requests[]", "request", "content"], d) } const r = u(t, ["config"]); return r != null && (c(l, ["_self"], ST(r, l)), gS(l, { "requests[].*": "requests[].request.*" })), l } function ST(i, t) { const l = {}, a = u(i, ["taskType"]); t !== void 0 && a != null && c(t, ["requests[]", "taskType"], a); const r = u(i, ["title"]); t !== void 0 && r != null && c(t, ["requests[]", "title"], r); const d = u(i, ["outputDimensionality"]); if (t !== void 0 && d != null && c(t, ["requests[]", "outputDimensionality"], d), u(i, ["mimeType"]) !== void 0) throw new Error("mimeType parameter is not supported in Gemini API."); if (u(i, ["autoTruncate"]) !== void 0) throw new Error("autoTruncate parameter is not supported in Gemini API."); return l } function TT(i, t) { const l = {}, a = u(t, ["fileName"]); a != null && c(l, ["file_name"], a); const r = u(t, ["inlinedRequests"]); return r != null && c(l, ["requests"], xT(i, r)), l } function _T(i) { const t = {}; if (u(i, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const l = u(i, ["fileUri"]); l != null && c(t, ["fileUri"], l); const a = u(i, ["mimeType"]); return a != null && c(t, ["mimeType"], a), t } function ET(i) { const t = {}, l = u(i, ["id"]); l != null && c(t, ["id"], l); const a = u(i, ["args"]); a != null && c(t, ["args"], a); const r = u(i, ["name"]); if (r != null && c(t, ["name"], r), u(i, ["partialArgs"]) !== void 0) throw new Error("partialArgs parameter is not supported in Gemini API."); if (u(i, ["willContinue"]) !== void 0) throw new Error("willContinue parameter is not supported in Gemini API."); return t } function AT(i) { const t = {}, l = u(i, ["allowedFunctionNames"]); l != null && c(t, ["allowedFunctionNames"], l); const a = u(i, ["mode"]); if (a != null && c(t, ["mode"], a), u(i, ["streamFunctionCallArguments"]) !== void 0) throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API."); return t } function CT(i, t, l) { const a = {}, r = u(t, ["systemInstruction"]); l !== void 0 && r != null && c(l, ["systemInstruction"], pg(ot(r))); const d = u(t, ["temperature"]); d != null && c(a, ["temperature"], d); const m = u(t, ["topP"]); m != null && c(a, ["topP"], m); const g = u(t, ["topK"]); g != null && c(a, ["topK"], g); const v = u(t, ["candidateCount"]); v != null && c(a, ["candidateCount"], v); const p = u(t, ["maxOutputTokens"]); p != null && c(a, ["maxOutputTokens"], p); const x = u(t, ["stopSequences"]); x != null && c(a, ["stopSequences"], x); const T = u(t, ["responseLogprobs"]); T != null && c(a, ["responseLogprobs"], T); const _ = u(t, ["logprobs"]); _ != null && c(a, ["logprobs"], _); const A = u(t, ["presencePenalty"]); A != null && c(a, ["presencePenalty"], A); const k = u(t, ["frequencyPenalty"]); k != null && c(a, ["frequencyPenalty"], k); const G = u(t, ["seed"]); G != null && c(a, ["seed"], G); const U = u(t, ["responseMimeType"]); U != null && c(a, ["responseMimeType"], U); const V = u(t, ["responseSchema"]); V != null && c(a, ["responseSchema"], Vu(V)); const W = u(t, ["responseJsonSchema"]); if (W != null && c(a, ["responseJsonSchema"], W), u(t, ["routingConfig"]) !== void 0) throw new Error("routingConfig parameter is not supported in Gemini API."); if (u(t, ["modelSelectionConfig"]) !== void 0) throw new Error("modelSelectionConfig parameter is not supported in Gemini API."); const B = u(t, ["safetySettings"]); if (l !== void 0 && B != null) { let _e = B; Array.isArray(_e) && (_e = _e.map(Oe => VT(Oe))), c(l, ["safetySettings"], _e) } const K = u(t, ["tools"]); if (l !== void 0 && K != null) { let _e = lo(K); Array.isArray(_e) && (_e = _e.map(Oe => OT(oo(Oe)))), c(l, ["tools"], _e) } const ee = u(t, ["toolConfig"]); if (l !== void 0 && ee != null && c(l, ["toolConfig"], BT(ee)), u(t, ["labels"]) !== void 0) throw new Error("labels parameter is not supported in Gemini API."); const te = u(t, ["cachedContent"]); l !== void 0 && te != null && c(l, ["cachedContent"], xn(i, te)); const F = u(t, ["responseModalities"]); F != null && c(a, ["responseModalities"], F); const ge = u(t, ["mediaResolution"]); ge != null && c(a, ["mediaResolution"], ge); const Z = u(t, ["speechConfig"]); if (Z != null && c(a, ["speechConfig"], Bu(Z)), u(t, ["audioTimestamp"]) !== void 0) throw new Error("audioTimestamp parameter is not supported in Gemini API."); const me = u(t, ["thinkingConfig"]); me != null && c(a, ["thinkingConfig"], me); const Ae = u(t, ["imageConfig"]); Ae != null && c(a, ["imageConfig"], IT(Ae)); const Le = u(t, ["enableEnhancedCivicAnswers"]); return Le != null && c(a, ["enableEnhancedCivicAnswers"], Le), a } function bT(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["candidates"]); if (a != null) { let v = a; Array.isArray(v) && (v = v.map(p => rT(p))), c(t, ["candidates"], v) } const r = u(i, ["modelVersion"]); r != null && c(t, ["modelVersion"], r); const d = u(i, ["promptFeedback"]); d != null && c(t, ["promptFeedback"], d); const m = u(i, ["responseId"]); m != null && c(t, ["responseId"], m); const g = u(i, ["usageMetadata"]); return g != null && c(t, ["usageMetadata"], g), t } function NT(i, t) { const l = {}, a = u(t, ["name"]); return a != null && c(l, ["_url", "name"], ao(i, a)), l } function wT(i, t) { const l = {}, a = u(t, ["name"]); return a != null && c(l, ["_url", "name"], ao(i, a)), l } function MT(i) { const t = {}; if (u(i, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API."); const l = u(i, ["enableWidget"]); return l != null && c(t, ["enableWidget"], l), t } function RT(i) { const t = {}; if (u(i, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API."); if (u(i, ["blockingConfidence"]) !== void 0) throw new Error("blockingConfidence parameter is not supported in Gemini API."); const l = u(i, ["timeRangeFilter"]); return l != null && c(t, ["timeRangeFilter"], l), t } function IT(i) { const t = {}, l = u(i, ["aspectRatio"]); l != null && c(t, ["aspectRatio"], l); const a = u(i, ["imageSize"]); if (a != null && c(t, ["imageSize"], a), u(i, ["personGeneration"]) !== void 0) throw new Error("personGeneration parameter is not supported in Gemini API."); if (u(i, ["outputMimeType"]) !== void 0) throw new Error("outputMimeType parameter is not supported in Gemini API."); if (u(i, ["outputCompressionQuality"]) !== void 0) throw new Error("outputCompressionQuality parameter is not supported in Gemini API."); return t } function kT(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["request", "model"], Se(i, a)); const r = u(t, ["contents"]); if (r != null) { let g = Ht(r); Array.isArray(g) && (g = g.map(v => pg(v))), c(l, ["request", "contents"], g) } const d = u(t, ["metadata"]); d != null && c(l, ["metadata"], d); const m = u(t, ["config"]); return m != null && c(l, ["request", "generationConfig"], CT(i, m, u(l, ["request"], {}))), l } function DT(i) { const t = {}, l = u(i, ["response"]); l != null && c(t, ["response"], bT(l)); const a = u(i, ["error"]); return a != null && c(t, ["error"], a), t } function UT(i, t) { const l = {}, a = u(i, ["pageSize"]); t !== void 0 && a != null && c(t, ["_query", "pageSize"], a); const r = u(i, ["pageToken"]); if (t !== void 0 && r != null && c(t, ["_query", "pageToken"], r), u(i, ["filter"]) !== void 0) throw new Error("filter parameter is not supported in Gemini API."); return l } function GT(i, t) { const l = {}, a = u(i, ["pageSize"]); t !== void 0 && a != null && c(t, ["_query", "pageSize"], a); const r = u(i, ["pageToken"]); t !== void 0 && r != null && c(t, ["_query", "pageToken"], r); const d = u(i, ["filter"]); return t !== void 0 && d != null && c(t, ["_query", "filter"], d), l } function LT(i) { const t = {}, l = u(i, ["config"]); return l != null && UT(l, t), t } function zT(i) { const t = {}, l = u(i, ["config"]); return l != null && GT(l, t), t } function qT(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["nextPageToken"]); a != null && c(t, ["nextPageToken"], a); const r = u(i, ["operations"]); if (r != null) { let d = r; Array.isArray(d) && (d = d.map(m => Da(m))), c(t, ["batchJobs"], d) } return t } function HT(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["nextPageToken"]); a != null && c(t, ["nextPageToken"], a); const r = u(i, ["batchPredictionJobs"]); if (r != null) { let d = r; Array.isArray(d) && (d = d.map(m => Cu(m))), c(t, ["batchJobs"], d) } return t } function PT(i) { const t = {}, l = u(i, ["mediaResolution"]); l != null && c(t, ["mediaResolution"], l); const a = u(i, ["codeExecutionResult"]); a != null && c(t, ["codeExecutionResult"], a); const r = u(i, ["executableCode"]); r != null && c(t, ["executableCode"], r); const d = u(i, ["fileData"]); d != null && c(t, ["fileData"], _T(d)); const m = u(i, ["functionCall"]); m != null && c(t, ["functionCall"], ET(m)); const g = u(i, ["functionResponse"]); g != null && c(t, ["functionResponse"], g); const v = u(i, ["inlineData"]); v != null && c(t, ["inlineData"], lT(v)); const p = u(i, ["text"]); p != null && c(t, ["text"], p); const x = u(i, ["thought"]); x != null && c(t, ["thought"], x); const T = u(i, ["thoughtSignature"]); T != null && c(t, ["thoughtSignature"], T); const _ = u(i, ["videoMetadata"]); return _ != null && c(t, ["videoMetadata"], _), t } function VT(i) { const t = {}, l = u(i, ["category"]); if (l != null && c(t, ["category"], l), u(i, ["method"]) !== void 0) throw new Error("method parameter is not supported in Gemini API."); const a = u(i, ["threshold"]); return a != null && c(t, ["threshold"], a), t } function BT(i) { const t = {}, l = u(i, ["retrievalConfig"]); l != null && c(t, ["retrievalConfig"], l); const a = u(i, ["functionCallingConfig"]); return a != null && c(t, ["functionCallingConfig"], AT(a)), t } function OT(i) { const t = {}; if (u(i, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API."); const l = u(i, ["computerUse"]); l != null && c(t, ["computerUse"], l); const a = u(i, ["fileSearch"]); a != null && c(t, ["fileSearch"], a); const r = u(i, ["codeExecution"]); if (r != null && c(t, ["codeExecution"], r), u(i, ["enterpriseWebSearch"]) !== void 0) throw new Error("enterpriseWebSearch parameter is not supported in Gemini API."); const d = u(i, ["functionDeclarations"]); if (d != null) { let x = d; Array.isArray(x) && (x = x.map(T => T)), c(t, ["functionDeclarations"], x) } const m = u(i, ["googleMaps"]); m != null && c(t, ["googleMaps"], MT(m)); const g = u(i, ["googleSearch"]); g != null && c(t, ["googleSearch"], RT(g)); const v = u(i, ["googleSearchRetrieval"]); v != null && c(t, ["googleSearchRetrieval"], v); const p = u(i, ["urlContext"]); return p != null && c(t, ["urlContext"], p), t }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */var yn; (function (i) { i.PAGED_ITEM_BATCH_JOBS = "batchJobs", i.PAGED_ITEM_MODELS = "models", i.PAGED_ITEM_TUNING_JOBS = "tuningJobs", i.PAGED_ITEM_FILES = "files", i.PAGED_ITEM_CACHED_CONTENTS = "cachedContents", i.PAGED_ITEM_FILE_SEARCH_STORES = "fileSearchStores", i.PAGED_ITEM_DOCUMENTS = "documents" })(yn || (yn = {})); class mi { constructor(t, l, a, r) { this.pageInternal = [], this.paramsInternal = {}, this.requestInternal = l, this.init(t, a, r) } init(t, l, a) { var r, d; this.nameInternal = t, this.pageInternal = l[this.nameInternal] || [], this.sdkHttpResponseInternal = l == null ? void 0 : l.sdkHttpResponse, this.idxInternal = 0; let m = { config: {} }; !a || Object.keys(a).length === 0 ? m = { config: {} } : typeof a == "object" ? m = Object.assign({}, a) : m = a, m.config && (m.config.pageToken = l.nextPageToken), this.paramsInternal = m, this.pageInternalSize = (d = (r = m.config) === null || r === void 0 ? void 0 : r.pageSize) !== null && d !== void 0 ? d : this.pageInternal.length } initNextPage(t) { this.init(this.nameInternal, t, this.paramsInternal) } get page() { return this.pageInternal } get name() { return this.nameInternal } get pageSize() { return this.pageInternalSize } get sdkHttpResponse() { return this.sdkHttpResponseInternal } get params() { return this.paramsInternal } get pageLength() { return this.pageInternal.length } getItem(t) { return this.pageInternal[t] } [Symbol.asyncIterator]() { return { next: async () => { if (this.idxInternal >= this.pageLength) if (this.hasNextPage()) await this.nextPage(); else return { value: void 0, done: !0 }; const t = this.getItem(this.idxInternal); return this.idxInternal += 1, { value: t, done: !1 } }, return: async () => ({ value: void 0, done: !0 }) } } async nextPage() { if (!this.hasNextPage()) throw new Error("No more pages to fetch."); const t = await this.requestInternal(this.params); return this.initNextPage(t), this.page } hasNextPage() { var t; return ((t = this.params.config) === null || t === void 0 ? void 0 : t.pageToken) !== void 0 } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class FT extends vn { constructor(t) { super(), this.apiClient = t, this.list = async (l = {}) => new mi(yn.PAGED_ITEM_BATCH_JOBS, a => this.listInternal(a), await this.listInternal(l), l), this.create = async l => (this.apiClient.isVertexAI() && (l.config = this.formatDestination(l.src, l.config)), this.createInternal(l)), this.createEmbeddings = async l => { if (console.warn("batches.createEmbeddings() is experimental and may change without notice."), this.apiClient.isVertexAI()) throw new Error("Vertex AI does not support batches.createEmbeddings."); return this.createEmbeddingsInternal(l) } } createInlinedGenerateContentRequest(t) { const l = yp(this.apiClient, t), a = l._url, r = J("{model}:batchGenerateContent", a), g = l.batch.inputConfig.requests, v = g.requests, p = []; for (const x of v) { const T = Object.assign({}, x); if (T.systemInstruction) { const _ = T.systemInstruction; delete T.systemInstruction; const A = T.request; A.systemInstruction = _, T.request = A } p.push(T) } return g.requests = p, delete l.config, delete l._url, delete l._query, { path: r, body: l } } getGcsUri(t) { if (typeof t == "string") return t.startsWith("gs://") ? t : void 0; if (!Array.isArray(t) && t.gcsUri && t.gcsUri.length > 0) return t.gcsUri[0] } getBigqueryUri(t) { if (typeof t == "string") return t.startsWith("bq://") ? t : void 0; if (!Array.isArray(t)) return t.bigqueryUri } formatDestination(t, l) { const a = l ? Object.assign({}, l) : {}, r = Date.now().toString(); if (a.displayName || (a.displayName = `genaiBatchJob_${r}`), a.dest === void 0) { const d = this.getGcsUri(t), m = this.getBigqueryUri(t); if (d) d.endsWith(".jsonl") ? a.dest = `${d.slice(0, -6)}/dest` : a.dest = `${d}_dest_${r}`; else if (m) a.dest = `${m}_dest_${r}`; else throw new Error("Unsupported source for Vertex AI: No GCS or BigQuery URI found.") } return a } async createInternal(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = fT(this.apiClient, t); return g = J("batchPredictionJobs", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json()), m.then(x => Cu(x)) } else { const p = yp(this.apiClient, t); return g = J("{model}:batchGenerateContent", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "POST", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json()), m.then(x => Da(x)) } } async createEmbeddingsInternal(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const g = hT(this.apiClient, t); return d = J("{model}:asyncBatchEmbedContent", g._url), m = g._query, delete g._url, delete g._query, r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(g), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(v => v.json()), r.then(v => Da(v)) } } async get(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = wT(this.apiClient, t); return g = J("batchPredictionJobs/{name}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "GET", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json()), m.then(x => Cu(x)) } else { const p = NT(this.apiClient, t); return g = J("batches/{name}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "GET", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json()), m.then(x => Da(x)) } } async cancel(t) { var l, a, r, d; let m = "", g = {}; if (this.apiClient.isVertexAI()) { const v = sT(this.apiClient, t); m = J("batchPredictionJobs/{name}:cancel", v._url), g = v._query, delete v._url, delete v._query, await this.apiClient.request({ path: m, queryParams: g, body: JSON.stringify(v), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }) } else { const v = aT(this.apiClient, t); m = J("batches/{name}:cancel", v._url), g = v._query, delete v._url, delete v._query, await this.apiClient.request({ path: m, queryParams: g, body: JSON.stringify(v), httpMethod: "POST", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }) } } async listInternal(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = zT(t); return g = J("batchPredictionJobs", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "GET", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = HT(x), _ = new mp; return Object.assign(_, T), _ }) } else { const p = LT(t); return g = J("batches", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "GET", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = qT(x), _ = new mp; return Object.assign(_, T), _ }) } } async delete(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = gT(this.apiClient, t); return g = J("batchPredictionJobs/{name}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "DELETE", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => vT(x)) } else { const p = pT(this.apiClient, t); return g = J("batches/{name}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "DELETE", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => yT(x)) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function YT(i) { const t = {}, l = u(i, ["data"]); if (l != null && c(t, ["data"], l), u(i, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const a = u(i, ["mimeType"]); return a != null && c(t, ["mimeType"], a), t } function vp(i) { const t = {}, l = u(i, ["parts"]); if (l != null) { let r = l; Array.isArray(r) && (r = r.map(d => h_(d))), c(t, ["parts"], r) } const a = u(i, ["role"]); return a != null && c(t, ["role"], a), t } function JT(i, t) { const l = {}, a = u(i, ["ttl"]); t !== void 0 && a != null && c(t, ["ttl"], a); const r = u(i, ["expireTime"]); t !== void 0 && r != null && c(t, ["expireTime"], r); const d = u(i, ["displayName"]); t !== void 0 && d != null && c(t, ["displayName"], d); const m = u(i, ["contents"]); if (t !== void 0 && m != null) { let x = Ht(m); Array.isArray(x) && (x = x.map(T => vp(T))), c(t, ["contents"], x) } const g = u(i, ["systemInstruction"]); t !== void 0 && g != null && c(t, ["systemInstruction"], vp(ot(g))); const v = u(i, ["tools"]); if (t !== void 0 && v != null) { let x = v; Array.isArray(x) && (x = x.map(T => g_(T))), c(t, ["tools"], x) } const p = u(i, ["toolConfig"]); if (t !== void 0 && p != null && c(t, ["toolConfig"], p_(p)), u(i, ["kmsKeyName"]) !== void 0) throw new Error("kmsKeyName parameter is not supported in Gemini API."); return l } function WT(i, t) { const l = {}, a = u(i, ["ttl"]); t !== void 0 && a != null && c(t, ["ttl"], a); const r = u(i, ["expireTime"]); t !== void 0 && r != null && c(t, ["expireTime"], r); const d = u(i, ["displayName"]); t !== void 0 && d != null && c(t, ["displayName"], d); const m = u(i, ["contents"]); if (t !== void 0 && m != null) { let T = Ht(m); Array.isArray(T) && (T = T.map(_ => _)), c(t, ["contents"], T) } const g = u(i, ["systemInstruction"]); t !== void 0 && g != null && c(t, ["systemInstruction"], ot(g)); const v = u(i, ["tools"]); if (t !== void 0 && v != null) { let T = v; Array.isArray(T) && (T = T.map(_ => y_(_))), c(t, ["tools"], T) } const p = u(i, ["toolConfig"]); t !== void 0 && p != null && c(t, ["toolConfig"], p); const x = u(i, ["kmsKeyName"]); return t !== void 0 && x != null && c(t, ["encryption_spec", "kmsKeyName"], x), l } function KT(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["model"], ig(i, a)); const r = u(t, ["config"]); return r != null && JT(r, l), l } function XT(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["model"], ig(i, a)); const r = u(t, ["config"]); return r != null && WT(r, l), l } function QT(i, t) { const l = {}, a = u(t, ["name"]); return a != null && c(l, ["_url", "name"], xn(i, a)), l } function jT(i, t) { const l = {}, a = u(t, ["name"]); return a != null && c(l, ["_url", "name"], xn(i, a)), l } function ZT(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); return l != null && c(t, ["sdkHttpResponse"], l), t } function $T(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); return l != null && c(t, ["sdkHttpResponse"], l), t } function e_(i) { const t = {}; if (u(i, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const l = u(i, ["fileUri"]); l != null && c(t, ["fileUri"], l); const a = u(i, ["mimeType"]); return a != null && c(t, ["mimeType"], a), t } function t_(i) { const t = {}, l = u(i, ["id"]); l != null && c(t, ["id"], l); const a = u(i, ["args"]); a != null && c(t, ["args"], a); const r = u(i, ["name"]); if (r != null && c(t, ["name"], r), u(i, ["partialArgs"]) !== void 0) throw new Error("partialArgs parameter is not supported in Gemini API."); if (u(i, ["willContinue"]) !== void 0) throw new Error("willContinue parameter is not supported in Gemini API."); return t } function n_(i) { const t = {}, l = u(i, ["allowedFunctionNames"]); l != null && c(t, ["allowedFunctionNames"], l); const a = u(i, ["mode"]); if (a != null && c(t, ["mode"], a), u(i, ["streamFunctionCallArguments"]) !== void 0) throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API."); return t } function i_(i) { const t = {}, l = u(i, ["description"]); l != null && c(t, ["description"], l); const a = u(i, ["name"]); a != null && c(t, ["name"], a); const r = u(i, ["parameters"]); r != null && c(t, ["parameters"], r); const d = u(i, ["parametersJsonSchema"]); d != null && c(t, ["parametersJsonSchema"], d); const m = u(i, ["response"]); m != null && c(t, ["response"], m); const g = u(i, ["responseJsonSchema"]); if (g != null && c(t, ["responseJsonSchema"], g), u(i, ["behavior"]) !== void 0) throw new Error("behavior parameter is not supported in Vertex AI."); return t } function o_(i, t) { const l = {}, a = u(t, ["name"]); return a != null && c(l, ["_url", "name"], xn(i, a)), l } function l_(i, t) { const l = {}, a = u(t, ["name"]); return a != null && c(l, ["_url", "name"], xn(i, a)), l } function a_(i) { const t = {}; if (u(i, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API."); const l = u(i, ["enableWidget"]); return l != null && c(t, ["enableWidget"], l), t } function s_(i) { const t = {}; if (u(i, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API."); if (u(i, ["blockingConfidence"]) !== void 0) throw new Error("blockingConfidence parameter is not supported in Gemini API."); const l = u(i, ["timeRangeFilter"]); return l != null && c(t, ["timeRangeFilter"], l), t } function r_(i, t) { const l = {}, a = u(i, ["pageSize"]); t !== void 0 && a != null && c(t, ["_query", "pageSize"], a); const r = u(i, ["pageToken"]); return t !== void 0 && r != null && c(t, ["_query", "pageToken"], r), l } function u_(i, t) { const l = {}, a = u(i, ["pageSize"]); t !== void 0 && a != null && c(t, ["_query", "pageSize"], a); const r = u(i, ["pageToken"]); return t !== void 0 && r != null && c(t, ["_query", "pageToken"], r), l } function c_(i) { const t = {}, l = u(i, ["config"]); return l != null && r_(l, t), t } function d_(i) { const t = {}, l = u(i, ["config"]); return l != null && u_(l, t), t } function f_(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["nextPageToken"]); a != null && c(t, ["nextPageToken"], a); const r = u(i, ["cachedContents"]); if (r != null) { let d = r; Array.isArray(d) && (d = d.map(m => m)), c(t, ["cachedContents"], d) } return t } function m_(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["nextPageToken"]); a != null && c(t, ["nextPageToken"], a); const r = u(i, ["cachedContents"]); if (r != null) { let d = r; Array.isArray(d) && (d = d.map(m => m)), c(t, ["cachedContents"], d) } return t } function h_(i) { const t = {}, l = u(i, ["mediaResolution"]); l != null && c(t, ["mediaResolution"], l); const a = u(i, ["codeExecutionResult"]); a != null && c(t, ["codeExecutionResult"], a); const r = u(i, ["executableCode"]); r != null && c(t, ["executableCode"], r); const d = u(i, ["fileData"]); d != null && c(t, ["fileData"], e_(d)); const m = u(i, ["functionCall"]); m != null && c(t, ["functionCall"], t_(m)); const g = u(i, ["functionResponse"]); g != null && c(t, ["functionResponse"], g); const v = u(i, ["inlineData"]); v != null && c(t, ["inlineData"], YT(v)); const p = u(i, ["text"]); p != null && c(t, ["text"], p); const x = u(i, ["thought"]); x != null && c(t, ["thought"], x); const T = u(i, ["thoughtSignature"]); T != null && c(t, ["thoughtSignature"], T); const _ = u(i, ["videoMetadata"]); return _ != null && c(t, ["videoMetadata"], _), t } function p_(i) { const t = {}, l = u(i, ["retrievalConfig"]); l != null && c(t, ["retrievalConfig"], l); const a = u(i, ["functionCallingConfig"]); return a != null && c(t, ["functionCallingConfig"], n_(a)), t } function g_(i) { const t = {}; if (u(i, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API."); const l = u(i, ["computerUse"]); l != null && c(t, ["computerUse"], l); const a = u(i, ["fileSearch"]); a != null && c(t, ["fileSearch"], a); const r = u(i, ["codeExecution"]); if (r != null && c(t, ["codeExecution"], r), u(i, ["enterpriseWebSearch"]) !== void 0) throw new Error("enterpriseWebSearch parameter is not supported in Gemini API."); const d = u(i, ["functionDeclarations"]); if (d != null) { let x = d; Array.isArray(x) && (x = x.map(T => T)), c(t, ["functionDeclarations"], x) } const m = u(i, ["googleMaps"]); m != null && c(t, ["googleMaps"], a_(m)); const g = u(i, ["googleSearch"]); g != null && c(t, ["googleSearch"], s_(g)); const v = u(i, ["googleSearchRetrieval"]); v != null && c(t, ["googleSearchRetrieval"], v); const p = u(i, ["urlContext"]); return p != null && c(t, ["urlContext"], p), t } function y_(i) { const t = {}, l = u(i, ["retrieval"]); l != null && c(t, ["retrieval"], l); const a = u(i, ["computerUse"]); if (a != null && c(t, ["computerUse"], a), u(i, ["fileSearch"]) !== void 0) throw new Error("fileSearch parameter is not supported in Vertex AI."); const r = u(i, ["codeExecution"]); r != null && c(t, ["codeExecution"], r); const d = u(i, ["enterpriseWebSearch"]); d != null && c(t, ["enterpriseWebSearch"], d); const m = u(i, ["functionDeclarations"]); if (m != null) { let T = m; Array.isArray(T) && (T = T.map(_ => i_(_))), c(t, ["functionDeclarations"], T) } const g = u(i, ["googleMaps"]); g != null && c(t, ["googleMaps"], g); const v = u(i, ["googleSearch"]); v != null && c(t, ["googleSearch"], v); const p = u(i, ["googleSearchRetrieval"]); p != null && c(t, ["googleSearchRetrieval"], p); const x = u(i, ["urlContext"]); return x != null && c(t, ["urlContext"], x), t } function v_(i, t) { const l = {}, a = u(i, ["ttl"]); t !== void 0 && a != null && c(t, ["ttl"], a); const r = u(i, ["expireTime"]); return t !== void 0 && r != null && c(t, ["expireTime"], r), l } function x_(i, t) { const l = {}, a = u(i, ["ttl"]); t !== void 0 && a != null && c(t, ["ttl"], a); const r = u(i, ["expireTime"]); return t !== void 0 && r != null && c(t, ["expireTime"], r), l } function S_(i, t) { const l = {}, a = u(t, ["name"]); a != null && c(l, ["_url", "name"], xn(i, a)); const r = u(t, ["config"]); return r != null && v_(r, l), l } function T_(i, t) { const l = {}, a = u(t, ["name"]); a != null && c(l, ["_url", "name"], xn(i, a)); const r = u(t, ["config"]); return r != null && x_(r, l), l }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class __ extends vn { constructor(t) { super(), this.apiClient = t, this.list = async (l = {}) => new mi(yn.PAGED_ITEM_CACHED_CONTENTS, a => this.listInternal(a), await this.listInternal(l), l) } async create(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = XT(this.apiClient, t); return g = J("cachedContents", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json()), m.then(x => x) } else { const p = KT(this.apiClient, t); return g = J("cachedContents", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "POST", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json()), m.then(x => x) } } async get(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = l_(this.apiClient, t); return g = J("{name}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "GET", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json()), m.then(x => x) } else { const p = o_(this.apiClient, t); return g = J("{name}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "GET", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json()), m.then(x => x) } } async delete(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = jT(this.apiClient, t); return g = J("{name}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "DELETE", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = $T(x), _ = new dp; return Object.assign(_, T), _ }) } else { const p = QT(this.apiClient, t); return g = J("{name}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "DELETE", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = ZT(x), _ = new dp; return Object.assign(_, T), _ }) } } async update(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = T_(this.apiClient, t); return g = J("{name}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "PATCH", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json()), m.then(x => x) } else { const p = S_(this.apiClient, t); return g = J("{name}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "PATCH", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json()), m.then(x => x) } } async listInternal(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = d_(t); return g = J("cachedContents", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "GET", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = m_(x), _ = new fp; return Object.assign(_, T), _ }) } else { const p = c_(t); return g = J("cachedContents", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "GET", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = f_(x), _ = new fp; return Object.assign(_, T), _ }) } } } function qa(i, t) { var l = {}; for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && t.indexOf(a) < 0 && (l[a] = i[a]); if (i != null && typeof Object.getOwnPropertySymbols == "function") for (var r = 0, a = Object.getOwnPropertySymbols(i); r < a.length; r++)t.indexOf(a[r]) < 0 && Object.prototype.propertyIsEnumerable.call(i, a[r]) && (l[a[r]] = i[a[r]]); return l } function xp(i) { var t = typeof Symbol == "function" && Symbol.iterator, l = t && i[t], a = 0; if (l) return l.call(i); if (i && typeof i.length == "number") return { next: function () { return i && a >= i.length && (i = void 0), { value: i && i[a++], done: !i } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") } function le(i) { return this instanceof le ? (this.v = i, this) : new le(i) } function Yt(i, t, l) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var a = l.apply(i, t || []), r, d = []; return r = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), g("next"), g("throw"), g("return", m), r[Symbol.asyncIterator] = function () { return this }, r; function m(A) { return function (k) { return Promise.resolve(k).then(A, T) } } function g(A, k) { a[A] && (r[A] = function (G) { return new Promise(function (U, V) { d.push([A, G, U, V]) > 1 || v(A, G) }) }, k && (r[A] = k(r[A]))) } function v(A, k) { try { p(a[A](k)) } catch (G) { _(d[0][3], G) } } function p(A) { A.value instanceof le ? Promise.resolve(A.value.v).then(x, T) : _(d[0][2], A) } function x(A) { v("next", A) } function T(A) { v("throw", A) } function _(A, k) { A(k), d.shift(), d.length && v(d[0][0], d[0][1]) } } function Jt(i) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var t = i[Symbol.asyncIterator], l; return t ? t.call(i) : (i = typeof xp == "function" ? xp(i) : i[Symbol.iterator](), l = {}, a("next"), a("throw"), a("return"), l[Symbol.asyncIterator] = function () { return this }, l); function a(d) { l[d] = i[d] && function (m) { return new Promise(function (g, v) { m = i[d](m), r(g, v, m.done, m.value) }) } } function r(d, m, g, v) { Promise.resolve(v).then(function (p) { d({ value: p, done: g }) }, m) } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function E_(i) { var t; if (i.candidates == null || i.candidates.length === 0) return !1; const l = (t = i.candidates[0]) === null || t === void 0 ? void 0 : t.content; return l === void 0 ? !1 : gg(l) } function gg(i) { if (i.parts === void 0 || i.parts.length === 0) return !1; for (const t of i.parts) if (t === void 0 || Object.keys(t).length === 0) return !1; return !0 } function A_(i) { if (i.length !== 0) { for (const t of i) if (t.role !== "user" && t.role !== "model") throw new Error(`Role must be user or model, but got ${t.role}.`) } } function Sp(i) { if (i === void 0 || i.length === 0) return []; const t = [], l = i.length; let a = 0; for (; a < l;)if (i[a].role === "user") t.push(i[a]), a++; else { const r = []; let d = !0; for (; a < l && i[a].role === "model";)r.push(i[a]), d && !gg(i[a]) && (d = !1), a++; d ? t.push(...r) : t.pop() } return t } class C_ { constructor(t, l) { this.modelsModule = t, this.apiClient = l } create(t) { return new b_(this.apiClient, this.modelsModule, t.model, t.config, structuredClone(t.history)) } } class b_ { constructor(t, l, a, r = {}, d = []) { this.apiClient = t, this.modelsModule = l, this.model = a, this.config = r, this.history = d, this.sendPromise = Promise.resolve(), A_(d) } async sendMessage(t) { var l; await this.sendPromise; const a = ot(t.message), r = this.modelsModule.generateContent({ model: this.model, contents: this.getHistory(!0).concat(a), config: (l = t.config) !== null && l !== void 0 ? l : this.config }); return this.sendPromise = (async () => { var d, m, g; const v = await r, p = (m = (d = v.candidates) === null || d === void 0 ? void 0 : d[0]) === null || m === void 0 ? void 0 : m.content, x = v.automaticFunctionCallingHistory, T = this.getHistory(!0).length; let _ = []; x != null && (_ = (g = x.slice(T)) !== null && g !== void 0 ? g : []); const A = p ? [p] : []; this.recordHistory(a, A, _) })(), await this.sendPromise.catch(() => { this.sendPromise = Promise.resolve() }), r } async sendMessageStream(t) { var l; await this.sendPromise; const a = ot(t.message), r = this.modelsModule.generateContentStream({ model: this.model, contents: this.getHistory(!0).concat(a), config: (l = t.config) !== null && l !== void 0 ? l : this.config }); this.sendPromise = r.then(() => { }).catch(() => { }); const d = await r; return this.processStreamResponse(d, a) } getHistory(t = !1) { const l = t ? Sp(this.history) : this.history; return structuredClone(l) } processStreamResponse(t, l) { return Yt(this, arguments, function* () { var r, d, m, g, v, p; const x = []; try { for (var T = !0, _ = Jt(t), A; A = yield le(_.next()), r = A.done, !r; T = !0) { g = A.value, T = !1; const k = g; if (E_(k)) { const G = (p = (v = k.candidates) === null || v === void 0 ? void 0 : v[0]) === null || p === void 0 ? void 0 : p.content; G !== void 0 && x.push(G) } yield yield le(k) } } catch (k) { d = { error: k } } finally { try { !T && !r && (m = _.return) && (yield le(m.call(_))) } finally { if (d) throw d.error } } this.recordHistory(l, x) }) } recordHistory(t, l, a) { let r = []; l.length > 0 && l.every(d => d.role !== void 0) ? r = l : r.push({ role: "model", parts: [] }), a && a.length > 0 ? this.history.push(...Sp(a)) : this.history.push(t), this.history.push(...r) } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Va extends Error { constructor(t) { super(t.message), this.name = "ApiError", this.status = t.status, Object.setPrototypeOf(this, Va.prototype) } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function N_(i) { const t = {}, l = u(i, ["file"]); return l != null && c(t, ["file"], l), t } function w_(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); return l != null && c(t, ["sdkHttpResponse"], l), t } function M_(i) { const t = {}, l = u(i, ["name"]); return l != null && c(t, ["_url", "file"], ug(l)), t } function R_(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); return l != null && c(t, ["sdkHttpResponse"], l), t } function I_(i) { const t = {}, l = u(i, ["name"]); return l != null && c(t, ["_url", "file"], ug(l)), t } function k_(i, t) { const l = {}, a = u(i, ["pageSize"]); t !== void 0 && a != null && c(t, ["_query", "pageSize"], a); const r = u(i, ["pageToken"]); return t !== void 0 && r != null && c(t, ["_query", "pageToken"], r), l } function D_(i) { const t = {}, l = u(i, ["config"]); return l != null && k_(l, t), t } function U_(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["nextPageToken"]); a != null && c(t, ["nextPageToken"], a); const r = u(i, ["files"]); if (r != null) { let d = r; Array.isArray(d) && (d = d.map(m => m)), c(t, ["files"], d) } return t }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class G_ extends vn { constructor(t) { super(), this.apiClient = t, this.list = async (l = {}) => new mi(yn.PAGED_ITEM_FILES, a => this.listInternal(a), await this.listInternal(l), l) } async upload(t) { if (this.apiClient.isVertexAI()) throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket."); return this.apiClient.uploadFile(t.file, t.config).then(l => l) } async download(t) { await this.apiClient.downloadFile(t) } async listInternal(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const g = D_(t); return d = J("files", g._url), m = g._query, delete g._url, delete g._query, r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(g), httpMethod: "GET", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(v => v.json().then(p => { const x = p; return x.sdkHttpResponse = { headers: v.headers }, x })), r.then(v => { const p = U_(v), x = new HS; return Object.assign(x, p), x }) } } async createInternal(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const g = N_(t); return d = J("upload/v1beta/files", g._url), m = g._query, delete g._url, delete g._query, r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(g), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(v => v.json()), r.then(v => { const p = w_(v), x = new PS; return Object.assign(x, p), x }) } } async get(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const g = I_(t); return d = J("files/{file}", g._url), m = g._query, delete g._url, delete g._query, r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(g), httpMethod: "GET", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(v => v.json()), r.then(v => v) } } async delete(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const g = M_(t); return d = J("files/{file}", g._url), m = g._query, delete g._url, delete g._query, r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(g), httpMethod: "DELETE", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(v => v.json().then(p => { const x = p; return x.sdkHttpResponse = { headers: v.headers }, x })), r.then(v => { const p = R_(v), x = new VS; return Object.assign(x, p), x }) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Ua(i) { const t = {}, l = u(i, ["data"]); if (l != null && c(t, ["data"], l), u(i, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const a = u(i, ["mimeType"]); return a != null && c(t, ["mimeType"], a), t } function L_(i) { const t = {}, l = u(i, ["parts"]); if (l != null) { let r = l; Array.isArray(r) && (r = r.map(d => Z_(d))), c(t, ["parts"], r) } const a = u(i, ["role"]); return a != null && c(t, ["role"], a), t } function z_(i) { const t = {}; if (u(i, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const l = u(i, ["fileUri"]); l != null && c(t, ["fileUri"], l); const a = u(i, ["mimeType"]); return a != null && c(t, ["mimeType"], a), t } function q_(i) { const t = {}, l = u(i, ["id"]); l != null && c(t, ["id"], l); const a = u(i, ["args"]); a != null && c(t, ["args"], a); const r = u(i, ["name"]); if (r != null && c(t, ["name"], r), u(i, ["partialArgs"]) !== void 0) throw new Error("partialArgs parameter is not supported in Gemini API."); if (u(i, ["willContinue"]) !== void 0) throw new Error("willContinue parameter is not supported in Gemini API."); return t } function H_(i) { const t = {}, l = u(i, ["description"]); l != null && c(t, ["description"], l); const a = u(i, ["name"]); a != null && c(t, ["name"], a); const r = u(i, ["parameters"]); r != null && c(t, ["parameters"], r); const d = u(i, ["parametersJsonSchema"]); d != null && c(t, ["parametersJsonSchema"], d); const m = u(i, ["response"]); m != null && c(t, ["response"], m); const g = u(i, ["responseJsonSchema"]); if (g != null && c(t, ["responseJsonSchema"], g), u(i, ["behavior"]) !== void 0) throw new Error("behavior parameter is not supported in Vertex AI."); return t } function P_(i) { const t = {}, l = u(i, ["modelSelectionConfig"]); l != null && c(t, ["modelConfig"], l); const a = u(i, ["responseJsonSchema"]); a != null && c(t, ["responseJsonSchema"], a); const r = u(i, ["audioTimestamp"]); r != null && c(t, ["audioTimestamp"], r); const d = u(i, ["candidateCount"]); d != null && c(t, ["candidateCount"], d); const m = u(i, ["enableAffectiveDialog"]); m != null && c(t, ["enableAffectiveDialog"], m); const g = u(i, ["frequencyPenalty"]); g != null && c(t, ["frequencyPenalty"], g); const v = u(i, ["logprobs"]); v != null && c(t, ["logprobs"], v); const p = u(i, ["maxOutputTokens"]); p != null && c(t, ["maxOutputTokens"], p); const x = u(i, ["mediaResolution"]); x != null && c(t, ["mediaResolution"], x); const T = u(i, ["presencePenalty"]); T != null && c(t, ["presencePenalty"], T); const _ = u(i, ["responseLogprobs"]); _ != null && c(t, ["responseLogprobs"], _); const A = u(i, ["responseMimeType"]); A != null && c(t, ["responseMimeType"], A); const k = u(i, ["responseModalities"]); k != null && c(t, ["responseModalities"], k); const G = u(i, ["responseSchema"]); G != null && c(t, ["responseSchema"], G); const U = u(i, ["routingConfig"]); U != null && c(t, ["routingConfig"], U); const V = u(i, ["seed"]); V != null && c(t, ["seed"], V); const W = u(i, ["speechConfig"]); W != null && c(t, ["speechConfig"], W); const B = u(i, ["stopSequences"]); B != null && c(t, ["stopSequences"], B); const K = u(i, ["temperature"]); K != null && c(t, ["temperature"], K); const ee = u(i, ["thinkingConfig"]); ee != null && c(t, ["thinkingConfig"], ee); const te = u(i, ["topK"]); te != null && c(t, ["topK"], te); const F = u(i, ["topP"]); if (F != null && c(t, ["topP"], F), u(i, ["enableEnhancedCivicAnswers"]) !== void 0) throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI."); return t } function V_(i) { const t = {}; if (u(i, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API."); const l = u(i, ["enableWidget"]); return l != null && c(t, ["enableWidget"], l), t } function B_(i) { const t = {}; if (u(i, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API."); if (u(i, ["blockingConfidence"]) !== void 0) throw new Error("blockingConfidence parameter is not supported in Gemini API."); const l = u(i, ["timeRangeFilter"]); return l != null && c(t, ["timeRangeFilter"], l), t } function O_(i, t) { const l = {}, a = u(i, ["generationConfig"]); t !== void 0 && a != null && c(t, ["setup", "generationConfig"], a); const r = u(i, ["responseModalities"]); t !== void 0 && r != null && c(t, ["setup", "generationConfig", "responseModalities"], r); const d = u(i, ["temperature"]); t !== void 0 && d != null && c(t, ["setup", "generationConfig", "temperature"], d); const m = u(i, ["topP"]); t !== void 0 && m != null && c(t, ["setup", "generationConfig", "topP"], m); const g = u(i, ["topK"]); t !== void 0 && g != null && c(t, ["setup", "generationConfig", "topK"], g); const v = u(i, ["maxOutputTokens"]); t !== void 0 && v != null && c(t, ["setup", "generationConfig", "maxOutputTokens"], v); const p = u(i, ["mediaResolution"]); t !== void 0 && p != null && c(t, ["setup", "generationConfig", "mediaResolution"], p); const x = u(i, ["seed"]); t !== void 0 && x != null && c(t, ["setup", "generationConfig", "seed"], x); const T = u(i, ["speechConfig"]); t !== void 0 && T != null && c(t, ["setup", "generationConfig", "speechConfig"], Ou(T)); const _ = u(i, ["thinkingConfig"]); t !== void 0 && _ != null && c(t, ["setup", "generationConfig", "thinkingConfig"], _); const A = u(i, ["enableAffectiveDialog"]); t !== void 0 && A != null && c(t, ["setup", "generationConfig", "enableAffectiveDialog"], A); const k = u(i, ["systemInstruction"]); t !== void 0 && k != null && c(t, ["setup", "systemInstruction"], L_(ot(k))); const G = u(i, ["tools"]); if (t !== void 0 && G != null) { let te = lo(G); Array.isArray(te) && (te = te.map(F => eE(oo(F)))), c(t, ["setup", "tools"], te) } const U = u(i, ["sessionResumption"]); t !== void 0 && U != null && c(t, ["setup", "sessionResumption"], $_(U)); const V = u(i, ["inputAudioTranscription"]); t !== void 0 && V != null && c(t, ["setup", "inputAudioTranscription"], V); const W = u(i, ["outputAudioTranscription"]); t !== void 0 && W != null && c(t, ["setup", "outputAudioTranscription"], W); const B = u(i, ["realtimeInputConfig"]); t !== void 0 && B != null && c(t, ["setup", "realtimeInputConfig"], B); const K = u(i, ["contextWindowCompression"]); t !== void 0 && K != null && c(t, ["setup", "contextWindowCompression"], K); const ee = u(i, ["proactivity"]); if (t !== void 0 && ee != null && c(t, ["setup", "proactivity"], ee), u(i, ["explicitVadSignal"]) !== void 0) throw new Error("explicitVadSignal parameter is not supported in Gemini API."); return l } function F_(i, t) { const l = {}, a = u(i, ["generationConfig"]); t !== void 0 && a != null && c(t, ["setup", "generationConfig"], P_(a)); const r = u(i, ["responseModalities"]); t !== void 0 && r != null && c(t, ["setup", "generationConfig", "responseModalities"], r); const d = u(i, ["temperature"]); t !== void 0 && d != null && c(t, ["setup", "generationConfig", "temperature"], d); const m = u(i, ["topP"]); t !== void 0 && m != null && c(t, ["setup", "generationConfig", "topP"], m); const g = u(i, ["topK"]); t !== void 0 && g != null && c(t, ["setup", "generationConfig", "topK"], g); const v = u(i, ["maxOutputTokens"]); t !== void 0 && v != null && c(t, ["setup", "generationConfig", "maxOutputTokens"], v); const p = u(i, ["mediaResolution"]); t !== void 0 && p != null && c(t, ["setup", "generationConfig", "mediaResolution"], p); const x = u(i, ["seed"]); t !== void 0 && x != null && c(t, ["setup", "generationConfig", "seed"], x); const T = u(i, ["speechConfig"]); t !== void 0 && T != null && c(t, ["setup", "generationConfig", "speechConfig"], Ou(T)); const _ = u(i, ["thinkingConfig"]); t !== void 0 && _ != null && c(t, ["setup", "generationConfig", "thinkingConfig"], _); const A = u(i, ["enableAffectiveDialog"]); t !== void 0 && A != null && c(t, ["setup", "generationConfig", "enableAffectiveDialog"], A); const k = u(i, ["systemInstruction"]); t !== void 0 && k != null && c(t, ["setup", "systemInstruction"], ot(k)); const G = u(i, ["tools"]); if (t !== void 0 && G != null) { let F = lo(G); Array.isArray(F) && (F = F.map(ge => tE(oo(ge)))), c(t, ["setup", "tools"], F) } const U = u(i, ["sessionResumption"]); t !== void 0 && U != null && c(t, ["setup", "sessionResumption"], U); const V = u(i, ["inputAudioTranscription"]); t !== void 0 && V != null && c(t, ["setup", "inputAudioTranscription"], V); const W = u(i, ["outputAudioTranscription"]); t !== void 0 && W != null && c(t, ["setup", "outputAudioTranscription"], W); const B = u(i, ["realtimeInputConfig"]); t !== void 0 && B != null && c(t, ["setup", "realtimeInputConfig"], B); const K = u(i, ["contextWindowCompression"]); t !== void 0 && K != null && c(t, ["setup", "contextWindowCompression"], K); const ee = u(i, ["proactivity"]); t !== void 0 && ee != null && c(t, ["setup", "proactivity"], ee); const te = u(i, ["explicitVadSignal"]); return t !== void 0 && te != null && c(t, ["setup", "explicitVadSignal"], te), l } function Y_(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["setup", "model"], Se(i, a)); const r = u(t, ["config"]); return r != null && c(l, ["config"], O_(r, l)), l } function J_(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["setup", "model"], Se(i, a)); const r = u(t, ["config"]); return r != null && c(l, ["config"], F_(r, l)), l } function W_(i) { const t = {}, l = u(i, ["musicGenerationConfig"]); return l != null && c(t, ["musicGenerationConfig"], l), t } function K_(i) { const t = {}, l = u(i, ["weightedPrompts"]); if (l != null) { let a = l; Array.isArray(a) && (a = a.map(r => r)), c(t, ["weightedPrompts"], a) } return t } function X_(i) { const t = {}, l = u(i, ["media"]); if (l != null) { let p = og(l); Array.isArray(p) && (p = p.map(x => Ua(x))), c(t, ["mediaChunks"], p) } const a = u(i, ["audio"]); a != null && c(t, ["audio"], Ua(ag(a))); const r = u(i, ["audioStreamEnd"]); r != null && c(t, ["audioStreamEnd"], r); const d = u(i, ["video"]); d != null && c(t, ["video"], Ua(lg(d))); const m = u(i, ["text"]); m != null && c(t, ["text"], m); const g = u(i, ["activityStart"]); g != null && c(t, ["activityStart"], g); const v = u(i, ["activityEnd"]); return v != null && c(t, ["activityEnd"], v), t } function Q_(i) { const t = {}, l = u(i, ["media"]); if (l != null) { let p = og(l); Array.isArray(p) && (p = p.map(x => x)), c(t, ["mediaChunks"], p) } const a = u(i, ["audio"]); a != null && c(t, ["audio"], ag(a)); const r = u(i, ["audioStreamEnd"]); r != null && c(t, ["audioStreamEnd"], r); const d = u(i, ["video"]); d != null && c(t, ["video"], lg(d)); const m = u(i, ["text"]); m != null && c(t, ["text"], m); const g = u(i, ["activityStart"]); g != null && c(t, ["activityStart"], g); const v = u(i, ["activityEnd"]); return v != null && c(t, ["activityEnd"], v), t } function j_(i) { const t = {}, l = u(i, ["setupComplete"]); l != null && c(t, ["setupComplete"], l); const a = u(i, ["serverContent"]); a != null && c(t, ["serverContent"], a); const r = u(i, ["toolCall"]); r != null && c(t, ["toolCall"], r); const d = u(i, ["toolCallCancellation"]); d != null && c(t, ["toolCallCancellation"], d); const m = u(i, ["usageMetadata"]); m != null && c(t, ["usageMetadata"], nE(m)); const g = u(i, ["goAway"]); g != null && c(t, ["goAway"], g); const v = u(i, ["sessionResumptionUpdate"]); v != null && c(t, ["sessionResumptionUpdate"], v); const p = u(i, ["voiceActivityDetectionSignal"]); return p != null && c(t, ["voiceActivityDetectionSignal"], p), t } function Z_(i) { const t = {}, l = u(i, ["mediaResolution"]); l != null && c(t, ["mediaResolution"], l); const a = u(i, ["codeExecutionResult"]); a != null && c(t, ["codeExecutionResult"], a); const r = u(i, ["executableCode"]); r != null && c(t, ["executableCode"], r); const d = u(i, ["fileData"]); d != null && c(t, ["fileData"], z_(d)); const m = u(i, ["functionCall"]); m != null && c(t, ["functionCall"], q_(m)); const g = u(i, ["functionResponse"]); g != null && c(t, ["functionResponse"], g); const v = u(i, ["inlineData"]); v != null && c(t, ["inlineData"], Ua(v)); const p = u(i, ["text"]); p != null && c(t, ["text"], p); const x = u(i, ["thought"]); x != null && c(t, ["thought"], x); const T = u(i, ["thoughtSignature"]); T != null && c(t, ["thoughtSignature"], T); const _ = u(i, ["videoMetadata"]); return _ != null && c(t, ["videoMetadata"], _), t } function $_(i) { const t = {}, l = u(i, ["handle"]); if (l != null && c(t, ["handle"], l), u(i, ["transparent"]) !== void 0) throw new Error("transparent parameter is not supported in Gemini API."); return t } function eE(i) { const t = {}; if (u(i, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API."); const l = u(i, ["computerUse"]); l != null && c(t, ["computerUse"], l); const a = u(i, ["fileSearch"]); a != null && c(t, ["fileSearch"], a); const r = u(i, ["codeExecution"]); if (r != null && c(t, ["codeExecution"], r), u(i, ["enterpriseWebSearch"]) !== void 0) throw new Error("enterpriseWebSearch parameter is not supported in Gemini API."); const d = u(i, ["functionDeclarations"]); if (d != null) { let x = d; Array.isArray(x) && (x = x.map(T => T)), c(t, ["functionDeclarations"], x) } const m = u(i, ["googleMaps"]); m != null && c(t, ["googleMaps"], V_(m)); const g = u(i, ["googleSearch"]); g != null && c(t, ["googleSearch"], B_(g)); const v = u(i, ["googleSearchRetrieval"]); v != null && c(t, ["googleSearchRetrieval"], v); const p = u(i, ["urlContext"]); return p != null && c(t, ["urlContext"], p), t } function tE(i) { const t = {}, l = u(i, ["retrieval"]); l != null && c(t, ["retrieval"], l); const a = u(i, ["computerUse"]); if (a != null && c(t, ["computerUse"], a), u(i, ["fileSearch"]) !== void 0) throw new Error("fileSearch parameter is not supported in Vertex AI."); const r = u(i, ["codeExecution"]); r != null && c(t, ["codeExecution"], r); const d = u(i, ["enterpriseWebSearch"]); d != null && c(t, ["enterpriseWebSearch"], d); const m = u(i, ["functionDeclarations"]); if (m != null) { let T = m; Array.isArray(T) && (T = T.map(_ => H_(_))), c(t, ["functionDeclarations"], T) } const g = u(i, ["googleMaps"]); g != null && c(t, ["googleMaps"], g); const v = u(i, ["googleSearch"]); v != null && c(t, ["googleSearch"], v); const p = u(i, ["googleSearchRetrieval"]); p != null && c(t, ["googleSearchRetrieval"], p); const x = u(i, ["urlContext"]); return x != null && c(t, ["urlContext"], x), t } function nE(i) { const t = {}, l = u(i, ["promptTokenCount"]); l != null && c(t, ["promptTokenCount"], l); const a = u(i, ["cachedContentTokenCount"]); a != null && c(t, ["cachedContentTokenCount"], a); const r = u(i, ["candidatesTokenCount"]); r != null && c(t, ["responseTokenCount"], r); const d = u(i, ["toolUsePromptTokenCount"]); d != null && c(t, ["toolUsePromptTokenCount"], d); const m = u(i, ["thoughtsTokenCount"]); m != null && c(t, ["thoughtsTokenCount"], m); const g = u(i, ["totalTokenCount"]); g != null && c(t, ["totalTokenCount"], g); const v = u(i, ["promptTokensDetails"]); if (v != null) { let A = v; Array.isArray(A) && (A = A.map(k => k)), c(t, ["promptTokensDetails"], A) } const p = u(i, ["cacheTokensDetails"]); if (p != null) { let A = p; Array.isArray(A) && (A = A.map(k => k)), c(t, ["cacheTokensDetails"], A) } const x = u(i, ["candidatesTokensDetails"]); if (x != null) { let A = x; Array.isArray(A) && (A = A.map(k => k)), c(t, ["responseTokensDetails"], A) } const T = u(i, ["toolUsePromptTokensDetails"]); if (T != null) { let A = T; Array.isArray(A) && (A = A.map(k => k)), c(t, ["toolUsePromptTokensDetails"], A) } const _ = u(i, ["trafficType"]); return _ != null && c(t, ["trafficType"], _), t }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function iE(i) { const t = {}, l = u(i, ["data"]); if (l != null && c(t, ["data"], l), u(i, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const a = u(i, ["mimeType"]); return a != null && c(t, ["mimeType"], a), t } function oE(i) { const t = {}, l = u(i, ["content"]); l != null && c(t, ["content"], l); const a = u(i, ["citationMetadata"]); a != null && c(t, ["citationMetadata"], lE(a)); const r = u(i, ["tokenCount"]); r != null && c(t, ["tokenCount"], r); const d = u(i, ["finishReason"]); d != null && c(t, ["finishReason"], d); const m = u(i, ["avgLogprobs"]); m != null && c(t, ["avgLogprobs"], m); const g = u(i, ["groundingMetadata"]); g != null && c(t, ["groundingMetadata"], g); const v = u(i, ["index"]); v != null && c(t, ["index"], v); const p = u(i, ["logprobsResult"]); p != null && c(t, ["logprobsResult"], p); const x = u(i, ["safetyRatings"]); if (x != null) { let _ = x; Array.isArray(_) && (_ = _.map(A => A)), c(t, ["safetyRatings"], _) } const T = u(i, ["urlContextMetadata"]); return T != null && c(t, ["urlContextMetadata"], T), t } function lE(i) { const t = {}, l = u(i, ["citationSources"]); if (l != null) { let a = l; Array.isArray(a) && (a = a.map(r => r)), c(t, ["citations"], a) } return t } function aE(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["_url", "model"], Se(i, a)); const r = u(t, ["contents"]); if (r != null) { let d = Ht(r); Array.isArray(d) && (d = d.map(m => m)), c(l, ["contents"], d) } return l } function sE(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["tokensInfo"]); if (a != null) { let r = a; Array.isArray(r) && (r = r.map(d => d)), c(t, ["tokensInfo"], r) } return t } function rE(i) { const t = {}, l = u(i, ["values"]); l != null && c(t, ["values"], l); const a = u(i, ["statistics"]); return a != null && c(t, ["statistics"], uE(a)), t } function uE(i) { const t = {}, l = u(i, ["truncated"]); l != null && c(t, ["truncated"], l); const a = u(i, ["token_count"]); return a != null && c(t, ["tokenCount"], a), t } function Ba(i) { const t = {}, l = u(i, ["parts"]); if (l != null) { let r = l; Array.isArray(r) && (r = r.map(d => vA(d))), c(t, ["parts"], r) } const a = u(i, ["role"]); return a != null && c(t, ["role"], a), t } function cE(i) { const t = {}, l = u(i, ["controlType"]); l != null && c(t, ["controlType"], l); const a = u(i, ["enableControlImageComputation"]); return a != null && c(t, ["computeControl"], a), t } function dE(i) { const t = {}; if (u(i, ["systemInstruction"]) !== void 0) throw new Error("systemInstruction parameter is not supported in Gemini API."); if (u(i, ["tools"]) !== void 0) throw new Error("tools parameter is not supported in Gemini API."); if (u(i, ["generationConfig"]) !== void 0) throw new Error("generationConfig parameter is not supported in Gemini API."); return t } function fE(i, t) { const l = {}, a = u(i, ["systemInstruction"]); t !== void 0 && a != null && c(t, ["systemInstruction"], ot(a)); const r = u(i, ["tools"]); if (t !== void 0 && r != null) { let m = r; Array.isArray(m) && (m = m.map(g => Sg(g))), c(t, ["tools"], m) } const d = u(i, ["generationConfig"]); return t !== void 0 && d != null && c(t, ["generationConfig"], iA(d)), l } function mE(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["_url", "model"], Se(i, a)); const r = u(t, ["contents"]); if (r != null) { let m = Ht(r); Array.isArray(m) && (m = m.map(g => Ba(g))), c(l, ["contents"], m) } const d = u(t, ["config"]); return d != null && dE(d), l } function hE(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["_url", "model"], Se(i, a)); const r = u(t, ["contents"]); if (r != null) { let m = Ht(r); Array.isArray(m) && (m = m.map(g => g)), c(l, ["contents"], m) } const d = u(t, ["config"]); return d != null && fE(d, l), l } function pE(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["totalTokens"]); a != null && c(t, ["totalTokens"], a); const r = u(i, ["cachedContentTokenCount"]); return r != null && c(t, ["cachedContentTokenCount"], r), t } function gE(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["totalTokens"]); return a != null && c(t, ["totalTokens"], a), t } function yE(i, t) { const l = {}, a = u(t, ["model"]); return a != null && c(l, ["_url", "name"], Se(i, a)), l } function vE(i, t) { const l = {}, a = u(t, ["model"]); return a != null && c(l, ["_url", "name"], Se(i, a)), l } function xE(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); return l != null && c(t, ["sdkHttpResponse"], l), t } function SE(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); return l != null && c(t, ["sdkHttpResponse"], l), t } function TE(i, t) { const l = {}, a = u(i, ["outputGcsUri"]); t !== void 0 && a != null && c(t, ["parameters", "storageUri"], a); const r = u(i, ["negativePrompt"]); t !== void 0 && r != null && c(t, ["parameters", "negativePrompt"], r); const d = u(i, ["numberOfImages"]); t !== void 0 && d != null && c(t, ["parameters", "sampleCount"], d); const m = u(i, ["aspectRatio"]); t !== void 0 && m != null && c(t, ["parameters", "aspectRatio"], m); const g = u(i, ["guidanceScale"]); t !== void 0 && g != null && c(t, ["parameters", "guidanceScale"], g); const v = u(i, ["seed"]); t !== void 0 && v != null && c(t, ["parameters", "seed"], v); const p = u(i, ["safetyFilterLevel"]); t !== void 0 && p != null && c(t, ["parameters", "safetySetting"], p); const x = u(i, ["personGeneration"]); t !== void 0 && x != null && c(t, ["parameters", "personGeneration"], x); const T = u(i, ["includeSafetyAttributes"]); t !== void 0 && T != null && c(t, ["parameters", "includeSafetyAttributes"], T); const _ = u(i, ["includeRaiReason"]); t !== void 0 && _ != null && c(t, ["parameters", "includeRaiReason"], _); const A = u(i, ["language"]); t !== void 0 && A != null && c(t, ["parameters", "language"], A); const k = u(i, ["outputMimeType"]); t !== void 0 && k != null && c(t, ["parameters", "outputOptions", "mimeType"], k); const G = u(i, ["outputCompressionQuality"]); t !== void 0 && G != null && c(t, ["parameters", "outputOptions", "compressionQuality"], G); const U = u(i, ["addWatermark"]); t !== void 0 && U != null && c(t, ["parameters", "addWatermark"], U); const V = u(i, ["labels"]); t !== void 0 && V != null && c(t, ["labels"], V); const W = u(i, ["editMode"]); t !== void 0 && W != null && c(t, ["parameters", "editMode"], W); const B = u(i, ["baseSteps"]); return t !== void 0 && B != null && c(t, ["parameters", "editConfig", "baseSteps"], B), l } function _E(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["_url", "model"], Se(i, a)); const r = u(t, ["prompt"]); r != null && c(l, ["instances[0]", "prompt"], r); const d = u(t, ["referenceImages"]); if (d != null) { let g = d; Array.isArray(g) && (g = g.map(v => AA(v))), c(l, ["instances[0]", "referenceImages"], g) } const m = u(t, ["config"]); return m != null && TE(m, l), l } function EE(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["predictions"]); if (a != null) { let r = a; Array.isArray(r) && (r = r.map(d => Oa(d))), c(t, ["generatedImages"], r) } return t } function AE(i, t) { const l = {}, a = u(i, ["taskType"]); t !== void 0 && a != null && c(t, ["requests[]", "taskType"], a); const r = u(i, ["title"]); t !== void 0 && r != null && c(t, ["requests[]", "title"], r); const d = u(i, ["outputDimensionality"]); if (t !== void 0 && d != null && c(t, ["requests[]", "outputDimensionality"], d), u(i, ["mimeType"]) !== void 0) throw new Error("mimeType parameter is not supported in Gemini API."); if (u(i, ["autoTruncate"]) !== void 0) throw new Error("autoTruncate parameter is not supported in Gemini API."); return l } function CE(i, t) { const l = {}, a = u(i, ["taskType"]); t !== void 0 && a != null && c(t, ["instances[]", "task_type"], a); const r = u(i, ["title"]); t !== void 0 && r != null && c(t, ["instances[]", "title"], r); const d = u(i, ["outputDimensionality"]); t !== void 0 && d != null && c(t, ["parameters", "outputDimensionality"], d); const m = u(i, ["mimeType"]); t !== void 0 && m != null && c(t, ["instances[]", "mimeType"], m); const g = u(i, ["autoTruncate"]); return t !== void 0 && g != null && c(t, ["parameters", "autoTruncate"], g), l } function bE(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["_url", "model"], Se(i, a)); const r = u(t, ["contents"]); if (r != null) { let g = Pu(i, r); Array.isArray(g) && (g = g.map(v => v)), c(l, ["requests[]", "content"], g) } const d = u(t, ["config"]); d != null && AE(d, l); const m = u(t, ["model"]); return m !== void 0 && c(l, ["requests[]", "model"], Se(i, m)), l } function NE(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["_url", "model"], Se(i, a)); const r = u(t, ["contents"]); if (r != null) { let m = Pu(i, r); Array.isArray(m) && (m = m.map(g => g)), c(l, ["instances[]", "content"], m) } const d = u(t, ["config"]); return d != null && CE(d, l), l } function wE(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["embeddings"]); if (a != null) { let d = a; Array.isArray(d) && (d = d.map(m => m)), c(t, ["embeddings"], d) } const r = u(i, ["metadata"]); return r != null && c(t, ["metadata"], r), t } function ME(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["predictions[]", "embeddings"]); if (a != null) { let d = a; Array.isArray(d) && (d = d.map(m => rE(m))), c(t, ["embeddings"], d) } const r = u(i, ["metadata"]); return r != null && c(t, ["metadata"], r), t } function RE(i) { const t = {}, l = u(i, ["endpoint"]); l != null && c(t, ["name"], l); const a = u(i, ["deployedModelId"]); return a != null && c(t, ["deployedModelId"], a), t } function IE(i) { const t = {}; if (u(i, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const l = u(i, ["fileUri"]); l != null && c(t, ["fileUri"], l); const a = u(i, ["mimeType"]); return a != null && c(t, ["mimeType"], a), t } function kE(i) { const t = {}, l = u(i, ["id"]); l != null && c(t, ["id"], l); const a = u(i, ["args"]); a != null && c(t, ["args"], a); const r = u(i, ["name"]); if (r != null && c(t, ["name"], r), u(i, ["partialArgs"]) !== void 0) throw new Error("partialArgs parameter is not supported in Gemini API."); if (u(i, ["willContinue"]) !== void 0) throw new Error("willContinue parameter is not supported in Gemini API."); return t } function DE(i) { const t = {}, l = u(i, ["allowedFunctionNames"]); l != null && c(t, ["allowedFunctionNames"], l); const a = u(i, ["mode"]); if (a != null && c(t, ["mode"], a), u(i, ["streamFunctionCallArguments"]) !== void 0) throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API."); return t } function UE(i) { const t = {}, l = u(i, ["description"]); l != null && c(t, ["description"], l); const a = u(i, ["name"]); a != null && c(t, ["name"], a); const r = u(i, ["parameters"]); r != null && c(t, ["parameters"], r); const d = u(i, ["parametersJsonSchema"]); d != null && c(t, ["parametersJsonSchema"], d); const m = u(i, ["response"]); m != null && c(t, ["response"], m); const g = u(i, ["responseJsonSchema"]); if (g != null && c(t, ["responseJsonSchema"], g), u(i, ["behavior"]) !== void 0) throw new Error("behavior parameter is not supported in Vertex AI."); return t } function GE(i, t, l) { const a = {}, r = u(t, ["systemInstruction"]); l !== void 0 && r != null && c(l, ["systemInstruction"], Ba(ot(r))); const d = u(t, ["temperature"]); d != null && c(a, ["temperature"], d); const m = u(t, ["topP"]); m != null && c(a, ["topP"], m); const g = u(t, ["topK"]); g != null && c(a, ["topK"], g); const v = u(t, ["candidateCount"]); v != null && c(a, ["candidateCount"], v); const p = u(t, ["maxOutputTokens"]); p != null && c(a, ["maxOutputTokens"], p); const x = u(t, ["stopSequences"]); x != null && c(a, ["stopSequences"], x); const T = u(t, ["responseLogprobs"]); T != null && c(a, ["responseLogprobs"], T); const _ = u(t, ["logprobs"]); _ != null && c(a, ["logprobs"], _); const A = u(t, ["presencePenalty"]); A != null && c(a, ["presencePenalty"], A); const k = u(t, ["frequencyPenalty"]); k != null && c(a, ["frequencyPenalty"], k); const G = u(t, ["seed"]); G != null && c(a, ["seed"], G); const U = u(t, ["responseMimeType"]); U != null && c(a, ["responseMimeType"], U); const V = u(t, ["responseSchema"]); V != null && c(a, ["responseSchema"], Vu(V)); const W = u(t, ["responseJsonSchema"]); if (W != null && c(a, ["responseJsonSchema"], W), u(t, ["routingConfig"]) !== void 0) throw new Error("routingConfig parameter is not supported in Gemini API."); if (u(t, ["modelSelectionConfig"]) !== void 0) throw new Error("modelSelectionConfig parameter is not supported in Gemini API."); const B = u(t, ["safetySettings"]); if (l !== void 0 && B != null) { let _e = B; Array.isArray(_e) && (_e = _e.map(Oe => CA(Oe))), c(l, ["safetySettings"], _e) } const K = u(t, ["tools"]); if (l !== void 0 && K != null) { let _e = lo(K); Array.isArray(_e) && (_e = _e.map(Oe => kA(oo(Oe)))), c(l, ["tools"], _e) } const ee = u(t, ["toolConfig"]); if (l !== void 0 && ee != null && c(l, ["toolConfig"], IA(ee)), u(t, ["labels"]) !== void 0) throw new Error("labels parameter is not supported in Gemini API."); const te = u(t, ["cachedContent"]); l !== void 0 && te != null && c(l, ["cachedContent"], xn(i, te)); const F = u(t, ["responseModalities"]); F != null && c(a, ["responseModalities"], F); const ge = u(t, ["mediaResolution"]); ge != null && c(a, ["mediaResolution"], ge); const Z = u(t, ["speechConfig"]); if (Z != null && c(a, ["speechConfig"], Bu(Z)), u(t, ["audioTimestamp"]) !== void 0) throw new Error("audioTimestamp parameter is not supported in Gemini API."); const me = u(t, ["thinkingConfig"]); me != null && c(a, ["thinkingConfig"], me); const Ae = u(t, ["imageConfig"]); Ae != null && c(a, ["imageConfig"], rA(Ae)); const Le = u(t, ["enableEnhancedCivicAnswers"]); return Le != null && c(a, ["enableEnhancedCivicAnswers"], Le), a } function LE(i, t, l) { const a = {}, r = u(t, ["systemInstruction"]); l !== void 0 && r != null && c(l, ["systemInstruction"], ot(r)); const d = u(t, ["temperature"]); d != null && c(a, ["temperature"], d); const m = u(t, ["topP"]); m != null && c(a, ["topP"], m); const g = u(t, ["topK"]); g != null && c(a, ["topK"], g); const v = u(t, ["candidateCount"]); v != null && c(a, ["candidateCount"], v); const p = u(t, ["maxOutputTokens"]); p != null && c(a, ["maxOutputTokens"], p); const x = u(t, ["stopSequences"]); x != null && c(a, ["stopSequences"], x); const T = u(t, ["responseLogprobs"]); T != null && c(a, ["responseLogprobs"], T); const _ = u(t, ["logprobs"]); _ != null && c(a, ["logprobs"], _); const A = u(t, ["presencePenalty"]); A != null && c(a, ["presencePenalty"], A); const k = u(t, ["frequencyPenalty"]); k != null && c(a, ["frequencyPenalty"], k); const G = u(t, ["seed"]); G != null && c(a, ["seed"], G); const U = u(t, ["responseMimeType"]); U != null && c(a, ["responseMimeType"], U); const V = u(t, ["responseSchema"]); V != null && c(a, ["responseSchema"], Vu(V)); const W = u(t, ["responseJsonSchema"]); W != null && c(a, ["responseJsonSchema"], W); const B = u(t, ["routingConfig"]); B != null && c(a, ["routingConfig"], B); const K = u(t, ["modelSelectionConfig"]); K != null && c(a, ["modelConfig"], K); const ee = u(t, ["safetySettings"]); if (l !== void 0 && ee != null) { let L = ee; Array.isArray(L) && (L = L.map(O => O)), c(l, ["safetySettings"], L) } const te = u(t, ["tools"]); if (l !== void 0 && te != null) { let L = lo(te); Array.isArray(L) && (L = L.map(O => Sg(oo(O)))), c(l, ["tools"], L) } const F = u(t, ["toolConfig"]); l !== void 0 && F != null && c(l, ["toolConfig"], F); const ge = u(t, ["labels"]); l !== void 0 && ge != null && c(l, ["labels"], ge); const Z = u(t, ["cachedContent"]); l !== void 0 && Z != null && c(l, ["cachedContent"], xn(i, Z)); const me = u(t, ["responseModalities"]); me != null && c(a, ["responseModalities"], me); const Ae = u(t, ["mediaResolution"]); Ae != null && c(a, ["mediaResolution"], Ae); const Le = u(t, ["speechConfig"]); Le != null && c(a, ["speechConfig"], Bu(Le)); const _e = u(t, ["audioTimestamp"]); _e != null && c(a, ["audioTimestamp"], _e); const Oe = u(t, ["thinkingConfig"]); Oe != null && c(a, ["thinkingConfig"], Oe); const ut = u(t, ["imageConfig"]); if (ut != null && c(a, ["imageConfig"], uA(ut)), u(t, ["enableEnhancedCivicAnswers"]) !== void 0) throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI."); return a } function Tp(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["_url", "model"], Se(i, a)); const r = u(t, ["contents"]); if (r != null) { let m = Ht(r); Array.isArray(m) && (m = m.map(g => Ba(g))), c(l, ["contents"], m) } const d = u(t, ["config"]); return d != null && c(l, ["generationConfig"], GE(i, d, l)), l } function _p(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["_url", "model"], Se(i, a)); const r = u(t, ["contents"]); if (r != null) { let m = Ht(r); Array.isArray(m) && (m = m.map(g => g)), c(l, ["contents"], m) } const d = u(t, ["config"]); return d != null && c(l, ["generationConfig"], LE(i, d, l)), l } function Ep(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["candidates"]); if (a != null) { let v = a; Array.isArray(v) && (v = v.map(p => oE(p))), c(t, ["candidates"], v) } const r = u(i, ["modelVersion"]); r != null && c(t, ["modelVersion"], r); const d = u(i, ["promptFeedback"]); d != null && c(t, ["promptFeedback"], d); const m = u(i, ["responseId"]); m != null && c(t, ["responseId"], m); const g = u(i, ["usageMetadata"]); return g != null && c(t, ["usageMetadata"], g), t } function Ap(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["candidates"]); if (a != null) { let p = a; Array.isArray(p) && (p = p.map(x => x)), c(t, ["candidates"], p) } const r = u(i, ["createTime"]); r != null && c(t, ["createTime"], r); const d = u(i, ["modelVersion"]); d != null && c(t, ["modelVersion"], d); const m = u(i, ["promptFeedback"]); m != null && c(t, ["promptFeedback"], m); const g = u(i, ["responseId"]); g != null && c(t, ["responseId"], g); const v = u(i, ["usageMetadata"]); return v != null && c(t, ["usageMetadata"], v), t } function zE(i, t) { const l = {}; if (u(i, ["outputGcsUri"]) !== void 0) throw new Error("outputGcsUri parameter is not supported in Gemini API."); if (u(i, ["negativePrompt"]) !== void 0) throw new Error("negativePrompt parameter is not supported in Gemini API."); const a = u(i, ["numberOfImages"]); t !== void 0 && a != null && c(t, ["parameters", "sampleCount"], a); const r = u(i, ["aspectRatio"]); t !== void 0 && r != null && c(t, ["parameters", "aspectRatio"], r); const d = u(i, ["guidanceScale"]); if (t !== void 0 && d != null && c(t, ["parameters", "guidanceScale"], d), u(i, ["seed"]) !== void 0) throw new Error("seed parameter is not supported in Gemini API."); const m = u(i, ["safetyFilterLevel"]); t !== void 0 && m != null && c(t, ["parameters", "safetySetting"], m); const g = u(i, ["personGeneration"]); t !== void 0 && g != null && c(t, ["parameters", "personGeneration"], g); const v = u(i, ["includeSafetyAttributes"]); t !== void 0 && v != null && c(t, ["parameters", "includeSafetyAttributes"], v); const p = u(i, ["includeRaiReason"]); t !== void 0 && p != null && c(t, ["parameters", "includeRaiReason"], p); const x = u(i, ["language"]); t !== void 0 && x != null && c(t, ["parameters", "language"], x); const T = u(i, ["outputMimeType"]); t !== void 0 && T != null && c(t, ["parameters", "outputOptions", "mimeType"], T); const _ = u(i, ["outputCompressionQuality"]); if (t !== void 0 && _ != null && c(t, ["parameters", "outputOptions", "compressionQuality"], _), u(i, ["addWatermark"]) !== void 0) throw new Error("addWatermark parameter is not supported in Gemini API."); if (u(i, ["labels"]) !== void 0) throw new Error("labels parameter is not supported in Gemini API."); const A = u(i, ["imageSize"]); if (t !== void 0 && A != null && c(t, ["parameters", "sampleImageSize"], A), u(i, ["enhancePrompt"]) !== void 0) throw new Error("enhancePrompt parameter is not supported in Gemini API."); return l } function qE(i, t) { const l = {}, a = u(i, ["outputGcsUri"]); t !== void 0 && a != null && c(t, ["parameters", "storageUri"], a); const r = u(i, ["negativePrompt"]); t !== void 0 && r != null && c(t, ["parameters", "negativePrompt"], r); const d = u(i, ["numberOfImages"]); t !== void 0 && d != null && c(t, ["parameters", "sampleCount"], d); const m = u(i, ["aspectRatio"]); t !== void 0 && m != null && c(t, ["parameters", "aspectRatio"], m); const g = u(i, ["guidanceScale"]); t !== void 0 && g != null && c(t, ["parameters", "guidanceScale"], g); const v = u(i, ["seed"]); t !== void 0 && v != null && c(t, ["parameters", "seed"], v); const p = u(i, ["safetyFilterLevel"]); t !== void 0 && p != null && c(t, ["parameters", "safetySetting"], p); const x = u(i, ["personGeneration"]); t !== void 0 && x != null && c(t, ["parameters", "personGeneration"], x); const T = u(i, ["includeSafetyAttributes"]); t !== void 0 && T != null && c(t, ["parameters", "includeSafetyAttributes"], T); const _ = u(i, ["includeRaiReason"]); t !== void 0 && _ != null && c(t, ["parameters", "includeRaiReason"], _); const A = u(i, ["language"]); t !== void 0 && A != null && c(t, ["parameters", "language"], A); const k = u(i, ["outputMimeType"]); t !== void 0 && k != null && c(t, ["parameters", "outputOptions", "mimeType"], k); const G = u(i, ["outputCompressionQuality"]); t !== void 0 && G != null && c(t, ["parameters", "outputOptions", "compressionQuality"], G); const U = u(i, ["addWatermark"]); t !== void 0 && U != null && c(t, ["parameters", "addWatermark"], U); const V = u(i, ["labels"]); t !== void 0 && V != null && c(t, ["labels"], V); const W = u(i, ["imageSize"]); t !== void 0 && W != null && c(t, ["parameters", "sampleImageSize"], W); const B = u(i, ["enhancePrompt"]); return t !== void 0 && B != null && c(t, ["parameters", "enhancePrompt"], B), l } function HE(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["_url", "model"], Se(i, a)); const r = u(t, ["prompt"]); r != null && c(l, ["instances[0]", "prompt"], r); const d = u(t, ["config"]); return d != null && zE(d, l), l } function PE(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["_url", "model"], Se(i, a)); const r = u(t, ["prompt"]); r != null && c(l, ["instances[0]", "prompt"], r); const d = u(t, ["config"]); return d != null && qE(d, l), l } function VE(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["predictions"]); if (a != null) { let d = a; Array.isArray(d) && (d = d.map(m => $E(m))), c(t, ["generatedImages"], d) } const r = u(i, ["positivePromptSafetyAttributes"]); return r != null && c(t, ["positivePromptSafetyAttributes"], vg(r)), t } function BE(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["predictions"]); if (a != null) { let d = a; Array.isArray(d) && (d = d.map(m => Oa(m))), c(t, ["generatedImages"], d) } const r = u(i, ["positivePromptSafetyAttributes"]); return r != null && c(t, ["positivePromptSafetyAttributes"], xg(r)), t } function OE(i, t) { const l = {}, a = u(i, ["numberOfVideos"]); if (t !== void 0 && a != null && c(t, ["parameters", "sampleCount"], a), u(i, ["outputGcsUri"]) !== void 0) throw new Error("outputGcsUri parameter is not supported in Gemini API."); if (u(i, ["fps"]) !== void 0) throw new Error("fps parameter is not supported in Gemini API."); const r = u(i, ["durationSeconds"]); if (t !== void 0 && r != null && c(t, ["parameters", "durationSeconds"], r), u(i, ["seed"]) !== void 0) throw new Error("seed parameter is not supported in Gemini API."); const d = u(i, ["aspectRatio"]); t !== void 0 && d != null && c(t, ["parameters", "aspectRatio"], d); const m = u(i, ["resolution"]); t !== void 0 && m != null && c(t, ["parameters", "resolution"], m); const g = u(i, ["personGeneration"]); if (t !== void 0 && g != null && c(t, ["parameters", "personGeneration"], g), u(i, ["pubsubTopic"]) !== void 0) throw new Error("pubsubTopic parameter is not supported in Gemini API."); const v = u(i, ["negativePrompt"]); t !== void 0 && v != null && c(t, ["parameters", "negativePrompt"], v); const p = u(i, ["enhancePrompt"]); if (t !== void 0 && p != null && c(t, ["parameters", "enhancePrompt"], p), u(i, ["generateAudio"]) !== void 0) throw new Error("generateAudio parameter is not supported in Gemini API."); const x = u(i, ["lastFrame"]); t !== void 0 && x != null && c(t, ["instances[0]", "lastFrame"], Fa(x)); const T = u(i, ["referenceImages"]); if (t !== void 0 && T != null) { let _ = T; Array.isArray(_) && (_ = _.map(A => YA(A))), c(t, ["instances[0]", "referenceImages"], _) } if (u(i, ["mask"]) !== void 0) throw new Error("mask parameter is not supported in Gemini API."); if (u(i, ["compressionQuality"]) !== void 0) throw new Error("compressionQuality parameter is not supported in Gemini API."); return l } function FE(i, t) { const l = {}, a = u(i, ["numberOfVideos"]); t !== void 0 && a != null && c(t, ["parameters", "sampleCount"], a); const r = u(i, ["outputGcsUri"]); t !== void 0 && r != null && c(t, ["parameters", "storageUri"], r); const d = u(i, ["fps"]); t !== void 0 && d != null && c(t, ["parameters", "fps"], d); const m = u(i, ["durationSeconds"]); t !== void 0 && m != null && c(t, ["parameters", "durationSeconds"], m); const g = u(i, ["seed"]); t !== void 0 && g != null && c(t, ["parameters", "seed"], g); const v = u(i, ["aspectRatio"]); t !== void 0 && v != null && c(t, ["parameters", "aspectRatio"], v); const p = u(i, ["resolution"]); t !== void 0 && p != null && c(t, ["parameters", "resolution"], p); const x = u(i, ["personGeneration"]); t !== void 0 && x != null && c(t, ["parameters", "personGeneration"], x); const T = u(i, ["pubsubTopic"]); t !== void 0 && T != null && c(t, ["parameters", "pubsubTopic"], T); const _ = u(i, ["negativePrompt"]); t !== void 0 && _ != null && c(t, ["parameters", "negativePrompt"], _); const A = u(i, ["enhancePrompt"]); t !== void 0 && A != null && c(t, ["parameters", "enhancePrompt"], A); const k = u(i, ["generateAudio"]); t !== void 0 && k != null && c(t, ["parameters", "generateAudio"], k); const G = u(i, ["lastFrame"]); t !== void 0 && G != null && c(t, ["instances[0]", "lastFrame"], Wt(G)); const U = u(i, ["referenceImages"]); if (t !== void 0 && U != null) { let B = U; Array.isArray(B) && (B = B.map(K => JA(K))), c(t, ["instances[0]", "referenceImages"], B) } const V = u(i, ["mask"]); t !== void 0 && V != null && c(t, ["instances[0]", "mask"], FA(V)); const W = u(i, ["compressionQuality"]); return t !== void 0 && W != null && c(t, ["parameters", "compressionQuality"], W), l } function YE(i) { const t = {}, l = u(i, ["name"]); l != null && c(t, ["name"], l); const a = u(i, ["metadata"]); a != null && c(t, ["metadata"], a); const r = u(i, ["done"]); r != null && c(t, ["done"], r); const d = u(i, ["error"]); d != null && c(t, ["error"], d); const m = u(i, ["response", "generateVideoResponse"]); return m != null && c(t, ["response"], XE(m)), t } function JE(i) { const t = {}, l = u(i, ["name"]); l != null && c(t, ["name"], l); const a = u(i, ["metadata"]); a != null && c(t, ["metadata"], a); const r = u(i, ["done"]); r != null && c(t, ["done"], r); const d = u(i, ["error"]); d != null && c(t, ["error"], d); const m = u(i, ["response"]); return m != null && c(t, ["response"], QE(m)), t } function WE(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["_url", "model"], Se(i, a)); const r = u(t, ["prompt"]); r != null && c(l, ["instances[0]", "prompt"], r); const d = u(t, ["image"]); d != null && c(l, ["instances[0]", "image"], Fa(d)); const m = u(t, ["video"]); m != null && c(l, ["instances[0]", "video"], Tg(m)); const g = u(t, ["source"]); g != null && jE(g, l); const v = u(t, ["config"]); return v != null && OE(v, l), l } function KE(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["_url", "model"], Se(i, a)); const r = u(t, ["prompt"]); r != null && c(l, ["instances[0]", "prompt"], r); const d = u(t, ["image"]); d != null && c(l, ["instances[0]", "image"], Wt(d)); const m = u(t, ["video"]); m != null && c(l, ["instances[0]", "video"], _g(m)); const g = u(t, ["source"]); g != null && ZE(g, l); const v = u(t, ["config"]); return v != null && FE(v, l), l } function XE(i) { const t = {}, l = u(i, ["generatedSamples"]); if (l != null) { let d = l; Array.isArray(d) && (d = d.map(m => tA(m))), c(t, ["generatedVideos"], d) } const a = u(i, ["raiMediaFilteredCount"]); a != null && c(t, ["raiMediaFilteredCount"], a); const r = u(i, ["raiMediaFilteredReasons"]); return r != null && c(t, ["raiMediaFilteredReasons"], r), t } function QE(i) { const t = {}, l = u(i, ["videos"]); if (l != null) { let d = l; Array.isArray(d) && (d = d.map(m => nA(m))), c(t, ["generatedVideos"], d) } const a = u(i, ["raiMediaFilteredCount"]); a != null && c(t, ["raiMediaFilteredCount"], a); const r = u(i, ["raiMediaFilteredReasons"]); return r != null && c(t, ["raiMediaFilteredReasons"], r), t } function jE(i, t) { const l = {}, a = u(i, ["prompt"]); t !== void 0 && a != null && c(t, ["instances[0]", "prompt"], a); const r = u(i, ["image"]); t !== void 0 && r != null && c(t, ["instances[0]", "image"], Fa(r)); const d = u(i, ["video"]); return t !== void 0 && d != null && c(t, ["instances[0]", "video"], Tg(d)), l } function ZE(i, t) { const l = {}, a = u(i, ["prompt"]); t !== void 0 && a != null && c(t, ["instances[0]", "prompt"], a); const r = u(i, ["image"]); t !== void 0 && r != null && c(t, ["instances[0]", "image"], Wt(r)); const d = u(i, ["video"]); return t !== void 0 && d != null && c(t, ["instances[0]", "video"], _g(d)), l } function $E(i) { const t = {}, l = u(i, ["_self"]); l != null && c(t, ["image"], cA(l)); const a = u(i, ["raiFilteredReason"]); a != null && c(t, ["raiFilteredReason"], a); const r = u(i, ["_self"]); return r != null && c(t, ["safetyAttributes"], vg(r)), t } function Oa(i) { const t = {}, l = u(i, ["_self"]); l != null && c(t, ["image"], yg(l)); const a = u(i, ["raiFilteredReason"]); a != null && c(t, ["raiFilteredReason"], a); const r = u(i, ["_self"]); r != null && c(t, ["safetyAttributes"], xg(r)); const d = u(i, ["prompt"]); return d != null && c(t, ["enhancedPrompt"], d), t } function eA(i) { const t = {}, l = u(i, ["_self"]); l != null && c(t, ["mask"], yg(l)); const a = u(i, ["labels"]); if (a != null) { let r = a; Array.isArray(r) && (r = r.map(d => d)), c(t, ["labels"], r) } return t } function tA(i) { const t = {}, l = u(i, ["video"]); return l != null && c(t, ["video"], BA(l)), t } function nA(i) { const t = {}, l = u(i, ["_self"]); return l != null && c(t, ["video"], OA(l)), t } function iA(i) { const t = {}, l = u(i, ["modelSelectionConfig"]); l != null && c(t, ["modelConfig"], l); const a = u(i, ["responseJsonSchema"]); a != null && c(t, ["responseJsonSchema"], a); const r = u(i, ["audioTimestamp"]); r != null && c(t, ["audioTimestamp"], r); const d = u(i, ["candidateCount"]); d != null && c(t, ["candidateCount"], d); const m = u(i, ["enableAffectiveDialog"]); m != null && c(t, ["enableAffectiveDialog"], m); const g = u(i, ["frequencyPenalty"]); g != null && c(t, ["frequencyPenalty"], g); const v = u(i, ["logprobs"]); v != null && c(t, ["logprobs"], v); const p = u(i, ["maxOutputTokens"]); p != null && c(t, ["maxOutputTokens"], p); const x = u(i, ["mediaResolution"]); x != null && c(t, ["mediaResolution"], x); const T = u(i, ["presencePenalty"]); T != null && c(t, ["presencePenalty"], T); const _ = u(i, ["responseLogprobs"]); _ != null && c(t, ["responseLogprobs"], _); const A = u(i, ["responseMimeType"]); A != null && c(t, ["responseMimeType"], A); const k = u(i, ["responseModalities"]); k != null && c(t, ["responseModalities"], k); const G = u(i, ["responseSchema"]); G != null && c(t, ["responseSchema"], G); const U = u(i, ["routingConfig"]); U != null && c(t, ["routingConfig"], U); const V = u(i, ["seed"]); V != null && c(t, ["seed"], V); const W = u(i, ["speechConfig"]); W != null && c(t, ["speechConfig"], W); const B = u(i, ["stopSequences"]); B != null && c(t, ["stopSequences"], B); const K = u(i, ["temperature"]); K != null && c(t, ["temperature"], K); const ee = u(i, ["thinkingConfig"]); ee != null && c(t, ["thinkingConfig"], ee); const te = u(i, ["topK"]); te != null && c(t, ["topK"], te); const F = u(i, ["topP"]); if (F != null && c(t, ["topP"], F), u(i, ["enableEnhancedCivicAnswers"]) !== void 0) throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI."); return t } function oA(i, t) { const l = {}, a = u(t, ["model"]); return a != null && c(l, ["_url", "name"], Se(i, a)), l } function lA(i, t) { const l = {}, a = u(t, ["model"]); return a != null && c(l, ["_url", "name"], Se(i, a)), l } function aA(i) { const t = {}; if (u(i, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API."); const l = u(i, ["enableWidget"]); return l != null && c(t, ["enableWidget"], l), t } function sA(i) { const t = {}; if (u(i, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API."); if (u(i, ["blockingConfidence"]) !== void 0) throw new Error("blockingConfidence parameter is not supported in Gemini API."); const l = u(i, ["timeRangeFilter"]); return l != null && c(t, ["timeRangeFilter"], l), t } function rA(i) { const t = {}, l = u(i, ["aspectRatio"]); l != null && c(t, ["aspectRatio"], l); const a = u(i, ["imageSize"]); if (a != null && c(t, ["imageSize"], a), u(i, ["personGeneration"]) !== void 0) throw new Error("personGeneration parameter is not supported in Gemini API."); if (u(i, ["outputMimeType"]) !== void 0) throw new Error("outputMimeType parameter is not supported in Gemini API."); if (u(i, ["outputCompressionQuality"]) !== void 0) throw new Error("outputCompressionQuality parameter is not supported in Gemini API."); return t } function uA(i) { const t = {}, l = u(i, ["aspectRatio"]); l != null && c(t, ["aspectRatio"], l); const a = u(i, ["imageSize"]); a != null && c(t, ["imageSize"], a); const r = u(i, ["personGeneration"]); r != null && c(t, ["personGeneration"], r); const d = u(i, ["outputMimeType"]); d != null && c(t, ["imageOutputOptions", "mimeType"], d); const m = u(i, ["outputCompressionQuality"]); return m != null && c(t, ["imageOutputOptions", "compressionQuality"], m), t } function cA(i) { const t = {}, l = u(i, ["bytesBase64Encoded"]); l != null && c(t, ["imageBytes"], Yn(l)); const a = u(i, ["mimeType"]); return a != null && c(t, ["mimeType"], a), t } function yg(i) { const t = {}, l = u(i, ["gcsUri"]); l != null && c(t, ["gcsUri"], l); const a = u(i, ["bytesBase64Encoded"]); a != null && c(t, ["imageBytes"], Yn(a)); const r = u(i, ["mimeType"]); return r != null && c(t, ["mimeType"], r), t } function Fa(i) { const t = {}; if (u(i, ["gcsUri"]) !== void 0) throw new Error("gcsUri parameter is not supported in Gemini API."); const l = u(i, ["imageBytes"]); l != null && c(t, ["bytesBase64Encoded"], Yn(l)); const a = u(i, ["mimeType"]); return a != null && c(t, ["mimeType"], a), t } function Wt(i) { const t = {}, l = u(i, ["gcsUri"]); l != null && c(t, ["gcsUri"], l); const a = u(i, ["imageBytes"]); a != null && c(t, ["bytesBase64Encoded"], Yn(a)); const r = u(i, ["mimeType"]); return r != null && c(t, ["mimeType"], r), t } function dA(i, t, l) { const a = {}, r = u(t, ["pageSize"]); l !== void 0 && r != null && c(l, ["_query", "pageSize"], r); const d = u(t, ["pageToken"]); l !== void 0 && d != null && c(l, ["_query", "pageToken"], d); const m = u(t, ["filter"]); l !== void 0 && m != null && c(l, ["_query", "filter"], m); const g = u(t, ["queryBase"]); return l !== void 0 && g != null && c(l, ["_url", "models_url"], cg(i, g)), a } function fA(i, t, l) { const a = {}, r = u(t, ["pageSize"]); l !== void 0 && r != null && c(l, ["_query", "pageSize"], r); const d = u(t, ["pageToken"]); l !== void 0 && d != null && c(l, ["_query", "pageToken"], d); const m = u(t, ["filter"]); l !== void 0 && m != null && c(l, ["_query", "filter"], m); const g = u(t, ["queryBase"]); return l !== void 0 && g != null && c(l, ["_url", "models_url"], cg(i, g)), a } function mA(i, t) { const l = {}, a = u(t, ["config"]); return a != null && dA(i, a, l), l } function hA(i, t) { const l = {}, a = u(t, ["config"]); return a != null && fA(i, a, l), l } function pA(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["nextPageToken"]); a != null && c(t, ["nextPageToken"], a); const r = u(i, ["_self"]); if (r != null) { let d = dg(r); Array.isArray(d) && (d = d.map(m => bu(m))), c(t, ["models"], d) } return t } function gA(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["nextPageToken"]); a != null && c(t, ["nextPageToken"], a); const r = u(i, ["_self"]); if (r != null) { let d = dg(r); Array.isArray(d) && (d = d.map(m => Nu(m))), c(t, ["models"], d) } return t } function yA(i) { const t = {}, l = u(i, ["maskMode"]); l != null && c(t, ["maskMode"], l); const a = u(i, ["segmentationClasses"]); a != null && c(t, ["maskClasses"], a); const r = u(i, ["maskDilation"]); return r != null && c(t, ["dilation"], r), t } function bu(i) { const t = {}, l = u(i, ["name"]); l != null && c(t, ["name"], l); const a = u(i, ["displayName"]); a != null && c(t, ["displayName"], a); const r = u(i, ["description"]); r != null && c(t, ["description"], r); const d = u(i, ["version"]); d != null && c(t, ["version"], d); const m = u(i, ["_self"]); m != null && c(t, ["tunedModelInfo"], DA(m)); const g = u(i, ["inputTokenLimit"]); g != null && c(t, ["inputTokenLimit"], g); const v = u(i, ["outputTokenLimit"]); v != null && c(t, ["outputTokenLimit"], v); const p = u(i, ["supportedGenerationMethods"]); p != null && c(t, ["supportedActions"], p); const x = u(i, ["temperature"]); x != null && c(t, ["temperature"], x); const T = u(i, ["maxTemperature"]); T != null && c(t, ["maxTemperature"], T); const _ = u(i, ["topP"]); _ != null && c(t, ["topP"], _); const A = u(i, ["topK"]); A != null && c(t, ["topK"], A); const k = u(i, ["thinking"]); return k != null && c(t, ["thinking"], k), t } function Nu(i) { const t = {}, l = u(i, ["name"]); l != null && c(t, ["name"], l); const a = u(i, ["displayName"]); a != null && c(t, ["displayName"], a); const r = u(i, ["description"]); r != null && c(t, ["description"], r); const d = u(i, ["versionId"]); d != null && c(t, ["version"], d); const m = u(i, ["deployedModels"]); if (m != null) { let T = m; Array.isArray(T) && (T = T.map(_ => RE(_))), c(t, ["endpoints"], T) } const g = u(i, ["labels"]); g != null && c(t, ["labels"], g); const v = u(i, ["_self"]); v != null && c(t, ["tunedModelInfo"], UA(v)); const p = u(i, ["defaultCheckpointId"]); p != null && c(t, ["defaultCheckpointId"], p); const x = u(i, ["checkpoints"]); if (x != null) { let T = x; Array.isArray(T) && (T = T.map(_ => _)), c(t, ["checkpoints"], T) } return t } function vA(i) { const t = {}, l = u(i, ["mediaResolution"]); l != null && c(t, ["mediaResolution"], l); const a = u(i, ["codeExecutionResult"]); a != null && c(t, ["codeExecutionResult"], a); const r = u(i, ["executableCode"]); r != null && c(t, ["executableCode"], r); const d = u(i, ["fileData"]); d != null && c(t, ["fileData"], IE(d)); const m = u(i, ["functionCall"]); m != null && c(t, ["functionCall"], kE(m)); const g = u(i, ["functionResponse"]); g != null && c(t, ["functionResponse"], g); const v = u(i, ["inlineData"]); v != null && c(t, ["inlineData"], iE(v)); const p = u(i, ["text"]); p != null && c(t, ["text"], p); const x = u(i, ["thought"]); x != null && c(t, ["thought"], x); const T = u(i, ["thoughtSignature"]); T != null && c(t, ["thoughtSignature"], T); const _ = u(i, ["videoMetadata"]); return _ != null && c(t, ["videoMetadata"], _), t } function xA(i) { const t = {}, l = u(i, ["productImage"]); return l != null && c(t, ["image"], Wt(l)), t } function SA(i, t) { const l = {}, a = u(i, ["numberOfImages"]); t !== void 0 && a != null && c(t, ["parameters", "sampleCount"], a); const r = u(i, ["baseSteps"]); t !== void 0 && r != null && c(t, ["parameters", "baseSteps"], r); const d = u(i, ["outputGcsUri"]); t !== void 0 && d != null && c(t, ["parameters", "storageUri"], d); const m = u(i, ["seed"]); t !== void 0 && m != null && c(t, ["parameters", "seed"], m); const g = u(i, ["safetyFilterLevel"]); t !== void 0 && g != null && c(t, ["parameters", "safetySetting"], g); const v = u(i, ["personGeneration"]); t !== void 0 && v != null && c(t, ["parameters", "personGeneration"], v); const p = u(i, ["addWatermark"]); t !== void 0 && p != null && c(t, ["parameters", "addWatermark"], p); const x = u(i, ["outputMimeType"]); t !== void 0 && x != null && c(t, ["parameters", "outputOptions", "mimeType"], x); const T = u(i, ["outputCompressionQuality"]); t !== void 0 && T != null && c(t, ["parameters", "outputOptions", "compressionQuality"], T); const _ = u(i, ["enhancePrompt"]); t !== void 0 && _ != null && c(t, ["parameters", "enhancePrompt"], _); const A = u(i, ["labels"]); return t !== void 0 && A != null && c(t, ["labels"], A), l } function TA(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["_url", "model"], Se(i, a)); const r = u(t, ["source"]); r != null && EA(r, l); const d = u(t, ["config"]); return d != null && SA(d, l), l } function _A(i) { const t = {}, l = u(i, ["predictions"]); if (l != null) { let a = l; Array.isArray(a) && (a = a.map(r => Oa(r))), c(t, ["generatedImages"], a) } return t } function EA(i, t) { const l = {}, a = u(i, ["prompt"]); t !== void 0 && a != null && c(t, ["instances[0]", "prompt"], a); const r = u(i, ["personImage"]); t !== void 0 && r != null && c(t, ["instances[0]", "personImage", "image"], Wt(r)); const d = u(i, ["productImages"]); if (t !== void 0 && d != null) { let m = d; Array.isArray(m) && (m = m.map(g => xA(g))), c(t, ["instances[0]", "productImages"], m) } return l } function AA(i) { const t = {}, l = u(i, ["referenceImage"]); l != null && c(t, ["referenceImage"], Wt(l)); const a = u(i, ["referenceId"]); a != null && c(t, ["referenceId"], a); const r = u(i, ["referenceType"]); r != null && c(t, ["referenceType"], r); const d = u(i, ["maskImageConfig"]); d != null && c(t, ["maskImageConfig"], yA(d)); const m = u(i, ["controlImageConfig"]); m != null && c(t, ["controlImageConfig"], cE(m)); const g = u(i, ["styleImageConfig"]); g != null && c(t, ["styleImageConfig"], g); const v = u(i, ["subjectImageConfig"]); return v != null && c(t, ["subjectImageConfig"], v), t } function vg(i) { const t = {}, l = u(i, ["safetyAttributes", "categories"]); l != null && c(t, ["categories"], l); const a = u(i, ["safetyAttributes", "scores"]); a != null && c(t, ["scores"], a); const r = u(i, ["contentType"]); return r != null && c(t, ["contentType"], r), t } function xg(i) { const t = {}, l = u(i, ["safetyAttributes", "categories"]); l != null && c(t, ["categories"], l); const a = u(i, ["safetyAttributes", "scores"]); a != null && c(t, ["scores"], a); const r = u(i, ["contentType"]); return r != null && c(t, ["contentType"], r), t } function CA(i) { const t = {}, l = u(i, ["category"]); if (l != null && c(t, ["category"], l), u(i, ["method"]) !== void 0) throw new Error("method parameter is not supported in Gemini API."); const a = u(i, ["threshold"]); return a != null && c(t, ["threshold"], a), t } function bA(i) { const t = {}, l = u(i, ["image"]); return l != null && c(t, ["image"], Wt(l)), t } function NA(i, t) { const l = {}, a = u(i, ["mode"]); t !== void 0 && a != null && c(t, ["parameters", "mode"], a); const r = u(i, ["maxPredictions"]); t !== void 0 && r != null && c(t, ["parameters", "maxPredictions"], r); const d = u(i, ["confidenceThreshold"]); t !== void 0 && d != null && c(t, ["parameters", "confidenceThreshold"], d); const m = u(i, ["maskDilation"]); t !== void 0 && m != null && c(t, ["parameters", "maskDilation"], m); const g = u(i, ["binaryColorThreshold"]); t !== void 0 && g != null && c(t, ["parameters", "binaryColorThreshold"], g); const v = u(i, ["labels"]); return t !== void 0 && v != null && c(t, ["labels"], v), l } function wA(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["_url", "model"], Se(i, a)); const r = u(t, ["source"]); r != null && RA(r, l); const d = u(t, ["config"]); return d != null && NA(d, l), l } function MA(i) { const t = {}, l = u(i, ["predictions"]); if (l != null) { let a = l; Array.isArray(a) && (a = a.map(r => eA(r))), c(t, ["generatedMasks"], a) } return t } function RA(i, t) { const l = {}, a = u(i, ["prompt"]); t !== void 0 && a != null && c(t, ["instances[0]", "prompt"], a); const r = u(i, ["image"]); t !== void 0 && r != null && c(t, ["instances[0]", "image"], Wt(r)); const d = u(i, ["scribbleImage"]); return t !== void 0 && d != null && c(t, ["instances[0]", "scribble"], bA(d)), l } function IA(i) { const t = {}, l = u(i, ["retrievalConfig"]); l != null && c(t, ["retrievalConfig"], l); const a = u(i, ["functionCallingConfig"]); return a != null && c(t, ["functionCallingConfig"], DE(a)), t } function kA(i) { const t = {}; if (u(i, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API."); const l = u(i, ["computerUse"]); l != null && c(t, ["computerUse"], l); const a = u(i, ["fileSearch"]); a != null && c(t, ["fileSearch"], a); const r = u(i, ["codeExecution"]); if (r != null && c(t, ["codeExecution"], r), u(i, ["enterpriseWebSearch"]) !== void 0) throw new Error("enterpriseWebSearch parameter is not supported in Gemini API."); const d = u(i, ["functionDeclarations"]); if (d != null) { let x = d; Array.isArray(x) && (x = x.map(T => T)), c(t, ["functionDeclarations"], x) } const m = u(i, ["googleMaps"]); m != null && c(t, ["googleMaps"], aA(m)); const g = u(i, ["googleSearch"]); g != null && c(t, ["googleSearch"], sA(g)); const v = u(i, ["googleSearchRetrieval"]); v != null && c(t, ["googleSearchRetrieval"], v); const p = u(i, ["urlContext"]); return p != null && c(t, ["urlContext"], p), t } function Sg(i) { const t = {}, l = u(i, ["retrieval"]); l != null && c(t, ["retrieval"], l); const a = u(i, ["computerUse"]); if (a != null && c(t, ["computerUse"], a), u(i, ["fileSearch"]) !== void 0) throw new Error("fileSearch parameter is not supported in Vertex AI."); const r = u(i, ["codeExecution"]); r != null && c(t, ["codeExecution"], r); const d = u(i, ["enterpriseWebSearch"]); d != null && c(t, ["enterpriseWebSearch"], d); const m = u(i, ["functionDeclarations"]); if (m != null) { let T = m; Array.isArray(T) && (T = T.map(_ => UE(_))), c(t, ["functionDeclarations"], T) } const g = u(i, ["googleMaps"]); g != null && c(t, ["googleMaps"], g); const v = u(i, ["googleSearch"]); v != null && c(t, ["googleSearch"], v); const p = u(i, ["googleSearchRetrieval"]); p != null && c(t, ["googleSearchRetrieval"], p); const x = u(i, ["urlContext"]); return x != null && c(t, ["urlContext"], x), t } function DA(i) { const t = {}, l = u(i, ["baseModel"]); l != null && c(t, ["baseModel"], l); const a = u(i, ["createTime"]); a != null && c(t, ["createTime"], a); const r = u(i, ["updateTime"]); return r != null && c(t, ["updateTime"], r), t } function UA(i) { const t = {}, l = u(i, ["labels", "google-vertex-llm-tuning-base-model-id"]); l != null && c(t, ["baseModel"], l); const a = u(i, ["createTime"]); a != null && c(t, ["createTime"], a); const r = u(i, ["updateTime"]); return r != null && c(t, ["updateTime"], r), t } function GA(i, t) { const l = {}, a = u(i, ["displayName"]); t !== void 0 && a != null && c(t, ["displayName"], a); const r = u(i, ["description"]); t !== void 0 && r != null && c(t, ["description"], r); const d = u(i, ["defaultCheckpointId"]); return t !== void 0 && d != null && c(t, ["defaultCheckpointId"], d), l } function LA(i, t) { const l = {}, a = u(i, ["displayName"]); t !== void 0 && a != null && c(t, ["displayName"], a); const r = u(i, ["description"]); t !== void 0 && r != null && c(t, ["description"], r); const d = u(i, ["defaultCheckpointId"]); return t !== void 0 && d != null && c(t, ["defaultCheckpointId"], d), l } function zA(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["_url", "name"], Se(i, a)); const r = u(t, ["config"]); return r != null && GA(r, l), l } function qA(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["_url", "model"], Se(i, a)); const r = u(t, ["config"]); return r != null && LA(r, l), l } function HA(i, t) { const l = {}, a = u(i, ["outputGcsUri"]); t !== void 0 && a != null && c(t, ["parameters", "storageUri"], a); const r = u(i, ["safetyFilterLevel"]); t !== void 0 && r != null && c(t, ["parameters", "safetySetting"], r); const d = u(i, ["personGeneration"]); t !== void 0 && d != null && c(t, ["parameters", "personGeneration"], d); const m = u(i, ["includeRaiReason"]); t !== void 0 && m != null && c(t, ["parameters", "includeRaiReason"], m); const g = u(i, ["outputMimeType"]); t !== void 0 && g != null && c(t, ["parameters", "outputOptions", "mimeType"], g); const v = u(i, ["outputCompressionQuality"]); t !== void 0 && v != null && c(t, ["parameters", "outputOptions", "compressionQuality"], v); const p = u(i, ["enhanceInputImage"]); t !== void 0 && p != null && c(t, ["parameters", "upscaleConfig", "enhanceInputImage"], p); const x = u(i, ["imagePreservationFactor"]); t !== void 0 && x != null && c(t, ["parameters", "upscaleConfig", "imagePreservationFactor"], x); const T = u(i, ["labels"]); t !== void 0 && T != null && c(t, ["labels"], T); const _ = u(i, ["numberOfImages"]); t !== void 0 && _ != null && c(t, ["parameters", "sampleCount"], _); const A = u(i, ["mode"]); return t !== void 0 && A != null && c(t, ["parameters", "mode"], A), l } function PA(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["_url", "model"], Se(i, a)); const r = u(t, ["image"]); r != null && c(l, ["instances[0]", "image"], Wt(r)); const d = u(t, ["upscaleFactor"]); d != null && c(l, ["parameters", "upscaleConfig", "upscaleFactor"], d); const m = u(t, ["config"]); return m != null && HA(m, l), l } function VA(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["predictions"]); if (a != null) { let r = a; Array.isArray(r) && (r = r.map(d => Oa(d))), c(t, ["generatedImages"], r) } return t } function BA(i) { const t = {}, l = u(i, ["uri"]); l != null && c(t, ["uri"], l); const a = u(i, ["encodedVideo"]); a != null && c(t, ["videoBytes"], Yn(a)); const r = u(i, ["encoding"]); return r != null && c(t, ["mimeType"], r), t } function OA(i) { const t = {}, l = u(i, ["gcsUri"]); l != null && c(t, ["uri"], l); const a = u(i, ["bytesBase64Encoded"]); a != null && c(t, ["videoBytes"], Yn(a)); const r = u(i, ["mimeType"]); return r != null && c(t, ["mimeType"], r), t } function FA(i) { const t = {}, l = u(i, ["image"]); l != null && c(t, ["_self"], Wt(l)); const a = u(i, ["maskMode"]); return a != null && c(t, ["maskMode"], a), t } function YA(i) { const t = {}, l = u(i, ["image"]); l != null && c(t, ["image"], Fa(l)); const a = u(i, ["referenceType"]); return a != null && c(t, ["referenceType"], a), t } function JA(i) { const t = {}, l = u(i, ["image"]); l != null && c(t, ["image"], Wt(l)); const a = u(i, ["referenceType"]); return a != null && c(t, ["referenceType"], a), t } function Tg(i) { const t = {}, l = u(i, ["uri"]); l != null && c(t, ["uri"], l); const a = u(i, ["videoBytes"]); a != null && c(t, ["encodedVideo"], Yn(a)); const r = u(i, ["mimeType"]); return r != null && c(t, ["encoding"], r), t } function _g(i) { const t = {}, l = u(i, ["uri"]); l != null && c(t, ["gcsUri"], l); const a = u(i, ["videoBytes"]); a != null && c(t, ["bytesBase64Encoded"], Yn(a)); const r = u(i, ["mimeType"]); return r != null && c(t, ["mimeType"], r), t }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function WA(i, t) { const l = {}, a = u(i, ["displayName"]); return t !== void 0 && a != null && c(t, ["displayName"], a), l } function KA(i) { const t = {}, l = u(i, ["config"]); return l != null && WA(l, t), t } function XA(i, t) { const l = {}, a = u(i, ["force"]); return t !== void 0 && a != null && c(t, ["_query", "force"], a), l } function QA(i) { const t = {}, l = u(i, ["name"]); l != null && c(t, ["_url", "name"], l); const a = u(i, ["config"]); return a != null && XA(a, t), t } function jA(i) { const t = {}, l = u(i, ["name"]); return l != null && c(t, ["_url", "name"], l), t } function ZA(i, t) { const l = {}, a = u(i, ["customMetadata"]); if (t !== void 0 && a != null) { let d = a; Array.isArray(d) && (d = d.map(m => m)), c(t, ["customMetadata"], d) } const r = u(i, ["chunkingConfig"]); return t !== void 0 && r != null && c(t, ["chunkingConfig"], r), l } function $A(i) { const t = {}, l = u(i, ["name"]); l != null && c(t, ["name"], l); const a = u(i, ["metadata"]); a != null && c(t, ["metadata"], a); const r = u(i, ["done"]); r != null && c(t, ["done"], r); const d = u(i, ["error"]); d != null && c(t, ["error"], d); const m = u(i, ["response"]); return m != null && c(t, ["response"], tC(m)), t } function eC(i) { const t = {}, l = u(i, ["fileSearchStoreName"]); l != null && c(t, ["_url", "file_search_store_name"], l); const a = u(i, ["fileName"]); a != null && c(t, ["fileName"], a); const r = u(i, ["config"]); return r != null && ZA(r, t), t } function tC(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["parent"]); a != null && c(t, ["parent"], a); const r = u(i, ["documentName"]); return r != null && c(t, ["documentName"], r), t } function nC(i, t) { const l = {}, a = u(i, ["pageSize"]); t !== void 0 && a != null && c(t, ["_query", "pageSize"], a); const r = u(i, ["pageToken"]); return t !== void 0 && r != null && c(t, ["_query", "pageToken"], r), l } function iC(i) { const t = {}, l = u(i, ["config"]); return l != null && nC(l, t), t } function oC(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["nextPageToken"]); a != null && c(t, ["nextPageToken"], a); const r = u(i, ["fileSearchStores"]); if (r != null) { let d = r; Array.isArray(d) && (d = d.map(m => m)), c(t, ["fileSearchStores"], d) } return t } function Eg(i, t) { const l = {}, a = u(i, ["mimeType"]); t !== void 0 && a != null && c(t, ["mimeType"], a); const r = u(i, ["displayName"]); t !== void 0 && r != null && c(t, ["displayName"], r); const d = u(i, ["customMetadata"]); if (t !== void 0 && d != null) { let g = d; Array.isArray(g) && (g = g.map(v => v)), c(t, ["customMetadata"], g) } const m = u(i, ["chunkingConfig"]); return t !== void 0 && m != null && c(t, ["chunkingConfig"], m), l } function lC(i) { const t = {}, l = u(i, ["fileSearchStoreName"]); l != null && c(t, ["_url", "file_search_store_name"], l); const a = u(i, ["config"]); return a != null && Eg(a, t), t } function aC(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); return l != null && c(t, ["sdkHttpResponse"], l), t }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const sC = "Content-Type", rC = "X-Server-Timeout", uC = "User-Agent", wu = "x-goog-api-client", cC = "1.35.0", dC = `google-genai-sdk/${cC}`, fC = "v1beta1", mC = "v1beta"; class hC {
  constructor(t) { var l, a; this.clientOptions = Object.assign(Object.assign({}, t), { project: t.project, location: t.location, apiKey: t.apiKey, vertexai: t.vertexai }); const r = {}; this.clientOptions.vertexai ? (r.apiVersion = (l = this.clientOptions.apiVersion) !== null && l !== void 0 ? l : fC, r.baseUrl = this.baseUrlFromProjectLocation(), this.normalizeAuthParameters()) : (r.apiVersion = (a = this.clientOptions.apiVersion) !== null && a !== void 0 ? a : mC, r.baseUrl = "https://generativelanguage.googleapis.com/"), r.headers = this.getDefaultHeaders(), this.clientOptions.httpOptions = r, t.httpOptions && (this.clientOptions.httpOptions = this.patchHttpOptions(r, t.httpOptions)) } baseUrlFromProjectLocation() { return this.clientOptions.project && this.clientOptions.location && this.clientOptions.location !== "global" ? `https://${this.clientOptions.location}-aiplatform.googleapis.com/` : "https://aiplatform.googleapis.com/" } normalizeAuthParameters() { if (this.clientOptions.project && this.clientOptions.location) { this.clientOptions.apiKey = void 0; return } this.clientOptions.project = void 0, this.clientOptions.location = void 0 } isVertexAI() { var t; return (t = this.clientOptions.vertexai) !== null && t !== void 0 ? t : !1 } getProject() { return this.clientOptions.project } getLocation() { return this.clientOptions.location } async getAuthHeaders() { const t = new Headers; return await this.clientOptions.auth.addAuthHeaders(t), t } getApiVersion() { if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== void 0) return this.clientOptions.httpOptions.apiVersion; throw new Error("API version is not set.") } getBaseUrl() { if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== void 0) return this.clientOptions.httpOptions.baseUrl; throw new Error("Base URL is not set.") } getRequestUrl() { return this.getRequestUrlInternal(this.clientOptions.httpOptions) } getHeaders() { if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== void 0) return this.clientOptions.httpOptions.headers; throw new Error("Headers are not set.") } getRequestUrlInternal(t) { if (!t || t.baseUrl === void 0 || t.apiVersion === void 0) throw new Error("HTTP options are not correctly set."); const a = [t.baseUrl.endsWith("/") ? t.baseUrl.slice(0, -1) : t.baseUrl]; return t.apiVersion && t.apiVersion !== "" && a.push(t.apiVersion), a.join("/") } getBaseResourcePath() { return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}` } getApiKey() { return this.clientOptions.apiKey } getWebsocketBaseUrl() { const t = this.getBaseUrl(), l = new URL(t); return l.protocol = l.protocol == "http:" ? "ws" : "wss", l.toString() } setBaseUrl(t) { if (this.clientOptions.httpOptions) this.clientOptions.httpOptions.baseUrl = t; else throw new Error("HTTP options are not correctly set.") } constructUrl(t, l, a) { const r = [this.getRequestUrlInternal(l)]; return a && r.push(this.getBaseResourcePath()), t !== "" && r.push(t), new URL(`${r.join("/")}`) } shouldPrependVertexProjectPath(t) { return !(this.clientOptions.apiKey || !this.clientOptions.vertexai || t.path.startsWith("projects/") || t.httpMethod === "GET" && t.path.startsWith("publishers/google/models")) } async request(t) { let l = this.clientOptions.httpOptions; t.httpOptions && (l = this.patchHttpOptions(this.clientOptions.httpOptions, t.httpOptions)); const a = this.shouldPrependVertexProjectPath(t), r = this.constructUrl(t.path, l, a); if (t.queryParams) for (const [m, g] of Object.entries(t.queryParams)) r.searchParams.append(m, String(g)); let d = {}; if (t.httpMethod === "GET") { if (t.body && t.body !== "{}") throw new Error("Request body should be empty for GET request, but got non empty request body") } else d.body = t.body; return d = await this.includeExtraHttpOptionsToRequestInit(d, l, r.toString(), t.abortSignal), this.unaryApiCall(r, d, t.httpMethod) } patchHttpOptions(t, l) { const a = JSON.parse(JSON.stringify(t)); for (const [r, d] of Object.entries(l)) typeof d == "object" ? a[r] = Object.assign(Object.assign({}, a[r]), d) : d !== void 0 && (a[r] = d); return a } async requestStream(t) { let l = this.clientOptions.httpOptions; t.httpOptions && (l = this.patchHttpOptions(this.clientOptions.httpOptions, t.httpOptions)); const a = this.shouldPrependVertexProjectPath(t), r = this.constructUrl(t.path, l, a); (!r.searchParams.has("alt") || r.searchParams.get("alt") !== "sse") && r.searchParams.set("alt", "sse"); let d = {}; return d.body = t.body, d = await this.includeExtraHttpOptionsToRequestInit(d, l, r.toString(), t.abortSignal), this.streamApiCall(r, d, t.httpMethod) } async includeExtraHttpOptionsToRequestInit(t, l, a, r) { if (l && l.timeout || r) { const d = new AbortController, m = d.signal; if (l.timeout && (l == null ? void 0 : l.timeout) > 0) { const g = setTimeout(() => d.abort(), l.timeout); g && typeof g.unref == "function" && g.unref() } r && r.addEventListener("abort", () => { d.abort() }), t.signal = m } return l && l.extraBody !== null && pC(t, l.extraBody), t.headers = await this.getHeadersInternal(l, a), t } async unaryApiCall(t, l, a) { return this.apiCall(t.toString(), Object.assign(Object.assign({}, l), { method: a })).then(async r => (await Cp(r), new Eu(r))).catch(r => { throw r instanceof Error ? r : new Error(JSON.stringify(r)) }) } async streamApiCall(t, l, a) { return this.apiCall(t.toString(), Object.assign(Object.assign({}, l), { method: a })).then(async r => (await Cp(r), this.processStreamResponse(r))).catch(r => { throw r instanceof Error ? r : new Error(JSON.stringify(r)) }) } processStreamResponse(t) {
    return Yt(this, arguments, function* () {
      var a; const r = (a = t == null ? void 0 : t.body) === null || a === void 0 ? void 0 : a.getReader(), d = new TextDecoder("utf-8"); if (!r) throw new Error("Response body is empty"); try {
        let m = ""; const g = "data:", v = [`

`, "\r\r", `\r
\r
`]; for (; ;) { const { done: p, value: x } = yield le(r.read()); if (p) { if (m.trim().length > 0) throw new Error("Incomplete JSON segment at the end"); break } const T = d.decode(x, { stream: !0 }); try { const k = JSON.parse(T); if ("error" in k) { const G = JSON.parse(JSON.stringify(k.error)), U = G.status, V = G.code, W = `got status: ${U}. ${JSON.stringify(k)}`; if (V >= 400 && V < 600) throw new Va({ message: W, status: V }) } } catch (k) { if (k.name === "ApiError") throw k } m += T; let _ = -1, A = 0; for (; ;) { _ = -1, A = 0; for (const U of v) { const V = m.indexOf(U); V !== -1 && (_ === -1 || V < _) && (_ = V, A = U.length) } if (_ === -1) break; const k = m.substring(0, _); m = m.substring(_ + A); const G = k.trim(); if (G.startsWith(g)) { const U = G.substring(g.length).trim(); try { const V = new Response(U, { headers: t == null ? void 0 : t.headers, status: t == null ? void 0 : t.status, statusText: t == null ? void 0 : t.statusText }); yield yield le(new Eu(V)) } catch (V) { throw new Error(`exception parsing stream chunk ${U}. ${V}`) } } } }
      } finally { r.releaseLock() }
    })
  } async apiCall(t, l) { return fetch(t, l).catch(a => { throw new Error(`exception ${a} sending request`) }) } getDefaultHeaders() { const t = {}, l = dC + " " + this.clientOptions.userAgentExtra; return t[uC] = l, t[wu] = l, t[sC] = "application/json", t } async getHeadersInternal(t, l) { const a = new Headers; if (t && t.headers) { for (const [r, d] of Object.entries(t.headers)) a.append(r, d); t.timeout && t.timeout > 0 && a.append(rC, String(Math.ceil(t.timeout / 1e3))) } return await this.clientOptions.auth.addAuthHeaders(a, l), a } getFileName(t) { var l; let a = ""; return typeof t == "string" && (a = t.replace(/[/\\]+$/, ""), a = (l = a.split(/[/\\]/).pop()) !== null && l !== void 0 ? l : ""), a } async uploadFile(t, l) { var a; const r = {}; l != null && (r.mimeType = l.mimeType, r.name = l.name, r.displayName = l.displayName), r.name && !r.name.startsWith("files/") && (r.name = `files/${r.name}`); const d = this.clientOptions.uploader, m = await d.stat(t); r.sizeBytes = String(m.size); const g = (a = l == null ? void 0 : l.mimeType) !== null && a !== void 0 ? a : m.type; if (g === void 0 || g === "") throw new Error("Can not determine mimeType. Please provide mimeType in the config."); r.mimeType = g; const v = { file: r }, p = this.getFileName(t), x = J("upload/v1beta/files", v._url), T = await this.fetchUploadUrl(x, r.sizeBytes, r.mimeType, p, v, l == null ? void 0 : l.httpOptions); return d.upload(t, T, this) } async uploadFileToFileSearchStore(t, l, a) { var r; const d = this.clientOptions.uploader, m = await d.stat(l), g = String(m.size), v = (r = a == null ? void 0 : a.mimeType) !== null && r !== void 0 ? r : m.type; if (v === void 0 || v === "") throw new Error("Can not determine mimeType. Please provide mimeType in the config."); const p = `upload/v1beta/${t}:uploadToFileSearchStore`, x = this.getFileName(l), T = {}; a != null && Eg(a, T); const _ = await this.fetchUploadUrl(p, g, v, x, T, a == null ? void 0 : a.httpOptions); return d.uploadToFileSearchStore(l, _, this) } async downloadFile(t) { await this.clientOptions.downloader.download(t, this) } async fetchUploadUrl(t, l, a, r, d, m) { var g; let v = {}; m ? v = m : v = { apiVersion: "", headers: Object.assign({ "Content-Type": "application/json", "X-Goog-Upload-Protocol": "resumable", "X-Goog-Upload-Command": "start", "X-Goog-Upload-Header-Content-Length": `${l}`, "X-Goog-Upload-Header-Content-Type": `${a}` }, r ? { "X-Goog-Upload-File-Name": r } : {}) }; const p = await this.request({ path: t, body: JSON.stringify(d), httpMethod: "POST", httpOptions: v }); if (!p || !(p != null && p.headers)) throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers."); const x = (g = p == null ? void 0 : p.headers) === null || g === void 0 ? void 0 : g["x-goog-upload-url"]; if (x === void 0) throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers"); return x }
} async function Cp(i) { var t; if (i === void 0) throw new Error("response is undefined"); if (!i.ok) { const l = i.status; let a; !((t = i.headers.get("content-type")) === null || t === void 0) && t.includes("application/json") ? a = await i.json() : a = { error: { message: await i.text(), code: i.status, status: i.statusText } }; const r = JSON.stringify(a); throw l >= 400 && l < 600 ? new Va({ message: r, status: l }) : new Error(r) } } function pC(i, t) { if (!t || Object.keys(t).length === 0) return; if (i.body instanceof Blob) { console.warn("includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies."); return } let l = {}; if (typeof i.body == "string" && i.body.length > 0) try { const d = JSON.parse(i.body); if (typeof d == "object" && d !== null && !Array.isArray(d)) l = d; else { console.warn("includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body."); return } } catch { console.warn("includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body."); return } function a(d, m) { const g = Object.assign({}, d); for (const v in m) if (Object.prototype.hasOwnProperty.call(m, v)) { const p = m[v], x = g[v]; p && typeof p == "object" && !Array.isArray(p) && x && typeof x == "object" && !Array.isArray(x) ? g[v] = a(x, p) : (x && p && typeof x != typeof p && console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key "${v}". Original type: ${typeof x}, New type: ${typeof p}. Overwriting.`), g[v] = p) } return g } const r = a(l, t); i.body = JSON.stringify(r) }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const gC = "mcp_used/unknown"; let yC = !1; function Ag(i) { for (const t of i) if (vC(t) || typeof t == "object" && "inputSchema" in t) return !0; return yC } function Cg(i) { var t; const l = (t = i[wu]) !== null && t !== void 0 ? t : ""; i[wu] = (l + ` ${gC}`).trimStart() } function vC(i) { return i !== null && typeof i == "object" && i instanceof Fu } function xC(i) { return Yt(this, arguments, function* (l, a = 100) { let r, d = 0; for (; d < a;) { const m = yield le(l.listTools({ cursor: r })); for (const g of m.tools) yield yield le(g), d++; if (!m.nextCursor) break; r = m.nextCursor } }) } class Fu { constructor(t = [], l) { this.mcpTools = [], this.functionNameToMcpClient = {}, this.mcpClients = t, this.config = l } static create(t, l) { return new Fu(t, l) } async initialize() { var t, l, a, r; if (this.mcpTools.length > 0) return; const d = {}, m = []; for (const x of this.mcpClients) try { for (var g = !0, v = (l = void 0, Jt(xC(x))), p; p = await v.next(), t = p.done, !t; g = !0) { r = p.value, g = !1; const T = r; m.push(T); const _ = T.name; if (d[_]) throw new Error(`Duplicate function name ${_} found in MCP tools. Please ensure function names are unique.`); d[_] = x } } catch (T) { l = { error: T } } finally { try { !g && !t && (a = v.return) && await a.call(v) } finally { if (l) throw l.error } } this.mcpTools = m, this.functionNameToMcpClient = d } async tool() { return await this.initialize(), jS(this.mcpTools, this.config) } async callTool(t) { await this.initialize(); const l = []; for (const a of t) if (a.name in this.functionNameToMcpClient) { const r = this.functionNameToMcpClient[a.name]; let d; this.config.timeout && (d = { timeout: this.config.timeout }); const m = await r.callTool({ name: a.name, arguments: a.args }, void 0, d); l.push({ functionResponse: { name: a.name, response: m.isError ? { error: m } : m } }) } return l } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */async function SC(i, t, l) { const a = new OS; let r; l.data instanceof Blob ? r = JSON.parse(await l.data.text()) : r = JSON.parse(l.data), Object.assign(a, r), t(a) } class TC { constructor(t, l, a) { this.apiClient = t, this.auth = l, this.webSocketFactory = a } async connect(t) { var l, a; if (this.apiClient.isVertexAI()) throw new Error("Live music is not supported for Vertex AI."); console.warn("Live music generation is experimental and may change in future versions."); const r = this.apiClient.getWebsocketBaseUrl(), d = this.apiClient.getApiVersion(), m = AC(this.apiClient.getDefaultHeaders()), g = this.apiClient.getApiKey(), v = `${r}/ws/google.ai.generativelanguage.${d}.GenerativeService.BidiGenerateMusic?key=${g}`; let p = () => { }; const x = new Promise(B => { p = B }), T = t.callbacks, _ = function () { p({}) }, A = this.apiClient, k = { onopen: _, onmessage: B => { SC(A, T.onmessage, B) }, onerror: (l = T == null ? void 0 : T.onerror) !== null && l !== void 0 ? l : function (B) { }, onclose: (a = T == null ? void 0 : T.onclose) !== null && a !== void 0 ? a : function (B) { } }, G = this.webSocketFactory.create(v, EC(m), k); G.connect(), await x; const W = { setup: { model: Se(this.apiClient, t.model) } }; return G.send(JSON.stringify(W)), new _C(G, this.apiClient) } } class _C { constructor(t, l) { this.conn = t, this.apiClient = l } async setWeightedPrompts(t) { if (!t.weightedPrompts || Object.keys(t.weightedPrompts).length === 0) throw new Error("Weighted prompts must be set and contain at least one entry."); const l = K_(t); this.conn.send(JSON.stringify({ clientContent: l })) } async setMusicGenerationConfig(t) { t.musicGenerationConfig || (t.musicGenerationConfig = {}); const l = W_(t); this.conn.send(JSON.stringify(l)) } sendPlaybackControl(t) { const l = { playbackControl: t }; this.conn.send(JSON.stringify(l)) } play() { this.sendPlaybackControl(eo.PLAY) } pause() { this.sendPlaybackControl(eo.PAUSE) } stop() { this.sendPlaybackControl(eo.STOP) } resetContext() { this.sendPlaybackControl(eo.RESET_CONTEXT) } close() { this.conn.close() } } function EC(i) { const t = {}; return i.forEach((l, a) => { t[a] = l }), t } function AC(i) { const t = new Headers; for (const [l, a] of Object.entries(i)) t.append(l, a); return t }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const CC = "FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI."; async function bC(i, t, l) { const a = new BS; let r; l.data instanceof Blob ? r = await l.data.text() : l.data instanceof ArrayBuffer ? r = new TextDecoder().decode(l.data) : r = l.data; const d = JSON.parse(r); if (i.isVertexAI()) { const m = j_(d); Object.assign(a, m) } else Object.assign(a, d); t(a) } class NC { constructor(t, l, a) { this.apiClient = t, this.auth = l, this.webSocketFactory = a, this.music = new TC(this.apiClient, this.auth, this.webSocketFactory) } async connect(t) { var l, a, r, d, m, g; if (t.config && t.config.httpOptions) throw new Error("The Live module does not support httpOptions at request-level in LiveConnectConfig yet. Please use the client-level httpOptions configuration instead."); const v = this.apiClient.getWebsocketBaseUrl(), p = this.apiClient.getApiVersion(); let x; const T = this.apiClient.getHeaders(); t.config && t.config.tools && Ag(t.config.tools) && Cg(T); const _ = IC(T); if (this.apiClient.isVertexAI()) x = `${v}/ws/google.cloud.aiplatform.${p}.LlmBidiService/BidiGenerateContent`, await this.auth.addAuthHeaders(_, x); else { const Z = this.apiClient.getApiKey(); let me = "BidiGenerateContent", Ae = "key"; Z != null && Z.startsWith("auth_tokens/") && (console.warn("Warning: Ephemeral token support is experimental and may change in future versions."), p !== "v1alpha" && console.warn("Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection."), me = "BidiGenerateContentConstrained", Ae = "access_token"), x = `${v}/ws/google.ai.generativelanguage.${p}.GenerativeService.${me}?${Ae}=${Z}` } let A = () => { }; const k = new Promise(Z => { A = Z }), G = t.callbacks, U = function () { var Z; (Z = G == null ? void 0 : G.onopen) === null || Z === void 0 || Z.call(G), A({}) }, V = this.apiClient, W = { onopen: U, onmessage: Z => { bC(V, G.onmessage, Z) }, onerror: (l = G == null ? void 0 : G.onerror) !== null && l !== void 0 ? l : function (Z) { }, onclose: (a = G == null ? void 0 : G.onclose) !== null && a !== void 0 ? a : function (Z) { } }, B = this.webSocketFactory.create(x, RC(_), W); B.connect(), await k; let K = Se(this.apiClient, t.model); if (this.apiClient.isVertexAI() && K.startsWith("publishers/")) { const Z = this.apiClient.getProject(), me = this.apiClient.getLocation(); K = `projects/${Z}/locations/${me}/` + K } let ee = {}; this.apiClient.isVertexAI() && ((r = t.config) === null || r === void 0 ? void 0 : r.responseModalities) === void 0 && (t.config === void 0 ? t.config = { responseModalities: [Ga.AUDIO] } : t.config.responseModalities = [Ga.AUDIO]), !((d = t.config) === null || d === void 0) && d.generationConfig && console.warn("Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025)."); const te = (g = (m = t.config) === null || m === void 0 ? void 0 : m.tools) !== null && g !== void 0 ? g : [], F = []; for (const Z of te) if (this.isCallableTool(Z)) { const me = Z; F.push(await me.tool()) } else F.push(Z); F.length > 0 && (t.config.tools = F); const ge = { model: K, config: t.config, callbacks: t.callbacks }; return this.apiClient.isVertexAI() ? ee = J_(this.apiClient, ge) : ee = Y_(this.apiClient, ge), delete ee.config, B.send(JSON.stringify(ee)), new MC(B, this.apiClient) } isCallableTool(t) { return "callTool" in t && typeof t.callTool == "function" } } const wC = { turnComplete: !0 }; class MC { constructor(t, l) { this.conn = t, this.apiClient = l } tLiveClientContent(t, l) { if (l.turns !== null && l.turns !== void 0) { let a = []; try { a = Ht(l.turns), t.isVertexAI() || (a = a.map(r => Ba(r))) } catch { throw new Error(`Failed to parse client content "turns", type: '${typeof l.turns}'`) } return { clientContent: { turns: a, turnComplete: l.turnComplete } } } return { clientContent: { turnComplete: l.turnComplete } } } tLiveClienttToolResponse(t, l) { let a = []; if (l.functionResponses == null) throw new Error("functionResponses is required."); if (Array.isArray(l.functionResponses) ? a = l.functionResponses : a = [l.functionResponses], a.length === 0) throw new Error("functionResponses is required."); for (const d of a) { if (typeof d != "object" || d === null || !("name" in d) || !("response" in d)) throw new Error(`Could not parse function response, type '${typeof d}'.`); if (!t.isVertexAI() && !("id" in d)) throw new Error(CC) } return { toolResponse: { functionResponses: a } } } sendClientContent(t) { t = Object.assign(Object.assign({}, wC), t); const l = this.tLiveClientContent(this.apiClient, t); this.conn.send(JSON.stringify(l)) } sendRealtimeInput(t) { let l = {}; this.apiClient.isVertexAI() ? l = { realtimeInput: Q_(t) } : l = { realtimeInput: X_(t) }, this.conn.send(JSON.stringify(l)) } sendToolResponse(t) { if (t.functionResponses == null) throw new Error("Tool response parameters are required."); const l = this.tLiveClienttToolResponse(this.apiClient, t); this.conn.send(JSON.stringify(l)) } close() { this.conn.close() } } function RC(i) { const t = {}; return i.forEach((l, a) => { t[a] = l }), t } function IC(i) { const t = new Headers; for (const [l, a] of Object.entries(i)) t.append(l, a); return t }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const bp = 10; function Np(i) { var t, l, a; if (!((t = i == null ? void 0 : i.automaticFunctionCalling) === null || t === void 0) && t.disable) return !0; let r = !1; for (const m of (l = i == null ? void 0 : i.tools) !== null && l !== void 0 ? l : []) if (io(m)) { r = !0; break } if (!r) return !0; const d = (a = i == null ? void 0 : i.automaticFunctionCalling) === null || a === void 0 ? void 0 : a.maximumRemoteCalls; return d && (d < 0 || !Number.isInteger(d)) || d == 0 ? (console.warn("Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:", d), !0) : !1 } function io(i) { return "callTool" in i && typeof i.callTool == "function" } function kC(i) { var t, l, a; return (a = (l = (t = i.config) === null || t === void 0 ? void 0 : t.tools) === null || l === void 0 ? void 0 : l.some(r => io(r))) !== null && a !== void 0 ? a : !1 } function wp(i) { var t; const l = []; return !((t = i == null ? void 0 : i.config) === null || t === void 0) && t.tools && i.config.tools.forEach((a, r) => { if (io(a)) return; const d = a; d.functionDeclarations && d.functionDeclarations.length > 0 && l.push(r) }), l } function Mp(i) { var t; return !(!((t = i == null ? void 0 : i.automaticFunctionCalling) === null || t === void 0) && t.ignoreCallHistory) }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class DC extends vn { constructor(t) { super(), this.apiClient = t, this.generateContent = async l => { var a, r, d, m, g; const v = await this.processParamsMaybeAddMcpUsage(l); if (this.maybeMoveToResponseJsonSchem(l), !kC(l) || Np(l.config)) return await this.generateContentInternal(v); const p = wp(l); if (p.length > 0) { const G = p.map(U => `tools[${U}]`).join(", "); throw new Error(`Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations is not yet supported. Incompatible tools found at ${G}.`) } let x, T; const _ = Ht(v.contents), A = (d = (r = (a = v.config) === null || a === void 0 ? void 0 : a.automaticFunctionCalling) === null || r === void 0 ? void 0 : r.maximumRemoteCalls) !== null && d !== void 0 ? d : bp; let k = 0; for (; k < A && (x = await this.generateContentInternal(v), !(!x.functionCalls || x.functionCalls.length === 0));) { const G = x.candidates[0].content, U = []; for (const V of (g = (m = l.config) === null || m === void 0 ? void 0 : m.tools) !== null && g !== void 0 ? g : []) if (io(V)) { const B = await V.callTool(x.functionCalls); U.push(...B) } k++, T = { role: "user", parts: U }, v.contents = Ht(v.contents), v.contents.push(G), v.contents.push(T), Mp(v.config) && (_.push(G), _.push(T)) } return Mp(v.config) && (x.automaticFunctionCallingHistory = _), x }, this.generateContentStream = async l => { var a, r, d, m, g; if (this.maybeMoveToResponseJsonSchem(l), Np(l.config)) { const T = await this.processParamsMaybeAddMcpUsage(l); return await this.generateContentStreamInternal(T) } const v = wp(l); if (v.length > 0) { const T = v.map(_ => `tools[${_}]`).join(", "); throw new Error(`Incompatible tools found at ${T}. Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations" is not yet supported.`) } const p = (d = (r = (a = l == null ? void 0 : l.config) === null || a === void 0 ? void 0 : a.toolConfig) === null || r === void 0 ? void 0 : r.functionCallingConfig) === null || d === void 0 ? void 0 : d.streamFunctionCallArguments, x = (g = (m = l == null ? void 0 : l.config) === null || m === void 0 ? void 0 : m.automaticFunctionCalling) === null || g === void 0 ? void 0 : g.disable; if (p && !x) throw new Error("Running in streaming mode with 'streamFunctionCallArguments' enabled, this feature is not compatible with automatic function calling (AFC). Please set 'config.automaticFunctionCalling.disable' to true to disable AFC or leave 'config.toolConfig.functionCallingConfig.streamFunctionCallArguments' to be undefined or set to false to disable streaming function call arguments feature."); return await this.processAfcStream(l) }, this.generateImages = async l => await this.generateImagesInternal(l).then(a => { var r; let d; const m = []; if (a != null && a.generatedImages) for (const v of a.generatedImages) v && (v != null && v.safetyAttributes) && ((r = v == null ? void 0 : v.safetyAttributes) === null || r === void 0 ? void 0 : r.contentType) === "Positive Prompt" ? d = v == null ? void 0 : v.safetyAttributes : m.push(v); let g; return d ? g = { generatedImages: m, positivePromptSafetyAttributes: d, sdkHttpResponse: a.sdkHttpResponse } : g = { generatedImages: m, sdkHttpResponse: a.sdkHttpResponse }, g }), this.list = async l => { var a; const m = { config: Object.assign(Object.assign({}, { queryBase: !0 }), l == null ? void 0 : l.config) }; if (this.apiClient.isVertexAI() && !m.config.queryBase) { if (!((a = m.config) === null || a === void 0) && a.filter) throw new Error("Filtering tuned models list for Vertex AI is not currently supported"); m.config.filter = "labels.tune-type:*" } return new mi(yn.PAGED_ITEM_MODELS, g => this.listInternal(g), await this.listInternal(m), m) }, this.editImage = async l => { const a = { model: l.model, prompt: l.prompt, referenceImages: [], config: l.config }; return l.referenceImages && l.referenceImages && (a.referenceImages = l.referenceImages.map(r => r.toReferenceImageAPI())), await this.editImageInternal(a) }, this.upscaleImage = async l => { let a = { numberOfImages: 1, mode: "upscale" }; l.config && (a = Object.assign(Object.assign({}, a), l.config)); const r = { model: l.model, image: l.image, upscaleFactor: l.upscaleFactor, config: a }; return await this.upscaleImageInternal(r) }, this.generateVideos = async l => { var a, r, d, m, g, v; if ((l.prompt || l.image || l.video) && l.source) throw new Error("Source and prompt/image/video are mutually exclusive. Please only use source."); return this.apiClient.isVertexAI() || (!((a = l.video) === null || a === void 0) && a.uri && (!((r = l.video) === null || r === void 0) && r.videoBytes) ? l.video = { uri: l.video.uri, mimeType: l.video.mimeType } : !((m = (d = l.source) === null || d === void 0 ? void 0 : d.video) === null || m === void 0) && m.uri && (!((v = (g = l.source) === null || g === void 0 ? void 0 : g.video) === null || v === void 0) && v.videoBytes) && (l.source.video = { uri: l.source.video.uri, mimeType: l.source.video.mimeType })), await this.generateVideosInternal(l) } } maybeMoveToResponseJsonSchem(t) { t.config && t.config.responseSchema && (t.config.responseJsonSchema || Object.keys(t.config.responseSchema).includes("$schema") && (t.config.responseJsonSchema = t.config.responseSchema, delete t.config.responseSchema)) } async processParamsMaybeAddMcpUsage(t) { var l, a, r; const d = (l = t.config) === null || l === void 0 ? void 0 : l.tools; if (!d) return t; const m = await Promise.all(d.map(async v => io(v) ? await v.tool() : v)), g = { model: t.model, contents: t.contents, config: Object.assign(Object.assign({}, t.config), { tools: m }) }; if (g.config.tools = m, t.config && t.config.tools && Ag(t.config.tools)) { const v = (r = (a = t.config.httpOptions) === null || a === void 0 ? void 0 : a.headers) !== null && r !== void 0 ? r : {}; let p = Object.assign({}, v); Object.keys(p).length === 0 && (p = this.apiClient.getDefaultHeaders()), Cg(p), g.config.httpOptions = Object.assign(Object.assign({}, t.config.httpOptions), { headers: p }) } return g } async initAfcToolsMap(t) { var l, a, r; const d = new Map; for (const m of (a = (l = t.config) === null || l === void 0 ? void 0 : l.tools) !== null && a !== void 0 ? a : []) if (io(m)) { const g = m, v = await g.tool(); for (const p of (r = v.functionDeclarations) !== null && r !== void 0 ? r : []) { if (!p.name) throw new Error("Function declaration name is required."); if (d.has(p.name)) throw new Error(`Duplicate tool declaration name: ${p.name}`); d.set(p.name, g) } } return d } async processAfcStream(t) { var l, a, r; const d = (r = (a = (l = t.config) === null || l === void 0 ? void 0 : l.automaticFunctionCalling) === null || a === void 0 ? void 0 : a.maximumRemoteCalls) !== null && r !== void 0 ? r : bp; let m = !1, g = 0; const v = await this.initAfcToolsMap(t); return (function (p, x, T) { return Yt(this, arguments, function* () { for (var _, A, k, G, U, V; g < d;) { m && (g++, m = !1); const ee = yield le(p.processParamsMaybeAddMcpUsage(T)), te = yield le(p.generateContentStreamInternal(ee)), F = [], ge = []; try { for (var W = !0, B = (A = void 0, Jt(te)), K; K = yield le(B.next()), _ = K.done, !_; W = !0) { G = K.value, W = !1; const Z = G; if (yield yield le(Z), Z.candidates && (!((U = Z.candidates[0]) === null || U === void 0) && U.content)) { ge.push(Z.candidates[0].content); for (const me of (V = Z.candidates[0].content.parts) !== null && V !== void 0 ? V : []) if (g < d && me.functionCall) { if (!me.functionCall.name) throw new Error("Function call name was not returned by the model."); if (x.has(me.functionCall.name)) { const Ae = yield le(x.get(me.functionCall.name).callTool([me.functionCall])); F.push(...Ae) } else throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${x.keys()}, mising tool: ${me.functionCall.name}`) } } } } catch (Z) { A = { error: Z } } finally { try { !W && !_ && (k = B.return) && (yield le(k.call(B))) } finally { if (A) throw A.error } } if (F.length > 0) { m = !0; const Z = new ol; Z.candidates = [{ content: { role: "user", parts: F } }], yield yield le(Z); const me = []; me.push(...ge), me.push({ role: "user", parts: F }); const Ae = Ht(T.contents).concat(me); T.contents = Ae } else break } }) })(this, v, t) } async generateContentInternal(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = _p(this.apiClient, t); return g = J("{model}:generateContent", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = Ap(x), _ = new ol; return Object.assign(_, T), _ }) } else { const p = Tp(this.apiClient, t); return g = J("{model}:generateContent", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "POST", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = Ep(x), _ = new ol; return Object.assign(_, T), _ }) } } async generateContentStreamInternal(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = _p(this.apiClient, t); return g = J("{model}:streamGenerateContent?alt=sse", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.requestStream({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }), m.then(function (T) { return Yt(this, arguments, function* () { var _, A, k, G; try { for (var U = !0, V = Jt(T), W; W = yield le(V.next()), _ = W.done, !_; U = !0) { G = W.value, U = !1; const B = G, K = Ap(yield le(B.json())); K.sdkHttpResponse = { headers: B.headers }; const ee = new ol; Object.assign(ee, K), yield yield le(ee) } } catch (B) { A = { error: B } } finally { try { !U && !_ && (k = V.return) && (yield le(k.call(V))) } finally { if (A) throw A.error } } }) }) } else { const p = Tp(this.apiClient, t); return g = J("{model}:streamGenerateContent?alt=sse", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.requestStream({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "POST", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }), m.then(function (T) { return Yt(this, arguments, function* () { var _, A, k, G; try { for (var U = !0, V = Jt(T), W; W = yield le(V.next()), _ = W.done, !_; U = !0) { G = W.value, U = !1; const B = G, K = Ep(yield le(B.json())); K.sdkHttpResponse = { headers: B.headers }; const ee = new ol; Object.assign(ee, K), yield yield le(ee) } } catch (B) { A = { error: B } } finally { try { !U && !_ && (k = V.return) && (yield le(k.call(V))) } finally { if (A) throw A.error } } }) }) } } async embedContent(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = NE(this.apiClient, t); return g = J("{model}:predict", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = ME(x), _ = new op; return Object.assign(_, T), _ }) } else { const p = bE(this.apiClient, t); return g = J("{model}:batchEmbedContents", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "POST", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = wE(x), _ = new op; return Object.assign(_, T), _ }) } } async generateImagesInternal(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = PE(this.apiClient, t); return g = J("{model}:predict", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = BE(x), _ = new lp; return Object.assign(_, T), _ }) } else { const p = HE(this.apiClient, t); return g = J("{model}:predict", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "POST", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = VE(x), _ = new lp; return Object.assign(_, T), _ }) } } async editImageInternal(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) { const g = _E(this.apiClient, t); return d = J("{model}:predict", g._url), m = g._query, delete g._url, delete g._query, r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(g), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(v => v.json().then(p => { const x = p; return x.sdkHttpResponse = { headers: v.headers }, x })), r.then(v => { const p = EE(v), x = new IS; return Object.assign(x, p), x }) } else throw new Error("This method is only supported by the Vertex AI.") } async upscaleImageInternal(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) { const g = PA(this.apiClient, t); return d = J("{model}:predict", g._url), m = g._query, delete g._url, delete g._query, r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(g), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(v => v.json().then(p => { const x = p; return x.sdkHttpResponse = { headers: v.headers }, x })), r.then(v => { const p = VA(v), x = new kS; return Object.assign(x, p), x }) } else throw new Error("This method is only supported by the Vertex AI.") } async recontextImage(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) { const g = TA(this.apiClient, t); return d = J("{model}:predict", g._url), m = g._query, delete g._url, delete g._query, r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(g), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(v => v.json()), r.then(v => { const p = _A(v), x = new DS; return Object.assign(x, p), x }) } else throw new Error("This method is only supported by the Vertex AI.") } async segmentImage(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) { const g = wA(this.apiClient, t); return d = J("{model}:predict", g._url), m = g._query, delete g._url, delete g._query, r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(g), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(v => v.json()), r.then(v => { const p = MA(v), x = new US; return Object.assign(x, p), x }) } else throw new Error("This method is only supported by the Vertex AI.") } async get(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = lA(this.apiClient, t); return g = J("{name}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "GET", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json()), m.then(x => Nu(x)) } else { const p = oA(this.apiClient, t); return g = J("{name}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "GET", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json()), m.then(x => bu(x)) } } async listInternal(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = hA(this.apiClient, t); return g = J("{models_url}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "GET", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = gA(x), _ = new ap; return Object.assign(_, T), _ }) } else { const p = mA(this.apiClient, t); return g = J("{models_url}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "GET", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = pA(x), _ = new ap; return Object.assign(_, T), _ }) } } async update(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = qA(this.apiClient, t); return g = J("{model}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "PATCH", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json()), m.then(x => Nu(x)) } else { const p = zA(this.apiClient, t); return g = J("{name}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "PATCH", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json()), m.then(x => bu(x)) } } async delete(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = vE(this.apiClient, t); return g = J("{name}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "DELETE", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = SE(x), _ = new sp; return Object.assign(_, T), _ }) } else { const p = yE(this.apiClient, t); return g = J("{name}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "DELETE", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = xE(x), _ = new sp; return Object.assign(_, T), _ }) } } async countTokens(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = hE(this.apiClient, t); return g = J("{model}:countTokens", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = gE(x), _ = new rp; return Object.assign(_, T), _ }) } else { const p = mE(this.apiClient, t); return g = J("{model}:countTokens", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "POST", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = pE(x), _ = new rp; return Object.assign(_, T), _ }) } } async computeTokens(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) { const g = aE(this.apiClient, t); return d = J("{model}:computeTokens", g._url), m = g._query, delete g._url, delete g._query, r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(g), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(v => v.json().then(p => { const x = p; return x.sdkHttpResponse = { headers: v.headers }, x })), r.then(v => { const p = sE(v), x = new GS; return Object.assign(x, p), x }) } else throw new Error("This method is only supported by the Vertex AI.") } async generateVideosInternal(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = KE(this.apiClient, t); return g = J("{model}:predictLongRunning", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json()), m.then(x => { const T = JE(x), _ = new La; return Object.assign(_, T), _ }) } else { const p = WE(this.apiClient, t); return g = J("{model}:predictLongRunning", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "POST", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json()), m.then(x => { const T = YE(x), _ = new La; return Object.assign(_, T), _ }) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class UC extends vn { constructor(t) { super(), this.apiClient = t } async getVideosOperation(t) { const l = t.operation, a = t.config; if (l.name === void 0 || l.name === "") throw new Error("Operation name is required."); if (this.apiClient.isVertexAI()) { const r = l.name.split("/operations/")[0]; let d; a && "httpOptions" in a && (d = a.httpOptions); const m = await this.fetchPredictVideosOperationInternal({ operationName: l.name, resourceName: r, config: { httpOptions: d } }); return l._fromAPIResponse({ apiResponse: m, _isVertexAI: !0 }) } else { const r = await this.getVideosOperationInternal({ operationName: l.name, config: a }); return l._fromAPIResponse({ apiResponse: r, _isVertexAI: !1 }) } } async get(t) { const l = t.operation, a = t.config; if (l.name === void 0 || l.name === "") throw new Error("Operation name is required."); if (this.apiClient.isVertexAI()) { const r = l.name.split("/operations/")[0]; let d; a && "httpOptions" in a && (d = a.httpOptions); const m = await this.fetchPredictVideosOperationInternal({ operationName: l.name, resourceName: r, config: { httpOptions: d } }); return l._fromAPIResponse({ apiResponse: m, _isVertexAI: !0 }) } else { const r = await this.getVideosOperationInternal({ operationName: l.name, config: a }); return l._fromAPIResponse({ apiResponse: r, _isVertexAI: !1 }) } } async getVideosOperationInternal(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = CS(t); return g = J("{operationName}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "GET", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json()), m } else { const p = AS(t); return g = J("{operationName}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "GET", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json()), m } } async fetchPredictVideosOperationInternal(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) { const g = yS(t); return d = J("{resourceName}:fetchPredictOperation", g._url), m = g._query, delete g._url, delete g._query, r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(g), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(v => v.json()), r } else throw new Error("This method is only supported by the Vertex AI.") } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function GC(i) { const t = {}, l = u(i, ["data"]); if (l != null && c(t, ["data"], l), u(i, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const a = u(i, ["mimeType"]); return a != null && c(t, ["mimeType"], a), t } function LC(i) { const t = {}, l = u(i, ["parts"]); if (l != null) { let r = l; Array.isArray(r) && (r = r.map(d => YC(d))), c(t, ["parts"], r) } const a = u(i, ["role"]); return a != null && c(t, ["role"], a), t } function zC(i, t, l) { const a = {}, r = u(t, ["expireTime"]); l !== void 0 && r != null && c(l, ["expireTime"], r); const d = u(t, ["newSessionExpireTime"]); l !== void 0 && d != null && c(l, ["newSessionExpireTime"], d); const m = u(t, ["uses"]); l !== void 0 && m != null && c(l, ["uses"], m); const g = u(t, ["liveConnectConstraints"]); l !== void 0 && g != null && c(l, ["bidiGenerateContentSetup"], FC(i, g)); const v = u(t, ["lockAdditionalFields"]); return l !== void 0 && v != null && c(l, ["fieldMask"], v), a } function qC(i, t) { const l = {}, a = u(t, ["config"]); return a != null && c(l, ["config"], zC(i, a, l)), l } function HC(i) { const t = {}; if (u(i, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const l = u(i, ["fileUri"]); l != null && c(t, ["fileUri"], l); const a = u(i, ["mimeType"]); return a != null && c(t, ["mimeType"], a), t } function PC(i) { const t = {}, l = u(i, ["id"]); l != null && c(t, ["id"], l); const a = u(i, ["args"]); a != null && c(t, ["args"], a); const r = u(i, ["name"]); if (r != null && c(t, ["name"], r), u(i, ["partialArgs"]) !== void 0) throw new Error("partialArgs parameter is not supported in Gemini API."); if (u(i, ["willContinue"]) !== void 0) throw new Error("willContinue parameter is not supported in Gemini API."); return t } function VC(i) { const t = {}; if (u(i, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API."); const l = u(i, ["enableWidget"]); return l != null && c(t, ["enableWidget"], l), t } function BC(i) { const t = {}; if (u(i, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API."); if (u(i, ["blockingConfidence"]) !== void 0) throw new Error("blockingConfidence parameter is not supported in Gemini API."); const l = u(i, ["timeRangeFilter"]); return l != null && c(t, ["timeRangeFilter"], l), t } function OC(i, t) { const l = {}, a = u(i, ["generationConfig"]); t !== void 0 && a != null && c(t, ["setup", "generationConfig"], a); const r = u(i, ["responseModalities"]); t !== void 0 && r != null && c(t, ["setup", "generationConfig", "responseModalities"], r); const d = u(i, ["temperature"]); t !== void 0 && d != null && c(t, ["setup", "generationConfig", "temperature"], d); const m = u(i, ["topP"]); t !== void 0 && m != null && c(t, ["setup", "generationConfig", "topP"], m); const g = u(i, ["topK"]); t !== void 0 && g != null && c(t, ["setup", "generationConfig", "topK"], g); const v = u(i, ["maxOutputTokens"]); t !== void 0 && v != null && c(t, ["setup", "generationConfig", "maxOutputTokens"], v); const p = u(i, ["mediaResolution"]); t !== void 0 && p != null && c(t, ["setup", "generationConfig", "mediaResolution"], p); const x = u(i, ["seed"]); t !== void 0 && x != null && c(t, ["setup", "generationConfig", "seed"], x); const T = u(i, ["speechConfig"]); t !== void 0 && T != null && c(t, ["setup", "generationConfig", "speechConfig"], Ou(T)); const _ = u(i, ["thinkingConfig"]); t !== void 0 && _ != null && c(t, ["setup", "generationConfig", "thinkingConfig"], _); const A = u(i, ["enableAffectiveDialog"]); t !== void 0 && A != null && c(t, ["setup", "generationConfig", "enableAffectiveDialog"], A); const k = u(i, ["systemInstruction"]); t !== void 0 && k != null && c(t, ["setup", "systemInstruction"], LC(ot(k))); const G = u(i, ["tools"]); if (t !== void 0 && G != null) { let te = lo(G); Array.isArray(te) && (te = te.map(F => WC(oo(F)))), c(t, ["setup", "tools"], te) } const U = u(i, ["sessionResumption"]); t !== void 0 && U != null && c(t, ["setup", "sessionResumption"], JC(U)); const V = u(i, ["inputAudioTranscription"]); t !== void 0 && V != null && c(t, ["setup", "inputAudioTranscription"], V); const W = u(i, ["outputAudioTranscription"]); t !== void 0 && W != null && c(t, ["setup", "outputAudioTranscription"], W); const B = u(i, ["realtimeInputConfig"]); t !== void 0 && B != null && c(t, ["setup", "realtimeInputConfig"], B); const K = u(i, ["contextWindowCompression"]); t !== void 0 && K != null && c(t, ["setup", "contextWindowCompression"], K); const ee = u(i, ["proactivity"]); if (t !== void 0 && ee != null && c(t, ["setup", "proactivity"], ee), u(i, ["explicitVadSignal"]) !== void 0) throw new Error("explicitVadSignal parameter is not supported in Gemini API."); return l } function FC(i, t) { const l = {}, a = u(t, ["model"]); a != null && c(l, ["setup", "model"], Se(i, a)); const r = u(t, ["config"]); return r != null && c(l, ["config"], OC(r, l)), l } function YC(i) { const t = {}, l = u(i, ["mediaResolution"]); l != null && c(t, ["mediaResolution"], l); const a = u(i, ["codeExecutionResult"]); a != null && c(t, ["codeExecutionResult"], a); const r = u(i, ["executableCode"]); r != null && c(t, ["executableCode"], r); const d = u(i, ["fileData"]); d != null && c(t, ["fileData"], HC(d)); const m = u(i, ["functionCall"]); m != null && c(t, ["functionCall"], PC(m)); const g = u(i, ["functionResponse"]); g != null && c(t, ["functionResponse"], g); const v = u(i, ["inlineData"]); v != null && c(t, ["inlineData"], GC(v)); const p = u(i, ["text"]); p != null && c(t, ["text"], p); const x = u(i, ["thought"]); x != null && c(t, ["thought"], x); const T = u(i, ["thoughtSignature"]); T != null && c(t, ["thoughtSignature"], T); const _ = u(i, ["videoMetadata"]); return _ != null && c(t, ["videoMetadata"], _), t } function JC(i) { const t = {}, l = u(i, ["handle"]); if (l != null && c(t, ["handle"], l), u(i, ["transparent"]) !== void 0) throw new Error("transparent parameter is not supported in Gemini API."); return t } function WC(i) { const t = {}; if (u(i, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API."); const l = u(i, ["computerUse"]); l != null && c(t, ["computerUse"], l); const a = u(i, ["fileSearch"]); a != null && c(t, ["fileSearch"], a); const r = u(i, ["codeExecution"]); if (r != null && c(t, ["codeExecution"], r), u(i, ["enterpriseWebSearch"]) !== void 0) throw new Error("enterpriseWebSearch parameter is not supported in Gemini API."); const d = u(i, ["functionDeclarations"]); if (d != null) { let x = d; Array.isArray(x) && (x = x.map(T => T)), c(t, ["functionDeclarations"], x) } const m = u(i, ["googleMaps"]); m != null && c(t, ["googleMaps"], VC(m)); const g = u(i, ["googleSearch"]); g != null && c(t, ["googleSearch"], BC(g)); const v = u(i, ["googleSearchRetrieval"]); v != null && c(t, ["googleSearchRetrieval"], v); const p = u(i, ["urlContext"]); return p != null && c(t, ["urlContext"], p), t }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function KC(i) { const t = []; for (const l in i) if (Object.prototype.hasOwnProperty.call(i, l)) { const a = i[l]; if (typeof a == "object" && a != null && Object.keys(a).length > 0) { const r = Object.keys(a).map(d => `${l}.${d}`); t.push(...r) } else t.push(l) } return t.join(",") } function XC(i, t) { let l = null; const a = i.bidiGenerateContentSetup; if (typeof a == "object" && a !== null && "setup" in a) { const d = a.setup; typeof d == "object" && d !== null ? (i.bidiGenerateContentSetup = d, l = d) : delete i.bidiGenerateContentSetup } else a !== void 0 && delete i.bidiGenerateContentSetup; const r = i.fieldMask; if (l) { const d = KC(l); if (Array.isArray(t == null ? void 0 : t.lockAdditionalFields) && (t == null ? void 0 : t.lockAdditionalFields.length) === 0) d ? i.fieldMask = d : delete i.fieldMask; else if (t != null && t.lockAdditionalFields && t.lockAdditionalFields.length > 0 && r !== null && Array.isArray(r) && r.length > 0) { const m = ["temperature", "topK", "topP", "maxOutputTokens", "responseModalities", "seed", "speechConfig"]; let g = []; r.length > 0 && (g = r.map(p => m.includes(p) ? `generationConfig.${p}` : p)); const v = []; d && v.push(d), g.length > 0 && v.push(...g), v.length > 0 ? i.fieldMask = v.join(",") : delete i.fieldMask } else delete i.fieldMask } else r !== null && Array.isArray(r) && r.length > 0 ? i.fieldMask = r.join(",") : delete i.fieldMask; return i } class QC extends vn { constructor(t) { super(), this.apiClient = t } async create(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) throw new Error("The client.tokens.create method is only supported by the Gemini Developer API."); { const g = qC(this.apiClient, t); d = J("auth_tokens", g._url), m = g._query, delete g.config, delete g._url, delete g._query; const v = XC(g, t.config); return r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(v), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(p => p.json()), r.then(p => p) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function jC(i, t) { const l = {}, a = u(i, ["force"]); return t !== void 0 && a != null && c(t, ["_query", "force"], a), l } function ZC(i) { const t = {}, l = u(i, ["name"]); l != null && c(t, ["_url", "name"], l); const a = u(i, ["config"]); return a != null && jC(a, t), t } function $C(i) { const t = {}, l = u(i, ["name"]); return l != null && c(t, ["_url", "name"], l), t } function e1(i, t) { const l = {}, a = u(i, ["pageSize"]); t !== void 0 && a != null && c(t, ["_query", "pageSize"], a); const r = u(i, ["pageToken"]); return t !== void 0 && r != null && c(t, ["_query", "pageToken"], r), l } function t1(i) { const t = {}, l = u(i, ["parent"]); l != null && c(t, ["_url", "parent"], l); const a = u(i, ["config"]); return a != null && e1(a, t), t } function n1(i) { const t = {}, l = u(i, ["sdkHttpResponse"]); l != null && c(t, ["sdkHttpResponse"], l); const a = u(i, ["nextPageToken"]); a != null && c(t, ["nextPageToken"], a); const r = u(i, ["documents"]); if (r != null) { let d = r; Array.isArray(d) && (d = d.map(m => m)), c(t, ["documents"], d) } return t }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class i1 extends vn { constructor(t) { super(), this.apiClient = t, this.list = async l => new mi(yn.PAGED_ITEM_DOCUMENTS, a => this.listInternal({ parent: l.parent, config: a.config }), await this.listInternal(l), l) } async get(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const g = $C(t); return d = J("{name}", g._url), m = g._query, delete g._url, delete g._query, r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(g), httpMethod: "GET", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(v => v.json()), r.then(v => v) } } async delete(t) { var l, a; let r = "", d = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const m = ZC(t); r = J("{name}", m._url), d = m._query, delete m._url, delete m._query, await this.apiClient.request({ path: r, queryParams: d, body: JSON.stringify(m), httpMethod: "DELETE", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }) } } async listInternal(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const g = t1(t); return d = J("{parent}/documents", g._url), m = g._query, delete g._url, delete g._query, r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(g), httpMethod: "GET", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(v => v.json()), r.then(v => { const p = n1(v), x = new LS; return Object.assign(x, p), x }) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class o1 extends vn { constructor(t, l = new i1(t)) { super(), this.apiClient = t, this.documents = l, this.list = async (a = {}) => new mi(yn.PAGED_ITEM_FILE_SEARCH_STORES, r => this.listInternal(r), await this.listInternal(a), a) } async uploadToFileSearchStore(t) { if (this.apiClient.isVertexAI()) throw new Error("Vertex AI does not support uploading files to a file search store."); return this.apiClient.uploadFileToFileSearchStore(t.fileSearchStoreName, t.file, t.config) } async create(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const g = KA(t); return d = J("fileSearchStores", g._url), m = g._query, delete g._url, delete g._query, r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(g), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(v => v.json()), r.then(v => v) } } async get(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const g = jA(t); return d = J("{name}", g._url), m = g._query, delete g._url, delete g._query, r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(g), httpMethod: "GET", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(v => v.json()), r.then(v => v) } } async delete(t) { var l, a; let r = "", d = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const m = QA(t); r = J("{name}", m._url), d = m._query, delete m._url, delete m._query, await this.apiClient.request({ path: r, queryParams: d, body: JSON.stringify(m), httpMethod: "DELETE", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }) } } async listInternal(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const g = iC(t); return d = J("fileSearchStores", g._url), m = g._query, delete g._url, delete g._query, r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(g), httpMethod: "GET", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(v => v.json()), r.then(v => { const p = oC(v), x = new zS; return Object.assign(x, p), x }) } } async uploadToFileSearchStoreInternal(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const g = lC(t); return d = J("upload/v1beta/{file_search_store_name}:uploadToFileSearchStore", g._url), m = g._query, delete g._url, delete g._query, r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(g), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(v => v.json()), r.then(v => { const p = aC(v), x = new qS; return Object.assign(x, p), x }) } } async importFile(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const g = eC(t); return d = J("{file_search_store_name}:importFile", g._url), m = g._query, delete g._url, delete g._query, r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(g), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(v => v.json()), r.then(v => { const p = $A(v), x = new qu; return Object.assign(x, p), x }) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */let bg = function () { const { crypto: i } = globalThis; if (i != null && i.randomUUID) return bg = i.randomUUID.bind(i), i.randomUUID(); const t = new Uint8Array(1), l = i ? () => i.getRandomValues(t)[0] : () => Math.random() * 255 & 255; return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, a => (+a ^ l() & 15 >> +a / 4).toString(16)) }; const l1 = () => bg();/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Mu(i) { return typeof i == "object" && i !== null && ("name" in i && i.name === "AbortError" || "message" in i && String(i.message).includes("FetchRequestCanceledException")) } const Ru = i => { if (i instanceof Error) return i; if (typeof i == "object" && i !== null) { try { if (Object.prototype.toString.call(i) === "[object Error]") { const t = new Error(i.message, i.cause ? { cause: i.cause } : {}); return i.stack && (t.stack = i.stack), i.cause && !t.cause && (t.cause = i.cause), i.name && (t.name = i.name), t } } catch { } try { return new Error(JSON.stringify(i)) } catch { } } return new Error(i) };/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Pt extends Error { } class rt extends Pt { constructor(t, l, a, r) { super(`${rt.makeMessage(t, l, a)}`), this.status = t, this.headers = r, this.error = l } static makeMessage(t, l, a) { const r = l != null && l.message ? typeof l.message == "string" ? l.message : JSON.stringify(l.message) : l ? JSON.stringify(l) : a; return t && r ? `${t} ${r}` : t ? `${t} status code (no body)` : r || "(no status code or body)" } static generate(t, l, a, r) { if (!t || !r) return new Ya({ message: a, cause: Ru(l) }); const d = l; return t === 400 ? new wg(t, d, a, r) : t === 401 ? new Mg(t, d, a, r) : t === 403 ? new Rg(t, d, a, r) : t === 404 ? new Ig(t, d, a, r) : t === 409 ? new kg(t, d, a, r) : t === 422 ? new Dg(t, d, a, r) : t === 429 ? new Ug(t, d, a, r) : t >= 500 ? new Gg(t, d, a, r) : new rt(t, d, a, r) } } class Iu extends rt { constructor({ message: t } = {}) { super(void 0, void 0, t || "Request was aborted.", void 0) } } class Ya extends rt { constructor({ message: t, cause: l }) { super(void 0, void 0, t || "Connection error.", void 0), l && (this.cause = l) } } class Ng extends Ya { constructor({ message: t } = {}) { super({ message: t ?? "Request timed out." }) } } class wg extends rt { } class Mg extends rt { } class Rg extends rt { } class Ig extends rt { } class kg extends rt { } class Dg extends rt { } class Ug extends rt { } class Gg extends rt { }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const a1 = /^[a-z][a-z0-9+.-]*:/i, s1 = i => a1.test(i); let ku = i => (ku = Array.isArray, ku(i)); const r1 = ku; let u1 = r1; const Rp = u1; function c1(i) { if (!i) return !0; for (const t in i) return !1; return !0 } function d1(i, t) { return Object.prototype.hasOwnProperty.call(i, t) } const f1 = (i, t) => { if (typeof t != "number" || !Number.isInteger(t)) throw new Pt(`${i} must be an integer`); if (t < 0) throw new Pt(`${i} must be a positive integer`); return t }, m1 = i => { try { return JSON.parse(i) } catch { return } };/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const h1 = i => new Promise(t => setTimeout(t, i));/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const $i = "0.0.1";/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function p1() { return typeof Deno < "u" && Deno.build != null ? "deno" : typeof EdgeRuntime < "u" ? "edge" : Object.prototype.toString.call(typeof globalThis.process < "u" ? globalThis.process : 0) === "[object process]" ? "node" : "unknown" } const g1 = () => { var i, t, l, a, r; const d = p1(); if (d === "deno") return { "X-Stainless-Lang": "js", "X-Stainless-Package-Version": $i, "X-Stainless-OS": kp(Deno.build.os), "X-Stainless-Arch": Ip(Deno.build.arch), "X-Stainless-Runtime": "deno", "X-Stainless-Runtime-Version": typeof Deno.version == "string" ? Deno.version : (t = (i = Deno.version) === null || i === void 0 ? void 0 : i.deno) !== null && t !== void 0 ? t : "unknown" }; if (typeof EdgeRuntime < "u") return { "X-Stainless-Lang": "js", "X-Stainless-Package-Version": $i, "X-Stainless-OS": "Unknown", "X-Stainless-Arch": `other:${EdgeRuntime}`, "X-Stainless-Runtime": "edge", "X-Stainless-Runtime-Version": globalThis.process.version }; if (d === "node") return { "X-Stainless-Lang": "js", "X-Stainless-Package-Version": $i, "X-Stainless-OS": kp((l = globalThis.process.platform) !== null && l !== void 0 ? l : "unknown"), "X-Stainless-Arch": Ip((a = globalThis.process.arch) !== null && a !== void 0 ? a : "unknown"), "X-Stainless-Runtime": "node", "X-Stainless-Runtime-Version": (r = globalThis.process.version) !== null && r !== void 0 ? r : "unknown" }; const m = y1(); return m ? { "X-Stainless-Lang": "js", "X-Stainless-Package-Version": $i, "X-Stainless-OS": "Unknown", "X-Stainless-Arch": "unknown", "X-Stainless-Runtime": `browser:${m.browser}`, "X-Stainless-Runtime-Version": m.version } : { "X-Stainless-Lang": "js", "X-Stainless-Package-Version": $i, "X-Stainless-OS": "Unknown", "X-Stainless-Arch": "unknown", "X-Stainless-Runtime": "unknown", "X-Stainless-Runtime-Version": "unknown" } }; function y1() { if (typeof navigator > "u" || !navigator) return null; const i = [{ key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ }, { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ }, { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ }, { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ }, { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ }, { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }]; for (const { key: t, pattern: l } of i) { const a = l.exec(navigator.userAgent); if (a) { const r = a[1] || 0, d = a[2] || 0, m = a[3] || 0; return { browser: t, version: `${r}.${d}.${m}` } } } return null } const Ip = i => i === "x32" ? "x32" : i === "x86_64" || i === "x64" ? "x64" : i === "arm" ? "arm" : i === "aarch64" || i === "arm64" ? "arm64" : i ? `other:${i}` : "unknown", kp = i => (i = i.toLowerCase(), i.includes("ios") ? "iOS" : i === "android" ? "Android" : i === "darwin" ? "MacOS" : i === "win32" ? "Windows" : i === "freebsd" ? "FreeBSD" : i === "openbsd" ? "OpenBSD" : i === "linux" ? "Linux" : i ? `Other:${i}` : "Unknown"); let Ca; const v1 = () => Ca ?? (Ca = g1());/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function x1() { if (typeof fetch < "u") return fetch; throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new GeminiNextGenAPIClient({ fetch })` or polyfill the global, `globalThis.fetch = fetch`") } function Lg(...i) { const t = globalThis.ReadableStream; if (typeof t > "u") throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`"); return new t(...i) } function S1(i) { let t = Symbol.asyncIterator in i ? i[Symbol.asyncIterator]() : i[Symbol.iterator](); return Lg({ start() { }, async pull(l) { const { done: a, value: r } = await t.next(); a ? l.close() : l.enqueue(r) }, async cancel() { var l; await ((l = t.return) === null || l === void 0 ? void 0 : l.call(t)) } }) } function zg(i) { if (i[Symbol.asyncIterator]) return i; const t = i.getReader(); return { async next() { try { const l = await t.read(); return l != null && l.done && t.releaseLock(), l } catch (l) { throw t.releaseLock(), l } }, async return() { const l = t.cancel(); return t.releaseLock(), await l, { done: !0, value: void 0 } }, [Symbol.asyncIterator]() { return this } } } async function T1(i) { var t, l; if (i === null || typeof i != "object") return; if (i[Symbol.asyncIterator]) { await ((l = (t = i[Symbol.asyncIterator]()).return) === null || l === void 0 ? void 0 : l.call(t)); return } const a = i.getReader(), r = a.cancel(); a.releaseLock(), await r }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const _1 = ({ headers: i, body: t }) => ({ bodyHeaders: { "content-type": "application/json" }, body: JSON.stringify(t) });/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const qg = () => { var i; if (typeof File > "u") { const { process: t } = globalThis, l = typeof ((i = t == null ? void 0 : t.versions) === null || i === void 0 ? void 0 : i.node) == "string" && parseInt(t.versions.node.split(".")) < 20; throw new Error("`File` is not defined as a global, which is required for file uploads." + (l ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : "")) } }; function vu(i, t, l) { return qg(), new File(i, t ?? "unknown_file", l) } function E1(i) { return (typeof i == "object" && i !== null && ("name" in i && i.name && String(i.name) || "url" in i && i.url && String(i.url) || "filename" in i && i.filename && String(i.filename) || "path" in i && i.path && String(i.path)) || "").split(/[\\/]/).pop() || void 0 } const A1 = i => i != null && typeof i == "object" && typeof i[Symbol.asyncIterator] == "function";/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const Hg = i => i != null && typeof i == "object" && typeof i.size == "number" && typeof i.type == "string" && typeof i.text == "function" && typeof i.slice == "function" && typeof i.arrayBuffer == "function", C1 = i => i != null && typeof i == "object" && typeof i.name == "string" && typeof i.lastModified == "number" && Hg(i), b1 = i => i != null && typeof i == "object" && typeof i.url == "string" && typeof i.blob == "function"; async function N1(i, t, l) { if (qg(), i = await i, C1(i)) return i instanceof File ? i : vu([await i.arrayBuffer()], i.name); if (b1(i)) { const r = await i.blob(); return t || (t = new URL(i.url).pathname.split(/[\\/]/).pop()), vu(await Du(r), t, l) } const a = await Du(i); if (t || (t = E1(i)), !(l != null && l.type)) { const r = a.find(d => typeof d == "object" && "type" in d && d.type); typeof r == "string" && (l = Object.assign(Object.assign({}, l), { type: r })) } return vu(a, t, l) } async function Du(i) { var t, l, a, r, d; let m = []; if (typeof i == "string" || ArrayBuffer.isView(i) || i instanceof ArrayBuffer) m.push(i); else if (Hg(i)) m.push(i instanceof Blob ? i : await i.arrayBuffer()); else if (A1(i)) try { for (var g = !0, v = Jt(i), p; p = await v.next(), t = p.done, !t; g = !0) { r = p.value, g = !1; const x = r; m.push(...await Du(x)) } } catch (x) { l = { error: x } } finally { try { !g && !t && (a = v.return) && await a.call(v) } finally { if (l) throw l.error } } else { const x = (d = i == null ? void 0 : i.constructor) === null || d === void 0 ? void 0 : d.name; throw new Error(`Unexpected data type: ${typeof i}${x ? `; constructor: ${x}` : ""}${w1(i)}`) } return m } function w1(i) { return typeof i != "object" || i === null ? "" : `; props: [${Object.getOwnPropertyNames(i).map(l => `"${l}"`).join(", ")}]` }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Pg { constructor(t) { this._client = t } } Pg._key = [];/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Vg(i) { return i.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent) } const Dp = Object.freeze(Object.create(null)), M1 = (i = Vg) => (function (l, ...a) {
  if (l.length === 1) return l[0]; let r = !1; const d = [], m = l.reduce((x, T, _) => { var A, k, G; /[?#]/.test(T) && (r = !0); const U = a[_]; let V = (r ? encodeURIComponent : i)("" + U); return _ !== a.length && (U == null || typeof U == "object" && U.toString === ((G = Object.getPrototypeOf((k = Object.getPrototypeOf((A = U.hasOwnProperty) !== null && A !== void 0 ? A : Dp)) !== null && k !== void 0 ? k : Dp)) === null || G === void 0 ? void 0 : G.toString)) && (V = U + "", d.push({ start: x.length + T.length, length: V.length, error: `Value of type ${Object.prototype.toString.call(U).slice(8, -1)} is not a valid path parameter` })), x + T + (_ === a.length ? "" : V) }, ""), g = m.split(/[?#]/, 1)[0], v = new RegExp("(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)", "gi"); let p; for (; (p = v.exec(g)) !== null;)d.push({ start: p.index, length: p[0].length, error: `Value "${p[0]}" can't be safely passed as a path parameter` }); if (d.sort((x, T) => x.start - T.start), d.length > 0) {
    let x = 0; const T = d.reduce((_, A) => { const k = " ".repeat(A.start - x), G = "^".repeat(A.length); return x = A.start + A.length, _ + k + G }, ""); throw new Pt(`Path parameters result in path with invalid segments:
${d.map(_ => _.error).join(`
`)}
${m}
${T}`)
  } return m
}), ba = M1(Vg);/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Bg extends Pg { create(t, l) { var a; const { api_version: r = this._client.apiVersion } = t, d = qa(t, ["api_version"]); if ("model" in d && "agent_config" in d) throw new Pt("Invalid request: specified `model` and `agent_config`. If specifying `model`, use `generation_config`."); if ("agent" in d && "generation_config" in d) throw new Pt("Invalid request: specified `agent` and `generation_config`. If specifying `agent`, use `agent_config`."); return this._client.post(ba`/${r}/interactions`, Object.assign(Object.assign({ body: d }, l), { stream: (a = t.stream) !== null && a !== void 0 ? a : !1 })) } delete(t, l = {}, a) { const { api_version: r = this._client.apiVersion } = l ?? {}; return this._client.delete(ba`/${r}/interactions/${t}`, a) } cancel(t, l = {}, a) { const { api_version: r = this._client.apiVersion } = l ?? {}; return this._client.post(ba`/${r}/interactions/${t}/cancel`, a) } get(t, l = {}, a) { var r; const d = l ?? {}, { api_version: m = this._client.apiVersion } = d, g = qa(d, ["api_version"]); return this._client.get(ba`/${m}/interactions/${t}`, Object.assign(Object.assign({ query: g }, a), { stream: (r = l == null ? void 0 : l.stream) !== null && r !== void 0 ? r : !1 })) } } Bg._key = Object.freeze(["interactions"]); class Og extends Bg { }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function R1(i) { let t = 0; for (const r of i) t += r.length; const l = new Uint8Array(t); let a = 0; for (const r of i) l.set(r, a), a += r.length; return l } let Na; function Yu(i) { let t; return (Na ?? (t = new globalThis.TextEncoder, Na = t.encode.bind(t)))(i) } let wa; function Up(i) { let t; return (wa ?? (t = new globalThis.TextDecoder, wa = t.decode.bind(t)))(i) }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Ja {
  constructor() { this.buffer = new Uint8Array, this.carriageReturnIndex = null } decode(t) { if (t == null) return []; const l = t instanceof ArrayBuffer ? new Uint8Array(t) : typeof t == "string" ? Yu(t) : t; this.buffer = R1([this.buffer, l]); const a = []; let r; for (; (r = I1(this.buffer, this.carriageReturnIndex)) != null;) { if (r.carriage && this.carriageReturnIndex == null) { this.carriageReturnIndex = r.index; continue } if (this.carriageReturnIndex != null && (r.index !== this.carriageReturnIndex + 1 || r.carriage)) { a.push(Up(this.buffer.subarray(0, this.carriageReturnIndex - 1))), this.buffer = this.buffer.subarray(this.carriageReturnIndex), this.carriageReturnIndex = null; continue } const d = this.carriageReturnIndex !== null ? r.preceding - 1 : r.preceding, m = Up(this.buffer.subarray(0, d)); a.push(m), this.buffer = this.buffer.subarray(r.index), this.carriageReturnIndex = null } return a } flush() {
    return this.buffer.length ? this.decode(`
`) : []
  }
} Ja.NEWLINE_CHARS = new Set([`
`, "\r"]); Ja.NEWLINE_REGEXP = /\r\n|[\n\r]/g; function I1(i, t) { for (let r = t ?? 0; r < i.length; r++) { if (i[r] === 10) return { preceding: r, index: r + 1, carriage: !1 }; if (i[r] === 13) return { preceding: r, index: r + 1, carriage: !0 } } return null } function k1(i) { for (let a = 0; a < i.length - 1; a++) { if (i[a] === 10 && i[a + 1] === 10 || i[a] === 13 && i[a + 1] === 13) return a + 2; if (i[a] === 13 && i[a + 1] === 10 && a + 3 < i.length && i[a + 2] === 13 && i[a + 3] === 10) return a + 4 } return -1 }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const Ha = { off: 0, error: 200, warn: 300, info: 400, debug: 500 }, Gp = (i, t, l) => { if (i) { if (d1(Ha, i)) return i; st(l).warn(`${t} was set to ${JSON.stringify(i)}, expected one of ${JSON.stringify(Object.keys(Ha))}`) } }; function al() { } function Ma(i, t, l) { return !t || Ha[i] > Ha[l] ? al : t[i].bind(t) } const D1 = { error: al, warn: al, info: al, debug: al }; let Lp = new WeakMap; function st(i) { var t; const l = i.logger, a = (t = i.logLevel) !== null && t !== void 0 ? t : "off"; if (!l) return D1; const r = Lp.get(l); if (r && r[0] === a) return r[1]; const d = { error: Ma("error", l, a), warn: Ma("warn", l, a), info: Ma("info", l, a), debug: Ma("debug", l, a) }; return Lp.set(l, [a, d]), d } const di = i => (i.options && (i.options = Object.assign({}, i.options), delete i.options.headers), i.headers && (i.headers = Object.fromEntries((i.headers instanceof Headers ? [...i.headers] : Object.entries(i.headers)).map(([t, l]) => [t, t.toLowerCase() === "x-goog-api-key" || t.toLowerCase() === "authorization" || t.toLowerCase() === "cookie" || t.toLowerCase() === "set-cookie" ? "***" : l]))), "retryOfRequestLogID" in i && (i.retryOfRequestLogID && (i.retryOf = i.retryOfRequestLogID), delete i.retryOfRequestLogID), i);/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class to {
  constructor(t, l, a) { this.iterator = t, this.controller = l, this.client = a } static fromSSEResponse(t, l, a) { let r = !1; const d = a ? st(a) : console; function m() { return Yt(this, arguments, function* () { var v, p, x, T; if (r) throw new Pt("Cannot iterate over a consumed stream, use `.tee()` to split the stream."); r = !0; let _ = !1; try { try { for (var A = !0, k = Jt(U1(t, l)), G; G = yield le(k.next()), v = G.done, !v; A = !0) { T = G.value, A = !1; const U = T; if (!_) if (U.data.startsWith("[DONE]")) { _ = !0; continue } else try { yield yield le(JSON.parse(U.data)) } catch (V) { throw d.error("Could not parse message into JSON:", U.data), d.error("From chunk:", U.raw), V } } } catch (U) { p = { error: U } } finally { try { !A && !v && (x = k.return) && (yield le(x.call(k))) } finally { if (p) throw p.error } } _ = !0 } catch (U) { if (Mu(U)) return yield le(void 0); throw U } finally { _ || l.abort() } }) } return new to(m, l, a) } static fromReadableStream(t, l, a) { let r = !1; function d() { return Yt(this, arguments, function* () { var v, p, x, T; const _ = new Ja, A = zg(t); try { for (var k = !0, G = Jt(A), U; U = yield le(G.next()), v = U.done, !v; k = !0) { T = U.value, k = !1; const V = T; for (const W of _.decode(V)) yield yield le(W) } } catch (V) { p = { error: V } } finally { try { !k && !v && (x = G.return) && (yield le(x.call(G))) } finally { if (p) throw p.error } } for (const V of _.flush()) yield yield le(V) }) } function m() { return Yt(this, arguments, function* () { var v, p, x, T; if (r) throw new Pt("Cannot iterate over a consumed stream, use `.tee()` to split the stream."); r = !0; let _ = !1; try { try { for (var A = !0, k = Jt(d()), G; G = yield le(k.next()), v = G.done, !v; A = !0) { T = G.value, A = !1; const U = T; _ || U && (yield yield le(JSON.parse(U))) } } catch (U) { p = { error: U } } finally { try { !A && !v && (x = k.return) && (yield le(x.call(k))) } finally { if (p) throw p.error } } _ = !0 } catch (U) { if (Mu(U)) return yield le(void 0); throw U } finally { _ || l.abort() } }) } return new to(m, l, a) } [Symbol.asyncIterator]() { return this.iterator() } tee() { const t = [], l = [], a = this.iterator(), r = d => ({ next: () => { if (d.length === 0) { const m = a.next(); t.push(m), l.push(m) } return d.shift() } }); return [new to(() => r(t), this.controller, this.client), new to(() => r(l), this.controller, this.client)] } toReadableStream() {
    const t = this; let l; return Lg({
      async start() { l = t[Symbol.asyncIterator]() }, async pull(a) {
        try {
          const { value: r, done: d } = await l.next(); if (d) return a.close(); const m = Yu(JSON.stringify(r) + `
`); a.enqueue(m)
        } catch (r) { a.error(r) }
      }, async cancel() { var a; await ((a = l.return) === null || a === void 0 ? void 0 : a.call(l)) }
    })
  }
} function U1(i, t) { return Yt(this, arguments, function* () { var a, r, d, m; if (!i.body) throw t.abort(), typeof globalThis.navigator < "u" && globalThis.navigator.product === "ReactNative" ? new Pt("The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api") : new Pt("Attempted to iterate over a response with no body"); const g = new L1, v = new Ja, p = zg(i.body); try { for (var x = !0, T = Jt(G1(p)), _; _ = yield le(T.next()), a = _.done, !a; x = !0) { m = _.value, x = !1; const A = m; for (const k of v.decode(A)) { const G = g.decode(k); G && (yield yield le(G)) } } } catch (A) { r = { error: A } } finally { try { !x && !a && (d = T.return) && (yield le(d.call(T))) } finally { if (r) throw r.error } } for (const A of v.flush()) { const k = g.decode(A); k && (yield yield le(k)) } }) } function G1(i) { return Yt(this, arguments, function* () { var l, a, r, d; let m = new Uint8Array; try { for (var g = !0, v = Jt(i), p; p = yield le(v.next()), l = p.done, !l; g = !0) { d = p.value, g = !1; const x = d; if (x == null) continue; const T = x instanceof ArrayBuffer ? new Uint8Array(x) : typeof x == "string" ? Yu(x) : x; let _ = new Uint8Array(m.length + T.length); _.set(m), _.set(T, m.length), m = _; let A; for (; (A = k1(m)) !== -1;)yield yield le(m.slice(0, A)), m = m.slice(A) } } catch (x) { a = { error: x } } finally { try { !g && !l && (r = v.return) && (yield le(r.call(v))) } finally { if (a) throw a.error } } m.length > 0 && (yield yield le(m)) }) } class L1 {
  constructor() { this.event = null, this.data = [], this.chunks = [] } decode(t) {
    if (t.endsWith("\r") && (t = t.substring(0, t.length - 1)), !t) {
      if (!this.event && !this.data.length) return null; const d = {
        event: this.event, data: this.data.join(`
`), raw: this.chunks
      }; return this.event = null, this.data = [], this.chunks = [], d
    } if (this.chunks.push(t), t.startsWith(":")) return null; let [l, a, r] = z1(t, ":"); return r.startsWith(" ") && (r = r.substring(1)), l === "event" ? this.event = r : l === "data" && this.data.push(r), null
  }
} function z1(i, t) { const l = i.indexOf(t); return l !== -1 ? [i.substring(0, l), t, i.substring(l + t.length)] : [i, "", ""] }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */async function q1(i, t) { const { response: l, requestLogID: a, retryOfRequestLogID: r, startTime: d } = t, m = await (async () => { var g; if (t.options.stream) return st(i).debug("response", l.status, l.url, l.headers, l.body), t.options.__streamClass ? t.options.__streamClass.fromSSEResponse(l, t.controller, i) : to.fromSSEResponse(l, t.controller, i); if (l.status === 204) return null; if (t.options.__binaryResponse) return l; const v = l.headers.get("content-type"), p = (g = v == null ? void 0 : v.split(";")[0]) === null || g === void 0 ? void 0 : g.trim(); return (p == null ? void 0 : p.includes("application/json")) || (p == null ? void 0 : p.endsWith("+json")) ? await l.json() : await l.text() })(); return st(i).debug(`[${a}] response parsed`, di({ retryOfRequestLogID: r, url: l.url, status: l.status, body: m, durationMs: Date.now() - d })), m }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Ju extends Promise { constructor(t, l, a = q1) { super(r => { r(null) }), this.responsePromise = l, this.parseResponse = a, this.client = t } _thenUnwrap(t) { return new Ju(this.client, this.responsePromise, async (l, a) => t(await this.parseResponse(l, a), a)) } asResponse() { return this.responsePromise.then(t => t.response) } async withResponse() { const [t, l] = await Promise.all([this.parse(), this.asResponse()]); return { data: t, response: l } } parse() { return this.parsedPromise || (this.parsedPromise = this.responsePromise.then(t => this.parseResponse(this.client, t))), this.parsedPromise } then(t, l) { return this.parse().then(t, l) } catch(t) { return this.parse().catch(t) } finally(t) { return this.parse().finally(t) } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const Fg = Symbol("brand.privateNullableHeaders"); function* H1(i) { if (!i) return; if (Fg in i) { const { values: a, nulls: r } = i; yield* a.entries(); for (const d of r) yield [d, null]; return } let t = !1, l; i instanceof Headers ? l = i.entries() : Rp(i) ? l = i : (t = !0, l = Object.entries(i ?? {})); for (let a of l) { const r = a[0]; if (typeof r != "string") throw new TypeError("expected header name to be a string"); const d = Rp(a[1]) ? a[1] : [a[1]]; let m = !1; for (const g of d) g !== void 0 && (t && !m && (m = !0, yield [r, null]), yield [r, g]) } } const ll = i => { const t = new Headers, l = new Set; for (const a of i) { const r = new Set; for (const [d, m] of H1(a)) { const g = d.toLowerCase(); r.has(g) || (t.delete(d), r.add(g)), m === null ? (t.delete(d), l.add(g)) : (t.append(d, m), l.delete(g)) } } return { [Fg]: !0, values: t, nulls: l } };/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const xu = i => { var t, l, a, r, d, m; if (typeof globalThis.process < "u") return (a = (l = (t = dS) === null || t === void 0 ? void 0 : t[i]) === null || l === void 0 ? void 0 : l.trim()) !== null && a !== void 0 ? a : void 0; if (typeof globalThis.Deno < "u") return (m = (d = (r = globalThis.Deno.env) === null || r === void 0 ? void 0 : r.get) === null || d === void 0 ? void 0 : d.call(r, i)) === null || m === void 0 ? void 0 : m.trim() };/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */var Yg; class Wa { constructor(t) { var l, a, r, d, m, g, v, { baseURL: p = xu("GEMINI_NEXT_GEN_API_BASE_URL"), apiKey: x = (l = xu("GEMINI_API_KEY")) !== null && l !== void 0 ? l : null, apiVersion: T = "v1beta" } = t, _ = qa(t, ["baseURL", "apiKey", "apiVersion"]); const A = Object.assign(Object.assign({ apiKey: x, apiVersion: T }, _), { baseURL: p || "https://generativelanguage.googleapis.com" }); this.baseURL = A.baseURL, this.timeout = (a = A.timeout) !== null && a !== void 0 ? a : Wa.DEFAULT_TIMEOUT, this.logger = (r = A.logger) !== null && r !== void 0 ? r : console; const k = "warn"; this.logLevel = k, this.logLevel = (m = (d = Gp(A.logLevel, "ClientOptions.logLevel", this)) !== null && d !== void 0 ? d : Gp(xu("GEMINI_NEXT_GEN_API_LOG"), "process.env['GEMINI_NEXT_GEN_API_LOG']", this)) !== null && m !== void 0 ? m : k, this.fetchOptions = A.fetchOptions, this.maxRetries = (g = A.maxRetries) !== null && g !== void 0 ? g : 2, this.fetch = (v = A.fetch) !== null && v !== void 0 ? v : x1(), this.encoder = _1, this._options = A, this.apiKey = x, this.apiVersion = T, this.clientAdapter = A.clientAdapter } withOptions(t) { return new this.constructor(Object.assign(Object.assign(Object.assign({}, this._options), { baseURL: this.baseURL, maxRetries: this.maxRetries, timeout: this.timeout, logger: this.logger, logLevel: this.logLevel, fetch: this.fetch, fetchOptions: this.fetchOptions, apiKey: this.apiKey, apiVersion: this.apiVersion }), t)) } baseURLOverridden() { return this.baseURL !== "https://generativelanguage.googleapis.com" } defaultQuery() { return this._options.defaultQuery } validateHeaders({ values: t, nulls: l }) { if (!(t.has("authorization") || t.has("x-goog-api-key")) && !(this.apiKey && t.get("x-goog-api-key")) && !l.has("x-goog-api-key")) throw new Error('Could not resolve authentication method. Expected the apiKey to be set. Or for the "x-goog-api-key" headers to be explicitly omitted') } async authHeaders(t) { const l = ll([t.headers]); if (!(l.values.has("authorization") || l.values.has("x-goog-api-key"))) { if (this.apiKey) return ll([{ "x-goog-api-key": this.apiKey }]); if (this.clientAdapter.isVertexAI()) return ll([await this.clientAdapter.getAuthHeaders()]) } } stringifyQuery(t) { return Object.entries(t).filter(([l, a]) => typeof a < "u").map(([l, a]) => { if (typeof a == "string" || typeof a == "number" || typeof a == "boolean") return `${encodeURIComponent(l)}=${encodeURIComponent(a)}`; if (a === null) return `${encodeURIComponent(l)}=`; throw new Pt(`Cannot stringify type ${typeof a}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`) }).join("&") } getUserAgent() { return `${this.constructor.name}/JS ${$i}` } defaultIdempotencyKey() { return `stainless-node-retry-${l1()}` } makeStatusError(t, l, a, r) { return rt.generate(t, l, a, r) } buildURL(t, l, a) { const r = !this.baseURLOverridden() && a || this.baseURL, d = s1(t) ? new URL(t) : new URL(r + (r.endsWith("/") && t.startsWith("/") ? t.slice(1) : t)), m = this.defaultQuery(); return c1(m) || (l = Object.assign(Object.assign({}, m), l)), typeof l == "object" && l && !Array.isArray(l) && (d.search = this.stringifyQuery(l)), d.toString() } async prepareOptions(t) { if (this.clientAdapter && this.clientAdapter.isVertexAI() && !t.path.startsWith(`/${this.apiVersion}/projects/`)) { const l = t.path.slice(this.apiVersion.length + 1); t.path = `/${this.apiVersion}/projects/${this.clientAdapter.getProject()}/locations/${this.clientAdapter.getLocation()}${l}` } } async prepareRequest(t, { url: l, options: a }) { } get(t, l) { return this.methodRequest("get", t, l) } post(t, l) { return this.methodRequest("post", t, l) } patch(t, l) { return this.methodRequest("patch", t, l) } put(t, l) { return this.methodRequest("put", t, l) } delete(t, l) { return this.methodRequest("delete", t, l) } methodRequest(t, l, a) { return this.request(Promise.resolve(a).then(r => Object.assign({ method: t, path: l }, r))) } request(t, l = null) { return new Ju(this, this.makeRequest(t, l, void 0)) } async makeRequest(t, l, a) { var r, d, m; const g = await t, v = (r = g.maxRetries) !== null && r !== void 0 ? r : this.maxRetries; l == null && (l = v), await this.prepareOptions(g); const { req: p, url: x, timeout: T } = await this.buildRequest(g, { retryCount: v - l }); await this.prepareRequest(p, { url: x, options: g }); const _ = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0"), A = a === void 0 ? "" : `, retryOf: ${a}`, k = Date.now(); if (st(this).debug(`[${_}] sending request`, di({ retryOfRequestLogID: a, method: g.method, url: x, options: g, headers: p.headers })), !((d = g.signal) === null || d === void 0) && d.aborted) throw new Iu; const G = new AbortController, U = await this.fetchWithTimeout(x, p, T, G).catch(Ru), V = Date.now(); if (U instanceof globalThis.Error) { const B = `retrying, ${l} attempts remaining`; if (!((m = g.signal) === null || m === void 0) && m.aborted) throw new Iu; const K = Mu(U) || /timed? ?out/i.test(String(U) + ("cause" in U ? String(U.cause) : "")); if (l) return st(this).info(`[${_}] connection ${K ? "timed out" : "failed"} - ${B}`), st(this).debug(`[${_}] connection ${K ? "timed out" : "failed"} (${B})`, di({ retryOfRequestLogID: a, url: x, durationMs: V - k, message: U.message })), this.retryRequest(g, l, a ?? _); throw st(this).info(`[${_}] connection ${K ? "timed out" : "failed"} - error; no more retries left`), st(this).debug(`[${_}] connection ${K ? "timed out" : "failed"} (error; no more retries left)`, di({ retryOfRequestLogID: a, url: x, durationMs: V - k, message: U.message })), K ? new Ng : new Ya({ cause: U }) } const W = `[${_}${A}] ${p.method} ${x} ${U.ok ? "succeeded" : "failed"} with status ${U.status} in ${V - k}ms`; if (!U.ok) { const B = await this.shouldRetry(U); if (l && B) { const Z = `retrying, ${l} attempts remaining`; return await T1(U.body), st(this).info(`${W} - ${Z}`), st(this).debug(`[${_}] response error (${Z})`, di({ retryOfRequestLogID: a, url: U.url, status: U.status, headers: U.headers, durationMs: V - k })), this.retryRequest(g, l, a ?? _, U.headers) } const K = B ? "error; no more retries left" : "error; not retryable"; st(this).info(`${W} - ${K}`); const ee = await U.text().catch(Z => Ru(Z).message), te = m1(ee), F = te ? void 0 : ee; throw st(this).debug(`[${_}] response error (${K})`, di({ retryOfRequestLogID: a, url: U.url, status: U.status, headers: U.headers, message: F, durationMs: Date.now() - k })), this.makeStatusError(U.status, te, F, U.headers) } return st(this).info(W), st(this).debug(`[${_}] response start`, di({ retryOfRequestLogID: a, url: U.url, status: U.status, headers: U.headers, durationMs: V - k })), { response: U, options: g, controller: G, requestLogID: _, retryOfRequestLogID: a, startTime: k } } async fetchWithTimeout(t, l, a, r) { const d = l || {}, { signal: m, method: g } = d, v = qa(d, ["signal", "method"]); m && m.addEventListener("abort", () => r.abort()); const p = setTimeout(() => r.abort(), a), x = globalThis.ReadableStream && v.body instanceof globalThis.ReadableStream || typeof v.body == "object" && v.body !== null && Symbol.asyncIterator in v.body, T = Object.assign(Object.assign(Object.assign({ signal: r.signal }, x ? { duplex: "half" } : {}), { method: "GET" }), v); g && (T.method = g.toUpperCase()); try { return await this.fetch.call(void 0, t, T) } finally { clearTimeout(p) } } async shouldRetry(t) { const l = t.headers.get("x-should-retry"); return l === "true" ? !0 : l === "false" ? !1 : t.status === 408 || t.status === 409 || t.status === 429 || t.status >= 500 } async retryRequest(t, l, a, r) { var d; let m; const g = r == null ? void 0 : r.get("retry-after-ms"); if (g) { const p = parseFloat(g); Number.isNaN(p) || (m = p) } const v = r == null ? void 0 : r.get("retry-after"); if (v && !m) { const p = parseFloat(v); Number.isNaN(p) ? m = Date.parse(v) - Date.now() : m = p * 1e3 } if (!(m && 0 <= m && m < 60 * 1e3)) { const p = (d = t.maxRetries) !== null && d !== void 0 ? d : this.maxRetries; m = this.calculateDefaultRetryTimeoutMillis(l, p) } return await h1(m), this.makeRequest(t, l - 1, a) } calculateDefaultRetryTimeoutMillis(t, l) { const d = l - t, m = Math.min(.5 * Math.pow(2, d), 8), g = 1 - Math.random() * .25; return m * g * 1e3 } async buildRequest(t, { retryCount: l = 0 } = {}) { var a, r, d; const m = Object.assign({}, t), { method: g, path: v, query: p, defaultBaseURL: x } = m, T = this.buildURL(v, p, x); "timeout" in m && f1("timeout", m.timeout), m.timeout = (a = m.timeout) !== null && a !== void 0 ? a : this.timeout; const { bodyHeaders: _, body: A } = this.buildBody({ options: m }), k = await this.buildHeaders({ options: t, method: g, bodyHeaders: _, retryCount: l }); return { req: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ method: g, headers: k }, m.signal && { signal: m.signal }), globalThis.ReadableStream && A instanceof globalThis.ReadableStream && { duplex: "half" }), A && { body: A }), (r = this.fetchOptions) !== null && r !== void 0 ? r : {}), (d = m.fetchOptions) !== null && d !== void 0 ? d : {}), url: T, timeout: m.timeout } } async buildHeaders({ options: t, method: l, bodyHeaders: a, retryCount: r }) { let d = {}; this.idempotencyHeader && l !== "get" && (t.idempotencyKey || (t.idempotencyKey = this.defaultIdempotencyKey()), d[this.idempotencyHeader] = t.idempotencyKey); const m = await this.authHeaders(t); let g = ll([d, Object.assign(Object.assign({ Accept: "application/json", "User-Agent": this.getUserAgent(), "X-Stainless-Retry-Count": String(r) }, t.timeout ? { "X-Stainless-Timeout": String(Math.trunc(t.timeout / 1e3)) } : {}), v1()), this._options.defaultHeaders, a, t.headers, m]); return this.validateHeaders(g), g.values } buildBody({ options: { body: t, headers: l } }) { if (!t) return { bodyHeaders: void 0, body: void 0 }; const a = ll([l]); return ArrayBuffer.isView(t) || t instanceof ArrayBuffer || t instanceof DataView || typeof t == "string" && a.values.has("content-type") || globalThis.Blob && t instanceof globalThis.Blob || t instanceof FormData || t instanceof URLSearchParams || globalThis.ReadableStream && t instanceof globalThis.ReadableStream ? { bodyHeaders: void 0, body: t } : typeof t == "object" && (Symbol.asyncIterator in t || Symbol.iterator in t && "next" in t && typeof t.next == "function") ? { bodyHeaders: void 0, body: S1(t) } : this.encoder({ body: t, headers: a }) } } Wa.DEFAULT_TIMEOUT = 6e4; class je extends Wa { constructor() { super(...arguments), this.interactions = new Og(this) } } Yg = je; je.GeminiNextGenAPIClient = Yg; je.GeminiNextGenAPIClientError = Pt; je.APIError = rt; je.APIConnectionError = Ya; je.APIConnectionTimeoutError = Ng; je.APIUserAbortError = Iu; je.NotFoundError = Ig; je.ConflictError = kg; je.RateLimitError = Ug; je.BadRequestError = wg; je.AuthenticationError = Mg; je.InternalServerError = Gg; je.PermissionDeniedError = Rg; je.UnprocessableEntityError = Dg; je.toFile = N1; je.Interactions = Og;/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function P1(i, t) { const l = {}, a = u(i, ["name"]); return a != null && c(l, ["_url", "name"], a), l } function V1(i, t) { const l = {}, a = u(i, ["name"]); return a != null && c(l, ["_url", "name"], a), l } function B1(i, t) { const l = {}, a = u(i, ["sdkHttpResponse"]); return a != null && c(l, ["sdkHttpResponse"], a), l } function O1(i, t) { const l = {}, a = u(i, ["sdkHttpResponse"]); return a != null && c(l, ["sdkHttpResponse"], a), l } function F1(i, t, l) { const a = {}; if (u(i, ["validationDataset"]) !== void 0) throw new Error("validationDataset parameter is not supported in Gemini API."); const r = u(i, ["tunedModelDisplayName"]); if (t !== void 0 && r != null && c(t, ["displayName"], r), u(i, ["description"]) !== void 0) throw new Error("description parameter is not supported in Gemini API."); const d = u(i, ["epochCount"]); t !== void 0 && d != null && c(t, ["tuningTask", "hyperparameters", "epochCount"], d); const m = u(i, ["learningRateMultiplier"]); if (m != null && c(a, ["tuningTask", "hyperparameters", "learningRateMultiplier"], m), u(i, ["exportLastCheckpointOnly"]) !== void 0) throw new Error("exportLastCheckpointOnly parameter is not supported in Gemini API."); if (u(i, ["preTunedModelCheckpointId"]) !== void 0) throw new Error("preTunedModelCheckpointId parameter is not supported in Gemini API."); if (u(i, ["adapterSize"]) !== void 0) throw new Error("adapterSize parameter is not supported in Gemini API."); const g = u(i, ["batchSize"]); t !== void 0 && g != null && c(t, ["tuningTask", "hyperparameters", "batchSize"], g); const v = u(i, ["learningRate"]); if (t !== void 0 && v != null && c(t, ["tuningTask", "hyperparameters", "learningRate"], v), u(i, ["labels"]) !== void 0) throw new Error("labels parameter is not supported in Gemini API."); if (u(i, ["beta"]) !== void 0) throw new Error("beta parameter is not supported in Gemini API."); return a } function Y1(i, t, l) { const a = {}; let r = u(l, ["config", "method"]); if (r === void 0 && (r = "SUPERVISED_FINE_TUNING"), r === "SUPERVISED_FINE_TUNING") { const A = u(i, ["validationDataset"]); t !== void 0 && A != null && c(t, ["supervisedTuningSpec"], zp(A)) } else if (r === "PREFERENCE_TUNING") { const A = u(i, ["validationDataset"]); t !== void 0 && A != null && c(t, ["preferenceOptimizationSpec"], zp(A)) } const d = u(i, ["tunedModelDisplayName"]); t !== void 0 && d != null && c(t, ["tunedModelDisplayName"], d); const m = u(i, ["description"]); t !== void 0 && m != null && c(t, ["description"], m); let g = u(l, ["config", "method"]); if (g === void 0 && (g = "SUPERVISED_FINE_TUNING"), g === "SUPERVISED_FINE_TUNING") { const A = u(i, ["epochCount"]); t !== void 0 && A != null && c(t, ["supervisedTuningSpec", "hyperParameters", "epochCount"], A) } else if (g === "PREFERENCE_TUNING") { const A = u(i, ["epochCount"]); t !== void 0 && A != null && c(t, ["preferenceOptimizationSpec", "hyperParameters", "epochCount"], A) } let v = u(l, ["config", "method"]); if (v === void 0 && (v = "SUPERVISED_FINE_TUNING"), v === "SUPERVISED_FINE_TUNING") { const A = u(i, ["learningRateMultiplier"]); t !== void 0 && A != null && c(t, ["supervisedTuningSpec", "hyperParameters", "learningRateMultiplier"], A) } else if (v === "PREFERENCE_TUNING") { const A = u(i, ["learningRateMultiplier"]); t !== void 0 && A != null && c(t, ["preferenceOptimizationSpec", "hyperParameters", "learningRateMultiplier"], A) } let p = u(l, ["config", "method"]); if (p === void 0 && (p = "SUPERVISED_FINE_TUNING"), p === "SUPERVISED_FINE_TUNING") { const A = u(i, ["exportLastCheckpointOnly"]); t !== void 0 && A != null && c(t, ["supervisedTuningSpec", "exportLastCheckpointOnly"], A) } else if (p === "PREFERENCE_TUNING") { const A = u(i, ["exportLastCheckpointOnly"]); t !== void 0 && A != null && c(t, ["preferenceOptimizationSpec", "exportLastCheckpointOnly"], A) } let x = u(l, ["config", "method"]); if (x === void 0 && (x = "SUPERVISED_FINE_TUNING"), x === "SUPERVISED_FINE_TUNING") { const A = u(i, ["adapterSize"]); t !== void 0 && A != null && c(t, ["supervisedTuningSpec", "hyperParameters", "adapterSize"], A) } else if (x === "PREFERENCE_TUNING") { const A = u(i, ["adapterSize"]); t !== void 0 && A != null && c(t, ["preferenceOptimizationSpec", "hyperParameters", "adapterSize"], A) } if (u(i, ["batchSize"]) !== void 0) throw new Error("batchSize parameter is not supported in Vertex AI."); if (u(i, ["learningRate"]) !== void 0) throw new Error("learningRate parameter is not supported in Vertex AI."); const T = u(i, ["labels"]); t !== void 0 && T != null && c(t, ["labels"], T); const _ = u(i, ["beta"]); return t !== void 0 && _ != null && c(t, ["preferenceOptimizationSpec", "hyperParameters", "beta"], _), a } function J1(i, t) { const l = {}, a = u(i, ["baseModel"]); a != null && c(l, ["baseModel"], a); const r = u(i, ["preTunedModel"]); r != null && c(l, ["preTunedModel"], r); const d = u(i, ["trainingDataset"]); d != null && ib(d); const m = u(i, ["config"]); return m != null && F1(m, l), l } function W1(i, t) { const l = {}, a = u(i, ["baseModel"]); a != null && c(l, ["baseModel"], a); const r = u(i, ["preTunedModel"]); r != null && c(l, ["preTunedModel"], r); const d = u(i, ["trainingDataset"]); d != null && ob(d, l, t); const m = u(i, ["config"]); return m != null && Y1(m, l, t), l } function K1(i, t) { const l = {}, a = u(i, ["name"]); return a != null && c(l, ["_url", "name"], a), l } function X1(i, t) { const l = {}, a = u(i, ["name"]); return a != null && c(l, ["_url", "name"], a), l } function Q1(i, t, l) { const a = {}, r = u(i, ["pageSize"]); t !== void 0 && r != null && c(t, ["_query", "pageSize"], r); const d = u(i, ["pageToken"]); t !== void 0 && d != null && c(t, ["_query", "pageToken"], d); const m = u(i, ["filter"]); return t !== void 0 && m != null && c(t, ["_query", "filter"], m), a } function j1(i, t, l) { const a = {}, r = u(i, ["pageSize"]); t !== void 0 && r != null && c(t, ["_query", "pageSize"], r); const d = u(i, ["pageToken"]); t !== void 0 && d != null && c(t, ["_query", "pageToken"], d); const m = u(i, ["filter"]); return t !== void 0 && m != null && c(t, ["_query", "filter"], m), a } function Z1(i, t) { const l = {}, a = u(i, ["config"]); return a != null && Q1(a, l), l } function $1(i, t) { const l = {}, a = u(i, ["config"]); return a != null && j1(a, l), l } function eb(i, t) { const l = {}, a = u(i, ["sdkHttpResponse"]); a != null && c(l, ["sdkHttpResponse"], a); const r = u(i, ["nextPageToken"]); r != null && c(l, ["nextPageToken"], r); const d = u(i, ["tunedModels"]); if (d != null) { let m = d; Array.isArray(m) && (m = m.map(g => Jg(g))), c(l, ["tuningJobs"], m) } return l } function tb(i, t) { const l = {}, a = u(i, ["sdkHttpResponse"]); a != null && c(l, ["sdkHttpResponse"], a); const r = u(i, ["nextPageToken"]); r != null && c(l, ["nextPageToken"], r); const d = u(i, ["tuningJobs"]); if (d != null) { let m = d; Array.isArray(m) && (m = m.map(g => Uu(g))), c(l, ["tuningJobs"], m) } return l } function nb(i, t) { const l = {}, a = u(i, ["name"]); a != null && c(l, ["model"], a); const r = u(i, ["name"]); return r != null && c(l, ["endpoint"], r), l } function ib(i, t) { const l = {}; if (u(i, ["gcsUri"]) !== void 0) throw new Error("gcsUri parameter is not supported in Gemini API."); if (u(i, ["vertexDatasetResource"]) !== void 0) throw new Error("vertexDatasetResource parameter is not supported in Gemini API."); const a = u(i, ["examples"]); if (a != null) { let r = a; Array.isArray(r) && (r = r.map(d => d)), c(l, ["examples", "examples"], r) } return l } function ob(i, t, l) { const a = {}; let r = u(l, ["config", "method"]); if (r === void 0 && (r = "SUPERVISED_FINE_TUNING"), r === "SUPERVISED_FINE_TUNING") { const m = u(i, ["gcsUri"]); t !== void 0 && m != null && c(t, ["supervisedTuningSpec", "trainingDatasetUri"], m) } else if (r === "PREFERENCE_TUNING") { const m = u(i, ["gcsUri"]); t !== void 0 && m != null && c(t, ["preferenceOptimizationSpec", "trainingDatasetUri"], m) } let d = u(l, ["config", "method"]); if (d === void 0 && (d = "SUPERVISED_FINE_TUNING"), d === "SUPERVISED_FINE_TUNING") { const m = u(i, ["vertexDatasetResource"]); t !== void 0 && m != null && c(t, ["supervisedTuningSpec", "trainingDatasetUri"], m) } else if (d === "PREFERENCE_TUNING") { const m = u(i, ["vertexDatasetResource"]); t !== void 0 && m != null && c(t, ["preferenceOptimizationSpec", "trainingDatasetUri"], m) } if (u(i, ["examples"]) !== void 0) throw new Error("examples parameter is not supported in Vertex AI."); return a } function Jg(i, t) { const l = {}, a = u(i, ["sdkHttpResponse"]); a != null && c(l, ["sdkHttpResponse"], a); const r = u(i, ["name"]); r != null && c(l, ["name"], r); const d = u(i, ["state"]); d != null && c(l, ["state"], rg(d)); const m = u(i, ["createTime"]); m != null && c(l, ["createTime"], m); const g = u(i, ["tuningTask", "startTime"]); g != null && c(l, ["startTime"], g); const v = u(i, ["tuningTask", "completeTime"]); v != null && c(l, ["endTime"], v); const p = u(i, ["updateTime"]); p != null && c(l, ["updateTime"], p); const x = u(i, ["description"]); x != null && c(l, ["description"], x); const T = u(i, ["baseModel"]); T != null && c(l, ["baseModel"], T); const _ = u(i, ["_self"]); return _ != null && c(l, ["tunedModel"], nb(_)), l } function Uu(i, t) { const l = {}, a = u(i, ["sdkHttpResponse"]); a != null && c(l, ["sdkHttpResponse"], a); const r = u(i, ["name"]); r != null && c(l, ["name"], r); const d = u(i, ["state"]); d != null && c(l, ["state"], rg(d)); const m = u(i, ["createTime"]); m != null && c(l, ["createTime"], m); const g = u(i, ["startTime"]); g != null && c(l, ["startTime"], g); const v = u(i, ["endTime"]); v != null && c(l, ["endTime"], v); const p = u(i, ["updateTime"]); p != null && c(l, ["updateTime"], p); const x = u(i, ["error"]); x != null && c(l, ["error"], x); const T = u(i, ["description"]); T != null && c(l, ["description"], T); const _ = u(i, ["baseModel"]); _ != null && c(l, ["baseModel"], _); const A = u(i, ["tunedModel"]); A != null && c(l, ["tunedModel"], A); const k = u(i, ["preTunedModel"]); k != null && c(l, ["preTunedModel"], k); const G = u(i, ["supervisedTuningSpec"]); G != null && c(l, ["supervisedTuningSpec"], G); const U = u(i, ["preferenceOptimizationSpec"]); U != null && c(l, ["preferenceOptimizationSpec"], U); const V = u(i, ["tuningDataStats"]); V != null && c(l, ["tuningDataStats"], V); const W = u(i, ["encryptionSpec"]); W != null && c(l, ["encryptionSpec"], W); const B = u(i, ["partnerModelTuningSpec"]); B != null && c(l, ["partnerModelTuningSpec"], B); const K = u(i, ["customBaseModel"]); K != null && c(l, ["customBaseModel"], K); const ee = u(i, ["experiment"]); ee != null && c(l, ["experiment"], ee); const te = u(i, ["labels"]); te != null && c(l, ["labels"], te); const F = u(i, ["outputUri"]); F != null && c(l, ["outputUri"], F); const ge = u(i, ["pipelineJob"]); ge != null && c(l, ["pipelineJob"], ge); const Z = u(i, ["serviceAccount"]); Z != null && c(l, ["serviceAccount"], Z); const me = u(i, ["tunedModelDisplayName"]); me != null && c(l, ["tunedModelDisplayName"], me); const Ae = u(i, ["veoTuningSpec"]); return Ae != null && c(l, ["veoTuningSpec"], Ae), l } function lb(i, t) { const l = {}, a = u(i, ["sdkHttpResponse"]); a != null && c(l, ["sdkHttpResponse"], a); const r = u(i, ["name"]); r != null && c(l, ["name"], r); const d = u(i, ["metadata"]); d != null && c(l, ["metadata"], d); const m = u(i, ["done"]); m != null && c(l, ["done"], m); const g = u(i, ["error"]); return g != null && c(l, ["error"], g), l } function zp(i, t) { const l = {}, a = u(i, ["gcsUri"]); a != null && c(l, ["validationDatasetUri"], a); const r = u(i, ["vertexDatasetResource"]); return r != null && c(l, ["validationDatasetUri"], r), l }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class ab extends vn { constructor(t) { super(), this.apiClient = t, this.list = async (l = {}) => new mi(yn.PAGED_ITEM_TUNING_JOBS, a => this.listInternal(a), await this.listInternal(l), l), this.get = async l => await this.getInternal(l), this.tune = async l => { var a; if (this.apiClient.isVertexAI()) if (l.baseModel.startsWith("projects/")) { const r = { tunedModelName: l.baseModel }; !((a = l.config) === null || a === void 0) && a.preTunedModelCheckpointId && (r.checkpointId = l.config.preTunedModelCheckpointId); const d = Object.assign(Object.assign({}, l), { preTunedModel: r }); return d.baseModel = void 0, await this.tuneInternal(d) } else { const r = Object.assign({}, l); return await this.tuneInternal(r) } else { const r = Object.assign({}, l), d = await this.tuneMldevInternal(r); let m = ""; return d.metadata !== void 0 && d.metadata.tunedModel !== void 0 ? m = d.metadata.tunedModel : d.name !== void 0 && d.name.includes("/operations/") && (m = d.name.split("/operations/")[0]), { name: m, state: _u.JOB_STATE_QUEUED } } } } async getInternal(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = X1(t); return g = J("{name}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "GET", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => Uu(x)) } else { const p = K1(t); return g = J("{name}", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "GET", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => Jg(x)) } } async listInternal(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = $1(t); return g = J("tuningJobs", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "GET", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = tb(x), _ = new up; return Object.assign(_, T), _ }) } else { const p = Z1(t); return g = J("tunedModels", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "GET", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = eb(x), _ = new up; return Object.assign(_, T), _ }) } } async cancel(t) { var l, a, r, d; let m, g = "", v = {}; if (this.apiClient.isVertexAI()) { const p = V1(t); return g = J("{name}:cancel", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = O1(x), _ = new cp; return Object.assign(_, T), _ }) } else { const p = P1(t); return g = J("{name}:cancel", p._url), v = p._query, delete p._url, delete p._query, m = this.apiClient.request({ path: g, queryParams: v, body: JSON.stringify(p), httpMethod: "POST", httpOptions: (r = t.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (d = t.config) === null || d === void 0 ? void 0 : d.abortSignal }).then(x => x.json().then(T => { const _ = T; return _.sdkHttpResponse = { headers: x.headers }, _ })), m.then(x => { const T = B1(x), _ = new cp; return Object.assign(_, T), _ }) } } async tuneInternal(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) { const g = W1(t, t); return d = J("tuningJobs", g._url), m = g._query, delete g._url, delete g._query, r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(g), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(v => v.json().then(p => { const x = p; return x.sdkHttpResponse = { headers: v.headers }, x })), r.then(v => Uu(v)) } else throw new Error("This method is only supported by the Vertex AI.") } async tuneMldevInternal(t) { var l, a; let r, d = "", m = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const g = J1(t); return d = J("tunedModels", g._url), m = g._query, delete g._url, delete g._query, r = this.apiClient.request({ path: d, queryParams: m, body: JSON.stringify(g), httpMethod: "POST", httpOptions: (l = t.config) === null || l === void 0 ? void 0 : l.httpOptions, abortSignal: (a = t.config) === null || a === void 0 ? void 0 : a.abortSignal }).then(v => v.json().then(p => { const x = p; return x.sdkHttpResponse = { headers: v.headers }, x })), r.then(v => lb(v)) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class sb { async download(t, l) { throw new Error("Download to file is not supported in the browser, please use a browser compliant download like an <a> tag.") } } const rb = 1024 * 1024 * 8, ub = 3, cb = 1e3, db = 2, Pa = "x-goog-upload-status"; async function fb(i, t, l) { var a; const r = await Wg(i, t, l), d = await (r == null ? void 0 : r.json()); if (((a = r == null ? void 0 : r.headers) === null || a === void 0 ? void 0 : a[Pa]) !== "final") throw new Error("Failed to upload file: Upload status is not finalized."); return d.file } async function mb(i, t, l) { var a; const r = await Wg(i, t, l), d = await (r == null ? void 0 : r.json()); if (((a = r == null ? void 0 : r.headers) === null || a === void 0 ? void 0 : a[Pa]) !== "final") throw new Error("Failed to upload file: Upload status is not finalized."); const m = ng(d), g = new Hu; return Object.assign(g, m), g } async function Wg(i, t, l) { var a, r; let d = 0, m = 0, g = new Eu(new Response), v = "upload"; for (d = i.size; m < d;) { const p = Math.min(rb, d - m), x = i.slice(m, m + p); m + p >= d && (v += ", finalize"); let T = 0, _ = cb; for (; T < ub && (g = await l.request({ path: "", body: x, httpMethod: "POST", httpOptions: { apiVersion: "", baseUrl: t, headers: { "X-Goog-Upload-Command": v, "X-Goog-Upload-Offset": String(m), "Content-Length": String(p) } } }), !(!((a = g == null ? void 0 : g.headers) === null || a === void 0) && a[Pa]));)T++, await pb(_), _ = _ * db; if (m += p, ((r = g == null ? void 0 : g.headers) === null || r === void 0 ? void 0 : r[Pa]) !== "active") break; if (d <= m) throw new Error("All content has been uploaded, but the upload status is not finalized.") } return g } async function hb(i) { return { size: i.size, type: i.type } } function pb(i) { return new Promise(t => setTimeout(t, i)) } class gb { async upload(t, l, a) { if (typeof t == "string") throw new Error("File path is not supported in browser uploader."); return await fb(t, l, a) } async uploadToFileSearchStore(t, l, a) { if (typeof t == "string") throw new Error("File path is not supported in browser uploader."); return await mb(t, l, a) } async stat(t) { if (typeof t == "string") throw new Error("File path is not supported in browser uploader."); return await hb(t) } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class yb { create(t, l, a) { return new vb(t, l, a) } } class vb { constructor(t, l, a) { this.url = t, this.headers = l, this.callbacks = a } connect() { this.ws = new WebSocket(this.url), this.ws.onopen = this.callbacks.onopen, this.ws.onerror = this.callbacks.onerror, this.ws.onclose = this.callbacks.onclose, this.ws.onmessage = this.callbacks.onmessage } send(t) { if (this.ws === void 0) throw new Error("WebSocket is not connected"); this.ws.send(t) } close() { if (this.ws === void 0) throw new Error("WebSocket is not connected"); this.ws.close() } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const qp = "x-goog-api-key"; class xb { constructor(t) { this.apiKey = t } async addAuthHeaders(t, l) { if (t.get(qp) === null) { if (this.apiKey.startsWith("auth_tokens/")) throw new Error("Ephemeral tokens are only supported by the live API."); if (!this.apiKey) throw new Error("API key is missing. Please provide a valid API key."); t.append(qp, this.apiKey) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const Sb = "gl-node/"; class Kg { get interactions() { if (this._interactions !== void 0) return this._interactions; console.warn("GoogleGenAI.interactions: Interactions usage is experimental and may change in future versions."); const t = this.httpOptions; t != null && t.extraBody && console.warn("GoogleGenAI.interactions: Client level httpOptions.extraBody is not supported by the interactions client and will be ignored."); const l = new je({ baseURL: this.apiClient.getBaseUrl(), apiKey: this.apiKey, apiVersion: this.apiClient.getApiVersion(), clientAdapter: this.apiClient, defaultHeaders: this.apiClient.getDefaultHeaders(), timeout: t == null ? void 0 : t.timeout }); return this._interactions = l.interactions, this._interactions } constructor(t) { var l; if (t.apiKey == null) throw new Error("An API Key must be set when running in a browser"); if (t.project || t.location) throw new Error("Vertex AI project based authentication is not supported on browser runtimes. Please do not provide a project or location."); this.vertexai = (l = t.vertexai) !== null && l !== void 0 ? l : !1, this.apiKey = t.apiKey; const a = pS(t.httpOptions, t.vertexai, void 0, void 0); a && (t.httpOptions ? t.httpOptions.baseUrl = a : t.httpOptions = { baseUrl: a }), this.apiVersion = t.apiVersion, this.httpOptions = t.httpOptions; const r = new xb(this.apiKey); this.apiClient = new hC({ auth: r, apiVersion: this.apiVersion, apiKey: this.apiKey, vertexai: this.vertexai, httpOptions: this.httpOptions, userAgentExtra: Sb + "web", uploader: new gb, downloader: new sb }), this.models = new DC(this.apiClient), this.live = new NC(this.apiClient, r, new yb), this.batches = new FT(this.apiClient), this.chats = new C_(this.models, this.apiClient), this.caches = new __(this.apiClient), this.files = new G_(this.apiClient), this.operations = new UC(this.apiClient), this.authTokens = new QC(this.apiClient), this.tunings = new ab(this.apiClient), this.fileSearchStores = new o1(this.apiClient) } } const Tb = new Kg({ apiKey: "" }), _b = async (i, t, l, a) => { let r = Tb; if (a && a.trim() !== "") r = new Kg({ apiKey: a }); else { console.warn("API Key missing. Returning mock data."); const d = []; return i.forEach(m => { for (let g = 0; g < l; g++)d.push({ text: `[${t.label} Mock] A detailed prompt about ${m} #${g + 1}` }) }), d } try { const d = i.join(", "), m = await r.models.generateContent({ model: "gemini-3-flash-preview", contents: `Generate exactly ${l} distinct, high-quality AI image generation prompts for EACH of the following subjects: "${d}".`, config: { systemInstruction: `You are a ${t.label}. ${t.systemInstruction}. Your task is to write high-fidelity image generation prompts (Midjourney/Stable Diffusion style). Return a flat list of all prompts.`, responseMimeType: "application/json", responseSchema: { type: qt.OBJECT, properties: { prompts: { type: qt.ARRAY, items: { type: qt.OBJECT, properties: { text: { type: qt.STRING } } } } } } } }); return JSON.parse(m.text || '{"prompts": []}').prompts } catch (d) { throw console.error("Error generating prompts:", d), d } }; var fi = (i => (i.IDLE = "IDLE", i.LOADING = "LOADING", i.SUCCESS = "SUCCESS", i.ERROR = "ERROR", i))(fi || {}); const Hp = [{ id: "general", label: "General", description: "Balanced style", systemInstruction: "Create well-balanced, high-quality prompts suitable for general purpose generation." }, { id: "photo", label: "Pro Photographer", description: "Photorealistic", systemInstruction: "Focus on camera gear, lighting, depth of field, and realistic textures (Sony A7R, 85mm)." }, { id: "graphic", label: "Graphic Designer", description: "Vector style", systemInstruction: "Focus on clean lines, vector art style, flat design, and commercial aesthetics." }, { id: "fashion", label: "Fashion Designer", description: "Apparel focus", systemInstruction: "Focus on fabric textures, draping, lighting on materials, and haute couture styling." }, { id: "3d", label: "3D Designer", description: "Render style", systemInstruction: "Focus on Octane Render, Unreal Engine 5, ray tracing, subsurface scattering, and 3D assets." }, { id: "arch", label: "Architect", description: "Structure focus", systemInstruction: "Focus on architectural details, lighting, brutalism or modernism, and realistic materials." }, { id: "abstract", label: "Abstract Art", description: "Creative", systemInstruction: "Focus on shapes, colors, emotions, non-representational forms, and artistic composition." }, { id: "elements", label: "Graphic Elements", description: "Assets", systemInstruction: "Focus on isolated elements, stickers, UI assets, and transparent backgrounds." }], Eb = () => {
  const [i, t] = ze.useState(""), [l, a] = ze.useState(""), [r, d] = ze.useState(Hp[0]), [m, g] = ze.useState(5), [v, p] = ze.useState(fi.IDLE), [x, T] = ze.useState([]), _ = async () => { if (l.trim()) { p(fi.LOADING); try { const A = l.split(",").map(G => G.trim()).filter(G => G.length > 0), k = await _b(A, r, m, i); T(k), p(fi.SUCCESS) } catch (A) { console.error(A), p(fi.ERROR) } } }; return y.jsx("div", {
    className: "neon-border rounded-[3rem] bg-background/50 backdrop-blur-xl p-8 md:p-12 shadow-[0_0_50px_rgba(250,204,21,0.15)]", children: y.jsxs("div", {
      className: "grid grid-cols-1 lg:grid-cols-12 gap-10 items-start", children: [y.jsxs("div", {
        className: "lg:col-span-5 space-y-8", children: [y.jsx("div", { className: "border-b border-white/10 pb-4 mb-4", children: y.jsx("h3", { className: "text-sm font-bold text-slate-400 uppercase tracking-widest mb-1", children: "GEMINI INTEGRATION" }) }), y.jsxs("div", { className: "space-y-2", children: [y.jsxs("div", { className: "flex justify-between items-center", children: [y.jsx("label", { className: "block text-sm font-bold text-slate-300", children: "API Key" }), y.jsxs("a", { href: "https://aistudio.google.com/app/apikey", target: "_blank", rel: "noreferrer", className: "text-xs text-primary font-bold flex items-center gap-1 hover:underline", children: ["Get Free Key ", y.jsx(ux, { size: 10 })] })] }), y.jsx("input", { type: "password", placeholder: "Paste Gemini Key", value: i, onChange: A => t(A.target.value), className: "w-full px-5 py-3 rounded-2xl bg-surface border border-white/10 text-slate-200 focus:border-primary focus:ring-1 focus:ring-primary outline-none transition-all placeholder:text-slate-600" })] }), y.jsxs("div", {
          className: "space-y-3", children: [y.jsx("label", { className: "block text-sm font-bold text-slate-300", children: "Persona (Style)" }), y.jsx("div", {
            className: "grid grid-cols-2 gap-3", children: Hp.map(A => y.jsx("button", {
              onClick: () => d(A), className: `px-3 py-3 rounded-xl text-xs font-bold transition-all border
                    ${r.id === A.id ? "bg-primary text-black border-primary shadow-[0_0_15px_rgba(250,204,21,0.4)]" : "bg-surface text-slate-400 border-white/5 hover:bg-white/5 hover:text-slate-200"}`, children: A.label
            }, A.id))
          })]
        }), y.jsxs("div", { className: "space-y-2", children: [y.jsx("label", { className: "block text-sm font-bold text-slate-300", children: "Keywords" }), y.jsx("textarea", { value: l, onChange: A => a(A.target.value), className: "w-full p-5 rounded-2xl bg-surface border border-white/10 text-slate-300 font-medium min-h-[120px] focus:border-primary focus:ring-1 focus:ring-primary outline-none resize-none placeholder:text-slate-600 transition-all text-sm", placeholder: "e.g. futuristic city, cyber cat" })] }), y.jsxs("div", { className: "p-4 rounded-2xl border border-dashed border-white/10 bg-white/5 text-xs text-slate-400 leading-relaxed", children: [y.jsx("strong", { className: "text-slate-200", children: "Quick Guide:" }), ' Enter multiple keywords separated by commas (e.g. "sunset, beach, waves"). The AI will generate ', y.jsxs("span", { className: "text-primary font-bold", children: [m, " unique prompts"] }), " for ", y.jsx("span", { className: "underline decoration-slate-600", children: "each" }), " keyword, tailored to the selected persona."] }), y.jsxs("div", { className: "space-y-2", children: [y.jsx("label", { className: "block text-sm font-bold text-slate-300", children: "Count per Keyword" }), y.jsx("input", { type: "number", min: "1", max: "20", value: m, onChange: A => g(parseInt(A.target.value)), className: "w-full px-5 py-3 rounded-2xl bg-surface border border-white/10 text-slate-200 focus:border-primary focus:ring-1 focus:ring-primary outline-none transition-all" })] }), y.jsx("button", { onClick: _, disabled: v === fi.LOADING || !l.trim(), className: "w-full py-4 bg-primary text-black font-black text-lg rounded-full hover:scale-105 transition-transform cta-glow flex items-center justify-center gap-2 shadow-[0_0_30px_rgba(250,204,21,0.4)] disabled:opacity-50 disabled:cursor-not-allowed", children: v === fi.LOADING ? y.jsx(Vx, { className: "animate-spin" }) : "Generate Prompts" })]
      }), y.jsx("div", { className: "lg:col-span-7 h-full min-h-[600px] flex flex-col", children: y.jsxs("div", { className: "relative h-full flex flex-col bg-surface/30 rounded-[2.5rem] border border-white/5 p-6 md:p-8", children: [y.jsx("div", { className: "absolute -top-6 -right-4 font-handwriting text-primary text-4xl -rotate-12 z-20 select-none drop-shadow-[0_0_10px_rgba(250,204,21,0.8)]", children: "Automated!" }), y.jsxs("div", { className: "flex items-center justify-between mb-6", children: [y.jsx("h3", { className: "text-sm font-bold text-primary uppercase tracking-widest", children: "Output Console" }), x.length > 0 && y.jsxs("span", { className: "text-xs font-bold text-slate-500 bg-white/5 px-3 py-1 rounded-full", children: [x.length, " prompts generated"] })] }), y.jsx("div", { className: "grid grid-cols-1 gap-4 overflow-y-auto pr-2 custom-scrollbar grow max-h-[800px]", children: x.length > 0 ? x.map((A, k) => y.jsxs("div", { className: "group relative p-6 rounded-2xl bg-background border border-white/10 text-slate-300 shadow-sm hover:border-primary/50 transition-colors animate-in fade-in slide-in-from-bottom-2 duration-300", children: [y.jsxs("div", { className: "text-[10px] font-bold text-slate-600 uppercase mb-2 flex justify-between", children: [y.jsxs("span", { children: ["Prompt #", k + 1] }), y.jsx("span", { className: "text-primary/50", children: r.label })] }), y.jsxs("p", { className: "text-sm leading-relaxed font-medium", children: ['"', A.text, '"'] }), y.jsx("button", { className: "absolute top-4 right-4 p-2 rounded-lg bg-white/5 text-primary opacity-0 group-hover:opacity-100 transition-opacity hover:bg-primary hover:text-black", onClick: () => navigator.clipboard.writeText(A.text), title: "Copy", children: y.jsx(ax, { size: 14 }) })] }, k)) : y.jsxs("div", { className: "h-full flex flex-col items-center justify-center text-center opacity-30", children: [y.jsx($p, { size: 48, className: "mb-4 text-slate-500" }), y.jsx("p", { className: "text-slate-400 font-medium", children: "Ready to generate." }), y.jsx("p", { className: "text-slate-600 text-sm mt-2", children: "Configure the settings on the left and hit Generate." })] }) })] }) })]
    })
  })
}, Zi = "https://chromewebstore.google.com/detail/oahcpmhnmcfjciaehfijhfjofjddjjij", Pp = ({ className: i = "" }) => y.jsx("svg", { viewBox: "0 0 300 100", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: `absolute pointer-events-none select-none ${i}`, preserveAspectRatio: "none", children: y.jsx("path", { d: "M20 50 C20 20 80 10 150 10 C240 10 280 30 280 50 C280 80 220 90 150 90 C70 90 20 70 20 50 Z", stroke: "#EF4444", strokeWidth: "4", strokeLinecap: "round", strokeLinejoin: "round", className: "opacity-90" }) }), Vp = [{ rating: 5, quote: "I was looking for how to download all images from Meta Ai   and found this. It turned a 40-hour work week into a 4-hour monitoring task.", name: "Marcus Sterling", role: "Creative Director @ Nexa", img: "https://picsum.photos/100/100?random=1" }, { rating: 5, quote: "The best Meta Ai   extensions usually crash, but this one is rock solid. Meta Ai   AI batch processing is a game changer.", name: "Sarah Chen", role: "Independent AI Artist", img: "https://picsum.photos/100/100?random=2", highlight: !0 }, { rating: 5, quote: "Finally, I can automate Meta Ai   prompts without getting banned. The human-like pacing is incredibly smart.", name: "David Thorne", role: "Stock Media Producer", img: "https://picsum.photos/100/100?random=3" }, { rating: 5, quote: "Meta Ai   AI for power users is right. I've scaled my agency's output by 10x using the Meta Ai   multiple images at once feature.", name: "Elena Rodriguez", role: "Agency Owner", img: "https://picsum.photos/100/100?random=4" }, { rating: 5, quote: "Compared to other free MetaAi Automator tools, this pays for itself in one day. The auto downloader saves my wrist.", name: "James Kim", role: "Freelance Designer", img: "https://picsum.photos/100/100?random=5" }], Ab = () => { const { t: i, isRTL: t } = ze.useContext(tg), [l, a] = Ia.useState(0), [r, d] = Ia.useState(!1), m = v => { a(l === v ? null : v) }; Ia.useEffect(() => { const v = p => { p.key === "Escape" && r && d(!1) }; return window.addEventListener("keydown", v), () => window.removeEventListener("keydown", v) }, [r]); const g = t ? Lv : Jp; return y.jsxs(y.Fragment, { children: [y.jsx("header", { className: "relative pt-40 pb-24 overflow-hidden", children: y.jsxs("div", { className: "max-w-7xl mx-auto px-6 text-center relative z-10 reveal", children: [y.jsxs("div", { className: "inline-flex items-center gap-2 px-6 py-3 rounded-full bg-primary/10 border border-primary/30 text-xs font-bold mb-8 text-primary tracking-widest uppercase animate-fade-in-up shadow-[0_0_20px_rgba(250,204,21,0.2)]", children: [y.jsx("span", { className: "flex h-2 w-2 rounded-full bg-primary animate-ping" }), i.hero.badge] }), y.jsxs("h1", { className: "text-5xl md:text-7xl font-extrabold leading-[1.1] tracking-tighter mb-8 text-white drop-shadow-[0_0_25px_rgba(0,0,0,0.5)] reveal reveal-delay-100", children: [i.hero.titlePrefix, " ", y.jsx("br", {}), i.hero.titleMiddle, " ", y.jsxs("span", { className: "relative inline-block mt-2", children: [y.jsx("span", { className: "yellow-gradient-text relative z-10 px-4", children: i.hero.titleSuffix }), y.jsx(Pp, { className: "-left-6 -top-4 w-[140%] h-[160%] rotate-1" })] })] }), y.jsx("p", { className: "text-xl md:text-2xl text-slate-300 max-w-3xl mx-auto mb-12 font-medium leading-relaxed reveal reveal-delay-200", children: i.hero.subtitle }), y.jsxs("div", { className: "flex flex-col sm:flex-row items-center justify-center gap-6 reveal reveal-delay-300", children: [y.jsxs(Ft, { size: "lg", className: "flex items-center gap-2", onClick: () => window.open(Zi, "_blank"), children: [i.hero.ctaPrimary, " ", y.jsx(il, { size: 20, fill: "currentColor" })] }), y.jsxs(Ft, { variant: "secondary", size: "lg", className: "flex items-center gap-2", onClick: () => d(!0), children: [y.jsx(zx, { size: 20, className: t ? "scale-x-[-1]" : "" }), " ", i.hero.ctaSecondary] })] })] }) }), y.jsx("section", { id: "video", className: "py-24 relative overflow-hidden section-glow scroll-mt-32", children: y.jsxs("div", { className: "max-w-5xl mx-auto px-6 reveal", children: [y.jsxs("div", { className: "text-center mb-12", children: [y.jsxs("h2", { className: "text-4xl md:text-5xl font-extrabold mb-4 uppercase italic text-white", children: ["Streamline ", y.jsx("span", { className: "text-primary", children: "Meta Ai  " })] }), y.jsx("p", { className: "text-slate-400", children: "See Meta Ai   AI batch processing in action. Generate 1000s of images hands-free." })] }), y.jsxs("div", { className: "relative reveal reveal-delay-200", children: [y.jsx("div", { className: "absolute -inset-1 bg-primary/20 rounded-[3rem] blur-2xl transition duration-500" }), y.jsx("div", { className: "relative bg-surface/80 backdrop-blur-sm rounded-[2.5rem] border-2 border-primary overflow-hidden aspect-video shadow-[0_0_60px_rgba(250,204,21,0.25)]", children: y.jsx("iframe", { width: "100%", height: "100%", src: "https://www.youtube.com/embed/wCnv514L0uM?si=Xs2JRbbd3je9jZOb", title: "YouTube video player", frameBorder: "0", allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share", referrerPolicy: "strict-origin-when-cross-origin", allowFullScreen: !0, className: "absolute inset-0 w-full h-full" }) })] })] }) }), y.jsx("section", { className: "py-24 relative", children: y.jsx("div", { className: "max-w-4xl mx-auto px-6 reveal", children: y.jsxs("div", { className: "relative group", children: [y.jsx("div", { className: "absolute -inset-1 bg-gradient-to-r from-primary/20 via-primary/5 to-primary/20 rounded-[3rem] blur-2xl opacity-75 group-hover:opacity-100 transition duration-1000" }), y.jsxs("div", { className: "relative rounded-[3rem] bg-[#080808] border border-white/10 p-12 md:p-20 text-center overflow-hidden shadow-2xl", children: [y.jsxs("div", { className: "inline-flex items-center gap-2 px-4 py-2 rounded-full bg-yellow-500/10 border border-yellow-500/20 text-yellow-500 text-sm font-bold mb-8 mx-auto reveal reveal-delay-100", children: [y.jsx(il, { size: 14, fill: "currentColor" }), " Meta Ai   AI for Power Users"] }), y.jsxs("h2", { className: "text-5xl md:text-6xl font-extrabold text-white mb-6 tracking-tight reveal reveal-delay-200", children: ["Stop Manually ", y.jsx("span", { className: "text-primary", children: "Clicking" })] }), y.jsx("p", { className: "text-lg text-slate-400 max-w-2xl mx-auto mb-12 leading-relaxed reveal reveal-delay-300", children: "Every hour you spend manually generating is wasted. Use our Meta Ai   auto downloader and prompt automator to reclaim your time." }), y.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-8 mb-12 text-sm font-bold text-slate-300 reveal reveal-delay-300", children: [y.jsxs("div", { className: "flex items-center justify-center gap-2", children: [y.jsx(ah, { size: 18, className: "text-primary" }), " Save 20+ hours/mo"] }), y.jsxs("div", { className: "flex items-center justify-center gap-2", children: [y.jsx(il, { size: 18, className: "text-primary" }), " Bulk Generate 10k+"] }), y.jsxs("div", { className: "flex items-center justify-center gap-2", children: [y.jsx(Lu, { size: 18, className: "text-primary" }), " Safe Automation"] })] }), y.jsxs("div", { className: "flex flex-col items-center gap-6 reveal reveal-delay-300", children: [y.jsxs(Ft, { size: "lg", className: "w-full md:w-auto shadow-[0_0_40px_rgba(250,204,21,0.3)] !text-xl !py-5", onClick: () => window.open(Zi, "_blank"), children: [i.cta.title, " ", y.jsx(g, { className: "mx-2", size: 24 })] }), y.jsx("p", { className: "text-xs text-slate-500 font-medium uppercase tracking-widest", children: "Best Meta Ai   Extensions  Lifetime updates  30-day money-back" })] })] })] }) }) }), y.jsx("section", { id: "comparison", className: "py-24 relative section-glow scroll-mt-32", children: y.jsxs("div", { className: "max-w-7xl mx-auto px-6", children: [y.jsxs("div", { className: "text-center mb-16 relative reveal", children: [y.jsxs("h2", { className: "text-4xl md:text-5xl font-extrabold mb-4 uppercase italic inline-block relative text-white", children: [i.comparison.title, " ", y.jsx("span", { className: "text-primary", children: "MetaAi Automator" }), y.jsx("svg", { className: "absolute -bottom-4 left-0 w-full", fill: "none", height: "12", viewBox: "0 0 200 12", xmlns: "http://www.w3.org/2000/svg", children: y.jsx("path", { d: "M2 10C30 3 170 3 198 10", stroke: "#FACC15", strokeLinecap: "round", strokeWidth: "4" }) })] }), y.jsx("p", { className: "text-slate-400 mt-6", children: "Why we are the premium Meta Ai  Automator alternative." })] }), y.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-8", children: [y.jsxs("div", { className: "p-10 rounded-[3rem] border border-white/5 bg-surface/40 backdrop-blur-md relative overflow-hidden group shadow-lg reveal reveal-delay-100", children: [y.jsx("div", { className: "absolute top-0 right-0 p-8 opacity-10 group-hover:opacity-20 transition-opacity", children: y.jsx(ah, { size: 120 }) }), y.jsxs("div", { className: "text-rose-500 font-black text-xl mb-8 flex items-center gap-2", children: [y.jsx(ka, { size: 28 }), " ", i.comparison.manual] }), y.jsx("div", { className: "space-y-8", children: [{ t: "One by One Generation", d: "Manually typing prompts. No Meta Ai   multiple images at once capability." }, { t: "Right-Click Save", d: "No Meta Ai   auto downloader. Saving files takes hours." }, { t: "Risk of Bans", d: "Spam clicking triggers bot detection quickly." }].map((v, p) => y.jsxs("div", { className: "flex gap-4", children: [y.jsx("div", { className: "w-12 h-12 shrink-0 rounded-full bg-rose-500/10 flex items-center justify-center text-rose-500", children: y.jsx(ka, { size: 20 }) }), y.jsxs("div", { children: [y.jsx("h4", { className: "font-bold text-lg text-slate-200", children: v.t }), y.jsx("p", { className: "text-slate-500 text-sm", children: v.d })] })] }, p)) }), y.jsxs("div", { className: "mt-12 p-8 rounded-[2rem] bg-rose-500/5 border border-rose-500/20 text-center", children: [y.jsx("div", { className: "text-xs font-bold text-rose-400 uppercase tracking-widest mb-1", children: "Total Effort" }), y.jsx("div", { className: "text-3xl font-black text-rose-500", children: i.comparison.manualEffort })] })] }), y.jsxs("div", { className: "p-10 rounded-[3rem] neon-border bg-primary/5 backdrop-blur-md relative overflow-hidden group shadow-[0_0_30px_rgba(250,204,21,0.15)] reveal reveal-delay-300", children: [y.jsx("div", { className: "absolute top-0 right-0 p-8 opacity-10 group-hover:opacity-30 transition-opacity", children: y.jsx(il, { size: 120, className: "text-primary" }) }), y.jsxs("div", { className: "text-primary font-black text-xl mb-8 flex items-center gap-2", children: [y.jsx(zt, { size: 28 }), " ", i.comparison.automated] }), y.jsx("div", { className: "space-y-8", children: [{ t: "Meta Ai   AI Batch Processing", d: "Upload 10,000 prompts. We automate Meta Ai   prompts entirely." }, { t: "Auto Downloader Included", d: "We answer 'how to download all images from Meta Ai  ' automatically." }, { t: "Smart Pacing Engine", d: "Proprietary algorithm stays under the radar. The safe Meta Ai   AI for power users." }].map((v, p) => y.jsxs("div", { className: "flex gap-4", children: [y.jsx("div", { className: "w-12 h-12 shrink-0 rounded-full bg-primary/20 flex items-center justify-center text-primary shadow-[0_0_15px_rgba(250,204,21,0.3)]", children: y.jsx(zt, { size: 20 }) }), y.jsxs("div", { children: [y.jsx("h4", { className: "font-bold text-lg text-white", children: v.t }), y.jsx("p", { className: "text-slate-400 text-sm", children: v.d })] })] }, p)) }), y.jsxs("div", { className: "mt-12 p-8 rounded-[2rem] bg-primary/20 border border-primary/40 text-center shadow-[0_0_30px_rgba(250,204,21,0.2)]", children: [y.jsx("div", { className: "text-xs font-bold text-primary uppercase tracking-widest mb-1", children: "Total Effort" }), y.jsx("div", { className: "text-3xl font-black text-primary", children: i.comparison.autoEffort })] })] })] })] }) }), y.jsx("section", { id: "features", className: "py-24 bg-black relative scroll-mt-32", children: y.jsxs("div", { className: "max-w-7xl mx-auto px-6", children: [y.jsxs("div", { className: "text-center mb-16 reveal", children: [y.jsxs("h2", { className: "text-4xl md:text-5xl font-extrabold mb-4 text-white", children: ["Best Meta Ai   ", y.jsx("span", { className: "text-primary", children: "Extensions" }), " Features"] }), y.jsx("p", { className: "text-slate-400 max-w-2xl mx-auto", children: 'Built for those asking "How to bulk generate images in Meta Ai  ?". Every feature is designed for scale.' })] }), y.jsx("div", { className: "flex flex-wrap justify-center gap-6", children: cS.map((v, p) => y.jsxs("div", { className: `w-full md:w-[calc(50%-12px)] lg:w-[calc(25%-18px)] bg-primary border border-primary/50 rounded-[2.5rem] p-8 hover:scale-105 transition-all duration-300 group shadow-lg flex flex-col reveal reveal-delay-${p % 4 * 100}`, children: [y.jsx("div", { className: "w-14 h-14 rounded-2xl bg-black text-primary flex items-center justify-center mb-6 group-hover:rotate-12 transition-transform shadow-xl", children: y.jsx(v.icon, { size: 28 }) }), y.jsx("h3", { className: "font-extrabold text-black mb-3 text-lg leading-tight", children: v.title }), y.jsx("p", { className: "text-zinc-800 text-sm leading-relaxed font-medium", children: v.desc })] }, p)) })] }) }), y.jsx("section", { id: "generator", className: "py-24 relative section-glow scroll-mt-32", children: y.jsxs("div", { className: "max-w-6xl mx-auto px-6 reveal", children: [y.jsxs("div", { className: "text-center mb-16", children: [y.jsxs("h2", { className: "text-4xl md:text-5xl font-extrabold mb-4 uppercase text-white leading-tight", children: ["Automate Meta Ai   ", y.jsx("br", {}), y.jsxs("span", { className: "relative inline-block mt-3", children: [y.jsx("span", { className: "font-handwriting absolute -top-5 -left-8 text-white text-2xl md:text-3xl -rotate-12 drop-shadow-md", children: "Smart" }), y.jsx("span", { className: "yellow-gradient-text relative z-10 px-6", children: "Prompts" }), y.jsx(Pp, { className: "-left-1 -top-2 w-[110%] h-[120%] -rotate-1" })] })] }), y.jsx("p", { className: "text-slate-400 mt-8", children: "Experience Meta Ai   workflow automation. See how we transform keywords into prompts." })] }), y.jsx(Eb, {})] }) }), y.jsxs("section", { id: "testimonials", className: "py-24 relative section-glow overflow-hidden scroll-mt-32 reveal", children: [y.jsx("div", { className: "text-center mb-16 relative px-6", children: y.jsxs("h2", { className: "text-4xl md:text-5xl font-extrabold italic inline-block relative text-white", children: ["Rated #1 of ", y.jsx("span", { className: "text-primary", children: "Best Meta Ai   Extensions" }), y.jsx("svg", { className: "absolute -bottom-4 left-0 w-full", fill: "none", height: "12", viewBox: "0 0 200 12", xmlns: "http://www.w3.org/2000/svg", children: y.jsx("path", { d: "M5 10C40 2 160 2 195 10", stroke: "#FACC15", strokeLinecap: "round", strokeWidth: "4" }) })] }) }), y.jsx("div", { className: "w-full inline-flex flex-nowrap overflow-hidden [mask-image:_linear-gradient(to_right,transparent_0,_black_128px,_black_calc(100%-128px),transparent_100%)]", children: y.jsx("ul", { className: "flex items-center justify-center md:justify-start [&_li]:mx-4 [&_img]:max-w-none animate-scroll hover:pause", children: [...Vp, ...Vp].map((v, p) => y.jsx("li", { className: "w-[350px] md:w-[450px] flex-shrink-0", children: y.jsxs("div", { className: `h-full p-8 rounded-[2.5rem] bg-surface/50 backdrop-blur-sm border border-white/5 hover:border-primary/40 transition-all group shadow-lg hover:shadow-[0_0_20px_rgba(250,204,21,0.1)] ${v.highlight ? "border-primary bg-surface/80" : ""}`, children: [y.jsx("div", { className: "flex gap-1 text-primary mb-6", children: [...Array(v.rating)].map((x, T) => y.jsx(jx, { size: 16, fill: "currentColor" }, T)) }), y.jsxs("p", { className: `mb-8 italic leading-relaxed ${v.highlight ? "text-white font-medium" : "text-slate-300"}`, children: ['"', v.quote, '"'] }), y.jsxs("div", { className: "flex items-center gap-4", children: [y.jsx("img", { alt: v.name, className: `w-12 h-12 rounded-full object-cover ${v.highlight ? "border-2 border-primary shadow-[0_0_10px_rgba(250,204,21,0.5)]" : "border border-primary/30"}`, src: v.img }), y.jsxs("div", { children: [y.jsx("div", { className: `font-bold ${v.highlight ? "text-primary" : "text-white"}`, children: v.name }), y.jsx("div", { className: "text-xs text-slate-500 font-bold uppercase", children: v.role })] })] })] }) }, p)) }) })] }), y.jsx("section", { id: "pricing", className: "py-24 relative section-glow scroll-mt-32", children: y.jsxs("div", { className: "max-w-7xl mx-auto px-6", children: [y.jsxs("div", { className: "text-center mb-16 reveal", children: [y.jsxs("div", { className: "inline-flex items-center gap-3 px-8 py-3 rounded-full bg-rose-500/10 border border-rose-500/20 text-rose-500 text-lg md:text-xl font-bold mb-8 animate-pulse shadow-[0_0_30px_rgba(244,63,94,0.2)]", children: [y.jsx(il, { size: 24, fill: "currentColor" }), y.jsxs("span", { children: ["Limited: Export Meta Ai   AI Images in Bulk ", y.jsx("span", { className: "underline decoration-wavy", children: "50% OFF" })] })] }), y.jsxs("h2", { className: "text-4xl md:text-5xl font-extrabold mb-4 uppercase text-white", children: [i.pricing.title, " ", y.jsx("span", { className: "text-primary", children: "Now" })] }), y.jsx("p", { className: "text-slate-400", children: "Better than free MetaAi Automator tools. Professional support included." })] }), y.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-8 max-w-5xl mx-auto items-center", children: [y.jsxs("div", { className: "p-8 rounded-[2rem] bg-surface/40 border border-white/5 hover:border-white/10 transition-all text-center group relative reveal reveal-delay-200", children: [y.jsx("h3", { className: "font-bold text-xl text-slate-300 mb-2", children: i.pricing.monthly }), y.jsxs("div", { className: "flex items-center justify-center gap-2 mb-6", children: [y.jsx("span", { className: "text-slate-500 line-through text-lg", children: "6.99" }), y.jsx("span", { className: "text-4xl font-black text-white", children: "1.99" }), y.jsx("span", { className: "text-sm text-slate-500", children: "/mo" })] }), y.jsxs("ul", { className: "space-y-4 mb-8 text-left text-sm text-slate-300", children: [y.jsxs("li", { className: "flex gap-2", children: [y.jsx(zt, { size: 16, className: "text-primary" }), " Meta Ai   AI batch processing"] }), y.jsxs("li", { className: "flex gap-2", children: [y.jsx(zt, { size: 16, className: "text-primary" }), " Auto Downloader"] }), y.jsxs("li", { className: "flex gap-2", children: [y.jsx(zt, { size: 16, className: "text-primary" }), " Auto-Save to Disk"] })] }), y.jsx(Ft, { variant: "secondary", className: "w-full", onClick: () => window.open(Zi, "_blank"), children: i.pricing.monthly })] }), y.jsxs("div", { className: "p-8 rounded-[2.5rem] bg-surface/80 border-2 border-primary shadow-[0_0_50px_rgba(250,204,21,0.15)] text-center relative transform md:-translate-y-4 z-10 reveal reveal-delay-100", children: [y.jsx("div", { className: "absolute top-0 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-primary text-black px-4 py-1 rounded-full text-xs font-black uppercase tracking-widest shadow-lg whitespace-nowrap", children: i.pricing.mostPopular }), y.jsx("h3", { className: "font-bold text-primary mb-2", children: i.pricing.yearly }), y.jsxs("div", { className: "flex items-center justify-center gap-2 mb-6", children: [y.jsx("span", { className: "text-slate-500 line-through text-lg", children: "59.99" }), y.jsx("span", { className: "text-5xl font-black text-white", children: "14.99" }), y.jsx("span", { className: "text-sm text-slate-500", children: "/yr" })] }), y.jsx("p", { className: "text-xs text-green-400 font-bold mb-6", children: i.pricing.save }), y.jsxs("ul", { className: "space-y-4 mb-8 text-left text-sm text-slate-200", children: [y.jsxs("li", { className: "flex gap-2", children: [y.jsx(zt, { size: 16, className: "text-primary" }), " Meta Ai   auto downloader"] }), y.jsxs("li", { className: "flex gap-2", children: [y.jsx(zt, { size: 16, className: "text-primary" }), " Priority Support"] }), y.jsxs("li", { className: "flex gap-2", children: [y.jsx(zt, { size: 16, className: "text-primary" }), " Meta Ai   AI multiple images"] }), y.jsxs("li", { className: "flex gap-2", children: [y.jsx(zt, { size: 16, className: "text-primary" }), " Cancel Anytime"] })] }), y.jsx(Ft, { className: "w-full py-4 text-lg", onClick: () => window.open(Zi, "_blank"), children: i.pricing.yearly })] }), y.jsxs("div", { className: "p-8 rounded-[2rem] bg-surface/40 border border-white/5 hover:border-white/10 transition-all text-center group relative reveal reveal-delay-300", children: [y.jsx("h3", { className: "font-bold text-xl text-slate-300 mb-2", children: i.pricing.lifetime }), y.jsxs("div", { className: "flex items-center justify-center gap-2 mb-6", children: [y.jsx("span", { className: "text-slate-500 line-through text-lg", children: "99.99" }), y.jsx("span", { className: "text-4xl font-black text-white", children: "29.99" })] }), y.jsx("p", { className: "text-sm text-slate-500 mb-6", children: i.pricing.oneTime }), y.jsxs("ul", { className: "space-y-4 mb-8 text-left text-sm text-slate-300", children: [y.jsxs("li", { className: "flex gap-2", children: [y.jsx(zt, { size: 16, className: "text-primary" }), " Lifetime Updates"] }), y.jsxs("li", { className: "flex gap-2", children: [y.jsx(zt, { size: 16, className: "text-primary" }), " No Recurring Fees"] }), y.jsxs("li", { className: "flex gap-2", children: [y.jsx(zt, { size: 16, className: "text-primary" }), " Commercial License"] })] }), y.jsx(Ft, { variant: "secondary", className: "w-full", onClick: () => window.open(Zi, "_blank"), children: i.pricing.lifetime })] })] })] }) }), y.jsx("section", { id: "faq", className: "py-24 relative section-glow scroll-mt-32", children: y.jsxs("div", { className: "max-w-3xl mx-auto px-6 reveal", children: [y.jsxs("h2", { className: "text-4xl font-extrabold text-center mb-16 italic text-white", children: ["Meta Ai   ", y.jsx("span", { className: "text-primary", children: i.faq.title })] }), y.jsx("div", { className: "space-y-4", children: i.faq.items.map((v, p) => y.jsxs("div", { className: "group reveal reveal-delay-100", children: [y.jsxs("button", { onClick: () => m(p), className: "w-full flex items-center justify-between p-6 rounded-[2rem] bg-surface/50 backdrop-blur-sm border border-white/10 cursor-pointer hover:border-primary/40 transition-all hover:bg-surface/70", children: [y.jsx("span", { className: "font-bold text-lg text-left text-white pl-4 rtl:pr-4 rtl:pl-0", children: v.q }), y.jsx(Jv, { className: `transition-transform text-primary ${l === p ? "rotate-180" : ""} mx-2` })] }), y.jsx("div", { className: `overflow-hidden transition-all duration-300 ${l === p ? "max-h-48 opacity-100" : "max-h-0 opacity-0"}`, children: y.jsx("div", { className: "p-8 text-slate-400 bg-surface/30 rounded-b-[2rem] border-x border-b border-white/10 mx-2 mb-2", children: v.a }) })] }, p)) })] }) }), y.jsx("section", { className: "py-24 bg-black", children: y.jsxs("div", { className: "max-w-5xl mx-auto px-6 text-center reveal", children: [y.jsx("h2", { className: "text-5xl md:text-7xl font-black mb-6 leading-none text-white tracking-tighter", children: i.cta.title }), y.jsx("p", { className: "text-xl md:text-2xl text-slate-400 max-w-2xl mx-auto mb-12", children: i.cta.subtitle }), y.jsxs("div", { className: "flex flex-col items-center gap-6", children: [y.jsxs(Ft, { size: "lg", className: "px-10 py-5 text-xl", onClick: () => window.open(Zi, "_blank"), children: ["Automate Meta Ai   ", y.jsx(g, { className: "mx-2" })] }), y.jsxs("div", { className: "flex items-center gap-6 text-sm font-medium text-slate-500", children: [y.jsxs("span", { className: "flex items-center gap-2", children: [y.jsx("span", { className: "w-1.5 h-1.5 rounded-full bg-primary" }), " No credit card required"] }), y.jsxs("span", { className: "flex items-center gap-2", children: [y.jsx("span", { className: "w-1.5 h-1.5 rounded-full bg-primary" }), " Chrome extensions for Google Labs"] })] })] })] }) }), r && y.jsx("div", { className: "fixed inset-0 z-[100] flex items-center justify-center bg-black/80 backdrop-blur-sm p-4 animate-fade-in", onClick: () => d(!1), children: y.jsxs("div", { className: "relative w-full max-w-5xl aspect-video bg-surface/95 backdrop-blur-md rounded-[2.5rem] border-2 border-primary shadow-[0_0_80px_rgba(250,204,21,0.4)] overflow-hidden animate-scale-in", onClick: v => v.stopPropagation(), children: [y.jsx("button", { onClick: () => d(!1), className: "absolute top-4 right-4 z-10 w-12 h-12 bg-black/80 hover:bg-primary text-white hover:text-black rounded-full flex items-center justify-center transition-all duration-300 shadow-lg hover:scale-110 border border-white/20 hover:border-primary", "aria-label": "Close video", children: y.jsx(ka, { size: 24 }) }), y.jsx("iframe", { width: "100%", height: "100%", src: "https://www.youtube.com/embed/wCnv514L0uM?si=Xs2JRbbd3je9jZOb&autoplay=1", title: "YouTube video player", frameBorder: "0", allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share", referrerPolicy: "strict-origin-when-cross-origin", allowFullScreen: !0, className: "absolute inset-0 w-full h-full rounded-[2.5rem]" })] }) })] }) }, Cb = () => y.jsx("div", { className: "pt-32 pb-24 px-6 min-h-screen", children: y.jsxs("div", { className: "max-w-4xl mx-auto", children: [y.jsxs("div", { className: "text-center mb-16", children: [y.jsxs("h1", { className: "text-5xl font-black text-white mb-6", children: ["How can we ", y.jsx("span", { className: "text-primary", children: "help?" })] }), y.jsx("p", { className: "text-slate-400 text-xl", children: "We are here to support your automation journey." })] }), y.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-6 mb-16", children: [y.jsxs("div", { className: "p-8 rounded-3xl bg-surface border border-white/10 text-center hover:border-primary/50 transition-colors", children: [y.jsx("div", { className: "w-12 h-12 bg-primary/10 rounded-full flex items-center justify-center text-primary mx-auto mb-6", children: y.jsx(Nx, { size: 24 }) }), y.jsx("h3", { className: "font-bold text-white text-lg mb-2", children: "Email Support" }), y.jsx("p", { className: "text-slate-400 text-sm mb-6", children: "Get a response within 24 hours." }), y.jsx("a", { href: "mailto:support@metaaiautomator.com", className: "text-primary font-bold hover:underline", children: "support@Meta Ai  .com" })] }), y.jsxs("div", { className: "p-8 rounded-3xl bg-surface border border-white/10 text-center hover:border-primary/50 transition-colors", children: [y.jsx("div", { className: "w-12 h-12 bg-primary/10 rounded-full flex items-center justify-center text-primary mx-auto mb-6", children: y.jsx(Ix, { size: 24 }) }), y.jsx("h3", { className: "font-bold text-white text-lg mb-2", children: "Live Chat" }), y.jsx("p", { className: "text-slate-400 text-sm mb-6", children: "Available Mon-Fri, 9am-5pm EST." }), y.jsx("span", { className: "text-slate-500 font-bold cursor-not-allowed", children: "Offline" })] }), y.jsxs("div", { className: "p-8 rounded-3xl bg-surface border border-white/10 text-center hover:border-primary/50 transition-colors", children: [y.jsx("div", { className: "w-12 h-12 bg-primary/10 rounded-full flex items-center justify-center text-primary mx-auto mb-6", children: y.jsx(Xp, { size: 24 }) }), y.jsx("h3", { className: "font-bold text-white text-lg mb-2", children: "Documentation" }), y.jsx("p", { className: "text-slate-400 text-sm mb-6", children: "Step-by-step guides and API refs." }), y.jsx("span", { className: "text-primary font-bold hover:underline cursor-pointer", children: "View Docs" })] })] }), y.jsxs("div", { className: "bg-surface/50 border border-white/10 rounded-[2.5rem] p-8 md:p-12", children: [y.jsx("h2", { className: "text-3xl font-bold text-white mb-8 text-center", children: "Send us a message" }), y.jsxs("form", { className: "space-y-6 max-w-2xl mx-auto", children: [y.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6", children: [y.jsxs("div", { className: "space-y-2", children: [y.jsx("label", { className: "text-sm font-bold text-slate-300", children: "Name" }), y.jsx("input", { type: "text", className: "w-full px-5 py-3 rounded-xl bg-black border border-white/10 text-white focus:border-primary outline-none transition-colors", placeholder: "John Doe" })] }), y.jsxs("div", { className: "space-y-2", children: [y.jsx("label", { className: "text-sm font-bold text-slate-300", children: "Email" }), y.jsx("input", { type: "email", className: "w-full px-5 py-3 rounded-xl bg-black border border-white/10 text-white focus:border-primary outline-none transition-colors", placeholder: "john@example.com" })] })] }), y.jsxs("div", { className: "space-y-2", children: [y.jsx("label", { className: "text-sm font-bold text-slate-300", children: "Subject" }), y.jsxs("select", { className: "w-full px-5 py-3 rounded-xl bg-black border border-white/10 text-white focus:border-primary outline-none transition-colors", children: [y.jsx("option", { children: "General Inquiry" }), y.jsx("option", { children: "Technical Support" }), y.jsx("option", { children: "Billing" }), y.jsx("option", { children: "Feature Request" })] })] }), y.jsxs("div", { className: "space-y-2", children: [y.jsx("label", { className: "text-sm font-bold text-slate-300", children: "Message" }), y.jsx("textarea", { className: "w-full px-5 py-3 rounded-xl bg-black border border-white/10 text-white focus:border-primary outline-none transition-colors min-h-[150px]", placeholder: "How can we help you today?" })] }), y.jsx("div", { className: "text-center pt-4", children: y.jsx(Ft, { className: "w-full md:w-auto", children: "Send Message" }) })] })] })] }) }), bb = () => { const [i, t] = ze.useState("getting-started"), l = [{ id: "getting-started", label: "Getting Started", icon: Vv }, { id: "installation", label: "Installation", icon: tS }, { id: "configuration", label: "Configuration", icon: jp }, { id: "troubleshooting", label: "Troubleshooting", icon: jv }]; return y.jsx("div", { className: "pt-32 pb-24 px-6 min-h-screen", children: y.jsxs("div", { className: "max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-12 gap-12", children: [y.jsx("div", { className: "lg:col-span-3", children: y.jsxs("div", { className: "sticky top-32 space-y-2", children: [y.jsx("h3", { className: "text-sm font-bold text-slate-500 uppercase tracking-widest mb-4 px-4", children: "Docs Navigation" }), l.map(a => y.jsxs("button", { onClick: () => t(a.id), className: `w-full flex items-center gap-3 px-4 py-3 rounded-xl text-sm font-bold transition-all ${i === a.id ? "bg-primary text-black shadow-[0_0_15px_rgba(250,204,21,0.4)]" : "text-slate-400 hover:bg-white/5 hover:text-white"}`, children: [y.jsx(a.icon, { size: 18 }), a.label, i === a.id && y.jsx(Wp, { size: 14, className: "ml-auto" })] }, a.id))] }) }), y.jsx("div", { className: "lg:col-span-9", children: y.jsxs("div", { className: "bg-surface/30 border border-white/10 rounded-[2.5rem] p-8 md:p-12 min-h-[600px]", children: [i === "getting-started" && y.jsxs("div", { className: "space-y-6 animate-in fade-in slide-in-from-bottom-4 duration-500", children: [y.jsx("h1", { className: "text-4xl font-black text-white mb-8", children: "Getting Started with Meta Ai  " }), y.jsx("p", { className: "text-slate-300 text-lg leading-relaxed", children: "MetaAi Automator is a powerful Chrome Extension designed to streamline your AI image generation workflow. Whether you are using Midjourney, Stable Diffusion, or other web-based generators, Meta Ai   helps you scale from dozens to thousands of images effortlessly." }), y.jsxs("div", { className: "p-6 rounded-2xl bg-primary/10 border border-primary/20", children: [y.jsx("h4", { className: "font-bold text-primary mb-2", children: "Key Concepts" }), y.jsxs("ul", { className: "list-disc list-inside text-slate-300 space-y-2", children: [y.jsxs("li", { children: [y.jsx("strong", { className: "text-white", children: "Batch Processing:" }), " Upload CSVs of prompts."] }), y.jsxs("li", { children: [y.jsx("strong", { className: "text-white", children: "Smart Personas:" }), " Let AI rewrite your prompts."] }), y.jsxs("li", { children: [y.jsx("strong", { className: "text-white", children: "Auto-Capture:" }), " Automatically download generated images."] })] })] })] }), i === "installation" && y.jsxs("div", { className: "space-y-6 animate-in fade-in slide-in-from-bottom-4 duration-500", children: [y.jsx("h1", { className: "text-4xl font-black text-white mb-8", children: "Installation Guide" }), y.jsxs("div", { className: "space-y-8", children: [y.jsxs("div", { children: [y.jsx("h3", { className: "text-2xl font-bold text-white mb-4", children: "Step 1: Download Extension" }), y.jsx("p", { className: "text-slate-300 mb-4", children: "You can install MetaAi Automator directly from the Chrome Web Store or manually via Developer Mode." }), y.jsx("div", { className: "bg-black p-4 rounded-xl font-mono text-sm text-slate-400 border border-white/10 break-all", children: "https://chromewebstore.google.com/detail/oahcpmhnmcfjciaehfijhfjofjddjjij" })] }), y.jsxs("div", { children: [y.jsx("h3", { className: "text-2xl font-bold text-white mb-4", children: "Step 2: Pin to Toolbar" }), y.jsx("p", { className: "text-slate-300", children: "Click the puzzle piece icon in Chrome and pin MetaAi Automator for easy access." })] }), y.jsxs("div", { children: [y.jsx("h3", { className: "text-2xl font-bold text-white mb-4", children: "Step 3: Login" }), y.jsx("p", { className: "text-slate-300", children: "Open the extension and log in with your account credentials to sync your license." })] })] })] }), i === "configuration" && y.jsxs("div", { className: "space-y-6 animate-in fade-in slide-in-from-bottom-4 duration-500", children: [y.jsx("h1", { className: "text-4xl font-black text-white mb-8", children: "Configuration" }), y.jsx("p", { className: "text-slate-300", children: "Learn how to tweak the Human-Flow algorithm settings for maximum safety and speed." }), y.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6 mt-8", children: [y.jsxs("div", { className: "p-6 rounded-2xl bg-black border border-white/10", children: [y.jsx("h4", { className: "font-bold text-white mb-2", children: "Delay Settings" }), y.jsx("p", { className: "text-sm text-slate-400", children: "Adjust the min/max delay between actions to mimic human behavior." })] }), y.jsxs("div", { className: "p-6 rounded-2xl bg-black border border-white/10", children: [y.jsx("h4", { className: "font-bold text-white mb-2", children: "Download Path" }), y.jsx("p", { className: "text-sm text-slate-400", children: "Set the default folder where all generated assets will be saved." })] })] })] }), i === "troubleshooting" && y.jsxs("div", { className: "space-y-6 animate-in fade-in slide-in-from-bottom-4 duration-500", children: [y.jsx("h1", { className: "text-4xl font-black text-white mb-8", children: "Troubleshooting" }), y.jsxs("div", { className: "space-y-4", children: [y.jsxs("details", { className: "bg-black rounded-xl p-4 border border-white/10 cursor-pointer", children: [y.jsx("summary", { className: "font-bold text-white", children: "Extension not loading?" }), y.jsx("p", { className: "mt-4 text-slate-400 text-sm", children: "Ensure you are on a supported website (e.g. Midjourney.com or Discord web). Refresh the page." })] }), y.jsxs("details", { className: "bg-black rounded-xl p-4 border border-white/10 cursor-pointer", children: [y.jsx("summary", { className: "font-bold text-white", children: "Images not downloading?" }), y.jsx("p", { className: "mt-4 text-slate-400 text-sm", children: "Check your browser permission settings. Chrome must allow automatic downloads for the site." })] })] })] })] }) })] }) }) }, Bp = [{ id: 1, title: "How to use a prompt list with Meta Ai   AI", excerpt: "A step-by-step guide to uploading CSVs and using Meta Ai   AI batch processing for maximum efficiency.", date: "Oct 12, 2025", author: "Sarah Connor", image: "https://picsum.photos/seed/ai1/800/600", category: "Tutorial" }, { id: 2, title: "The fastest way to generate 100 images in Meta Ai  ", excerpt: "Stop clicking. Learn how to automate Meta Ai   prompts to generate 100+ coherent images in minutes.", date: "Sep 28, 2025", author: "John Matrix", image: "https://picsum.photos/seed/ai2/800/600", category: "Workflow" }, { id: 3, title: "Meta Ai   tips for designers: Exporting in Bulk", excerpt: "Why we are the best Meta Ai  Automator alternative. Learn how to export Meta Ai   AI images in bulk with metadata.", date: "Sep 15, 2025", author: "Team Meta Ai  ", image: "https://picsum.photos/seed/ai3/800/600", category: "Product" }], Su = 2, Nb = () => { const [i, t] = ze.useState(1), l = Math.ceil(Bp.length / Su); ze.useEffect(() => { const d = new URLSearchParams(window.location.search), m = parseInt(d.get("page") || "1"); !isNaN(m) && m > 0 && t(m); let g = document.querySelector("link[rel='canonical']"); g || (g = document.createElement("link"), g.setAttribute("rel", "canonical"), document.head.appendChild(g)), new URL(window.location.href), g.setAttribute("href", `https://metaaiautomator.com/?view=blog&page=${m}`) }, []); const a = d => { t(d), window.scrollTo({ top: 0, behavior: "smooth" }); const m = new URL(window.location.href); m.searchParams.set("view", "blog"), m.searchParams.set("page", d.toString()), window.history.pushState({}, "", m) }, r = Bp.slice((i - 1) * Su, i * Su); return y.jsx("div", { className: "pt-32 pb-24 px-6 min-h-screen", children: y.jsxs("div", { className: "max-w-7xl mx-auto", children: [y.jsxs("div", { className: "text-center mb-16", children: [y.jsxs("h1", { className: "text-5xl font-black text-white mb-6", children: ["Latest ", y.jsx("span", { className: "text-primary", children: "Guides" })] }), y.jsx("p", { className: "text-slate-400 text-xl", children: "Expert tutorials on Meta Ai   workflow automation." })] }), y.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8 mb-16", children: r.map(d => y.jsxs("div", { className: "group rounded-[2rem] bg-surface border border-white/10 overflow-hidden hover:border-primary/50 transition-all hover:-translate-y-2 duration-300", children: [y.jsxs("div", { className: "h-48 overflow-hidden relative", children: [y.jsx("img", { src: d.image, alt: d.title, className: "w-full h-full object-cover group-hover:scale-110 transition-transform duration-500" }), y.jsx("div", { className: "absolute top-4 left-4 bg-black/80 backdrop-blur-md text-primary text-xs font-bold px-3 py-1 rounded-full uppercase tracking-wider", children: d.category })] }), y.jsxs("div", { className: "p-8", children: [y.jsxs("div", { className: "flex items-center gap-4 text-xs text-slate-500 mb-4 font-bold uppercase tracking-widest", children: [y.jsxs("span", { className: "flex items-center gap-1", children: [y.jsx(Ov, { size: 12 }), " ", d.date] }), y.jsxs("span", { className: "flex items-center gap-1", children: [y.jsx(lS, { size: 12 }), " ", d.author] })] }), y.jsx("h3", { className: "text-2xl font-bold text-white mb-4 group-hover:text-primary transition-colors leading-tight", children: d.title }), y.jsx("p", { className: "text-slate-400 text-sm mb-6 leading-relaxed", children: d.excerpt }), y.jsxs("button", { className: "flex items-center gap-2 text-primary font-bold text-sm hover:gap-3 transition-all", children: ["Read Guide ", y.jsx(Jp, { size: 16 })] })] })] }, d.id)) }), y.jsxs("div", { className: "flex justify-center items-center gap-4", children: [y.jsx("button", { onClick: () => a(Math.max(1, i - 1)), disabled: i === 1, className: "p-3 rounded-full border border-white/10 hover:bg-white/5 disabled:opacity-30 disabled:cursor-not-allowed transition-all", children: y.jsx(Kv, { size: 20 }) }), y.jsxs("div", { className: "text-sm font-bold text-slate-400", children: ["Page ", y.jsx("span", { className: "text-white", children: i }), " of ", l] }), y.jsx("button", { onClick: () => a(Math.min(l, i + 1)), disabled: i === l, className: "p-3 rounded-full border border-white/10 hover:bg-white/5 disabled:opacity-30 disabled:cursor-not-allowed transition-all", children: y.jsx(Wp, { size: 20 }) })] })] }) }) }, wb = () => y.jsx("div", { className: "pt-32 pb-24 px-6 min-h-screen", children: y.jsxs("div", { className: "max-w-4xl mx-auto", children: [y.jsxs("div", { className: "text-center mb-16", children: [y.jsxs("h1", { className: "text-5xl font-black text-white mb-6", children: ["About ", y.jsx("span", { className: "text-primary", children: "MetaAi Automator" })] }), y.jsx("p", { className: "text-slate-400 text-xl max-w-2xl mx-auto", children: "We build tools that bridge the gap between human creativity and AI scalability." })] }), y.jsx("div", { className: "mb-20", children: y.jsxs("div", { className: "p-10 rounded-[2.5rem] bg-surface/50 border border-white/10 backdrop-blur-sm relative overflow-hidden", children: [y.jsx("div", { className: "absolute top-0 right-0 p-12 opacity-5", children: y.jsx($x, { size: 200 }) }), y.jsx("h2", { className: "text-3xl font-bold text-white mb-6 relative z-10", children: "Our Mission" }), y.jsxs("p", { className: "text-slate-300 text-lg leading-relaxed relative z-10", children: ["At MetaAi Automator, we believe that ", y.jsx("span", { className: "text-primary font-bold", children: "creativity should flow, not click" }), ". Google Labs' Meta Ai   (formerly ImageFX) is an incredible tool for generation, but its interface wasn't built for professional, high-volume workflows. We created this tool to help designers, agencies, and power users reclaim their time by automating the repetitive parts of the creative process."] })] }) }), y.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-8 mb-20", children: [y.jsxs("div", { className: "p-8 rounded-3xl bg-surface border border-white/5 hover:border-primary/30 transition-all group", children: [y.jsx("div", { className: "w-12 h-12 bg-primary/10 rounded-2xl flex items-center justify-center text-primary mb-6 group-hover:scale-110 transition-transform", children: y.jsx(Zp, { size: 24 }) }), y.jsx("h3", { className: "text-xl font-bold text-white mb-3", children: "Safety First" }), y.jsx("p", { className: "text-slate-400 leading-relaxed", children: 'We prioritize account safety above all else. Our "Human-Flow" algorithms mimic natural interaction patterns to keep your Google account secure while you automate.' })] }), y.jsxs("div", { className: "p-8 rounded-3xl bg-surface border border-white/5 hover:border-primary/30 transition-all group", children: [y.jsx("div", { className: "w-12 h-12 bg-rose-500/10 rounded-2xl flex items-center justify-center text-rose-500 mb-6 group-hover:scale-110 transition-transform", children: y.jsx(yx, { size: 24 }) }), y.jsx("h3", { className: "text-xl font-bold text-white mb-3", children: "Community Driven" }), y.jsx("p", { className: "text-slate-400 leading-relaxed", children: "MetaAi Automator started as a community script. We listen to our users' feedback daily to add features like auto-downloading and persona rewriting." })] }), y.jsxs("div", { className: "p-8 rounded-3xl bg-surface border border-white/5 hover:border-primary/30 transition-all group", children: [y.jsx("div", { className: "w-12 h-12 bg-blue-500/10 rounded-2xl flex items-center justify-center text-blue-500 mb-6 group-hover:scale-110 transition-transform", children: y.jsx(nx, { size: 24 }) }), y.jsx("h3", { className: "text-xl font-bold text-white mb-3", children: "Built for Efficiency" }), y.jsx("p", { className: "text-slate-400 leading-relaxed", children: "We optimize for speed without compromising quality. Our tools are designed to run in the background so you can focus on other tasks while your images generate." })] }), y.jsxs("div", { className: "p-8 rounded-3xl bg-surface border border-white/5 hover:border-primary/30 transition-all group", children: [y.jsx("div", { className: "w-12 h-12 bg-green-500/10 rounded-2xl flex items-center justify-center text-green-500 mb-6 group-hover:scale-110 transition-transform", children: y.jsx(Qp, { size: 24 }) }), y.jsx("h3", { className: "text-xl font-bold text-white mb-3", children: "Global Accessibility" }), y.jsx("p", { className: "text-slate-400 leading-relaxed", children: "Creativity knows no borders. We are committed to making automation accessible to creators worldwide, supporting standard browser environments." })] })] }), y.jsxs("div", { className: "flex flex-col md:flex-row items-center gap-12 bg-surface/30 p-10 rounded-[3rem] border border-white/5", children: [y.jsxs("div", { className: "flex-1", children: [y.jsx("h2", { className: "text-3xl font-bold text-white mb-6", children: "The Story" }), y.jsx("p", { className: "text-slate-300 mb-6 leading-relaxed", children: 'It began late one night in 2024. Our founder was working on a project that required 500 variations of a specific sci-fi aesthetic. After clicking "Generate" for the 50th time manually, they realized there had to be a better way.' }), y.jsx("p", { className: "text-slate-300 leading-relaxed", children: "What started as a rough Python script for personal use quickly evolved into a robust Chrome Extension used by thousands of creators. Today, MetaAi Automator is the standard for workflow efficiency in the AI art space." })] }), y.jsx("div", { className: "w-full md:w-1/3", children: y.jsxs("div", { className: "aspect-square rounded-[2rem] bg-gradient-to-br from-primary/20 to-purple-500/20 flex items-center justify-center border border-white/10 relative overflow-hidden", children: [y.jsx("div", { className: "absolute inset-0 bg-[url('https://picsum.photos/seed/tech/800')] opacity-30 bg-cover bg-center mix-blend-overlay" }), y.jsx(sS, { size: 64, className: "text-white relative z-10" })] }) })] })] }) }), Mb = () => y.jsx("div", { className: "pt-32 pb-24 px-6 min-h-screen", children: y.jsxs("div", { className: "max-w-4xl mx-auto", children: [y.jsxs("div", { className: "mb-16", children: [y.jsxs("h1", { className: "text-4xl md:text-5xl font-black text-white mb-6", children: ["Privacy ", y.jsx("span", { className: "text-primary", children: "Policy" })] }), y.jsx("p", { className: "text-slate-400 text-lg", children: "Last Updated: May 20, 2025" })] }), y.jsxs("div", { className: "bg-surface/30 border border-white/10 rounded-[2.5rem] p-8 md:p-12 space-y-12", children: [y.jsxs("section", { children: [y.jsxs("div", { className: "flex items-center gap-3 mb-6", children: [y.jsx("div", { className: "w-10 h-10 rounded-xl bg-primary/10 flex items-center justify-center text-primary", children: y.jsx(Lu, { size: 20 }) }), y.jsx("h2", { className: "text-2xl font-bold text-white", children: "1. Introduction" })] }), y.jsx("p", { className: "text-slate-300 leading-relaxed", children: 'MetaAi Automator ("we," "our," or "us") values your privacy. This Privacy Policy explains how we collect, use, and share information about you when you use our website (metaaiautomator.com) and our Chrome Extension. We are committed to ensuring that your personal information is protected and never misused.' })] }), y.jsxs("section", { children: [y.jsxs("div", { className: "flex items-center gap-3 mb-6", children: [y.jsx("div", { className: "w-10 h-10 rounded-xl bg-blue-500/10 flex items-center justify-center text-blue-500", children: y.jsx(dx, { size: 20 }) }), y.jsx("h2", { className: "text-2xl font-bold text-white", children: "2. Information We Collect" })] }), y.jsxs("div", { className: "space-y-4 text-slate-300 leading-relaxed", children: [y.jsx("p", { children: "We believe in data minimization. We only collect what is strictly necessary:" }), y.jsxs("ul", { className: "list-disc pl-6 space-y-3", children: [y.jsxs("li", { children: [y.jsx("strong", { children: "Local Data:" }), " Your generated prompts, history, and settings are stored locally on your device using Chrome's ", y.jsx("code", { children: "local.storage" }), " API. We do not transmit this data to our servers."] }), y.jsxs("li", { children: [y.jsx("strong", { children: "Account Information:" }), " If you purchase a premium license, we collect your email address and payment confirmation via our payment processor (Stripe/LemonSqueezy) to validate your license."] }), y.jsxs("li", { children: [y.jsx("strong", { children: "AI Interaction:" }), ' When using the "Smart Prompts" feature, your keywords are sent to Google Gemini APIs to generate text. This data is not stored by us.'] })] })] })] }), y.jsxs("section", { children: [y.jsxs("div", { className: "flex items-center gap-3 mb-6", children: [y.jsx("div", { className: "w-10 h-10 rounded-xl bg-green-500/10 flex items-center justify-center text-green-500", children: y.jsx(Yx, { size: 20 }) }), y.jsx("h2", { className: "text-2xl font-bold text-white", children: "3. How We Use Your Information" })] }), y.jsx("p", { className: "text-slate-300 leading-relaxed mb-4", children: "We use the information we collect for the following purposes:" }), y.jsxs("ul", { className: "list-disc pl-6 space-y-2 text-slate-300", children: [y.jsx("li", { children: "To provide and maintain the functionality of the MetaAi Automator extension." }), y.jsx("li", { children: "To verify your premium license status." }), y.jsx("li", { children: "To provide customer support when you contact us." }), y.jsx("li", { children: "To detect and prevent fraudulent use of our software." })] })] }), y.jsxs("section", { children: [y.jsx("h2", { className: "text-2xl font-bold text-white mb-6", children: "4. Third-Party Services" }), y.jsx("p", { className: "text-slate-300 leading-relaxed mb-4", children: "We may employ third-party companies and individuals to facilitate our Service. These third parties have access to your Personal Data only to perform these tasks on our behalf and are obligated not to disclose or use it for any other purpose." }), y.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4 mt-6", children: [y.jsxs("div", { className: "p-4 rounded-xl bg-black border border-white/5", children: [y.jsx("h4", { className: "font-bold text-white mb-1", children: "Google Gemini API" }), y.jsx("p", { className: "text-xs text-slate-500", children: "Used for generating smart prompts. Data is processed according to Google's AI Principles." })] }), y.jsxs("div", { className: "p-4 rounded-xl bg-black border border-white/5", children: [y.jsx("h4", { className: "font-bold text-white mb-1", children: "Stripe / LemonSqueezy" }), y.jsx("p", { className: "text-xs text-slate-500", children: "Used for secure payment processing. We do not store credit card details." })] })] })] }), y.jsxs("section", { children: [y.jsxs("div", { className: "flex items-center gap-3 mb-6", children: [y.jsx("div", { className: "w-10 h-10 rounded-xl bg-rose-500/10 flex items-center justify-center text-rose-500", children: y.jsx(Cx, { size: 20 }) }), y.jsx("h2", { className: "text-2xl font-bold text-white", children: "5. Data Security" })] }), y.jsx("p", { className: "text-slate-300 leading-relaxed", children: "We value your trust in providing us your Personal Information, thus we are striving to use commercially acceptable means of protecting it. But remember that no method of transmission over the internet, or method of electronic storage is 100% secure and reliable, and we cannot guarantee its absolute security." })] }), y.jsxs("section", { className: "pt-8 border-t border-white/10", children: [y.jsx("h2", { className: "text-2xl font-bold text-white mb-4", children: "6. Contact Us" }), y.jsx("p", { className: "text-slate-300 leading-relaxed mb-4", children: "If you have any questions or suggestions about our Privacy Policy, do not hesitate to contact us." }), y.jsx("a", { href: "mailto:privacy@metaaiautomator.com", className: "text-primary font-bold hover:underline", children: "privacy@metaaiautomator.com" })] })] })] }) }), Rb = () => y.jsx("div", { className: "pt-32 pb-24 px-6 min-h-screen", children: y.jsxs("div", { className: "max-w-4xl mx-auto", children: [y.jsxs("div", { className: "mb-16", children: [y.jsxs("h1", { className: "text-4xl md:text-5xl font-black text-white mb-6", children: ["Cookie ", y.jsx("span", { className: "text-primary", children: "Policy" })] }), y.jsx("p", { className: "text-slate-400 text-lg", children: "Last Updated: May 20, 2025" })] }), y.jsxs("div", { className: "bg-surface/30 border border-white/10 rounded-[2.5rem] p-8 md:p-12 space-y-12", children: [y.jsxs("section", { children: [y.jsxs("div", { className: "flex items-center gap-3 mb-6", children: [y.jsx("div", { className: "w-10 h-10 rounded-xl bg-primary/10 flex items-center justify-center text-primary", children: y.jsx(ox, { size: 20 }) }), y.jsx("h2", { className: "text-2xl font-bold text-white", children: "1. What Are Cookies?" })] }), y.jsx("p", { className: "text-slate-300 leading-relaxed mb-4", children: "Cookies are small text files that are placed on your computer or mobile device when you visit a website. They are widely used to make websites work more efficiently and to provide information to the owners of the site." }), y.jsxs("p", { className: "text-slate-300 leading-relaxed", children: ["At MetaAi Automator, we prioritize local processing. Most of your data is stored in your browser's ", y.jsx("strong", { children: "Local Storage" }), " rather than traditional tracking cookies."] })] }), y.jsxs("section", { children: [y.jsxs("div", { className: "flex items-center gap-3 mb-6", children: [y.jsx("div", { className: "w-10 h-10 rounded-xl bg-blue-500/10 flex items-center justify-center text-blue-500", children: y.jsx(jp, { size: 20 }) }), y.jsx("h2", { className: "text-2xl font-bold text-white", children: "2. How We Use Cookies & Local Storage" })] }), y.jsxs("div", { className: "space-y-6", children: [y.jsxs("div", { className: "p-6 rounded-2xl bg-black border border-white/5", children: [y.jsx("h3", { className: "font-bold text-white mb-2 text-lg", children: "Strictly Necessary" }), y.jsx("p", { className: "text-slate-400 text-sm leading-relaxed", children: "These are essential for the website and extension to function. For example, we use Local Storage to save your:" }), y.jsxs("ul", { className: "list-disc list-inside mt-2 text-slate-400 text-sm", children: [y.jsx("li", { children: "API Key configurations (stored locally on your device)" }), y.jsx("li", { children: "Extension settings (delay timers, download paths)" }), y.jsx("li", { children: "Theme preferences" })] })] }), y.jsxs("div", { className: "p-6 rounded-2xl bg-black border border-white/5", children: [y.jsx("h3", { className: "font-bold text-white mb-2 text-lg", children: "Functionality" }), y.jsx("p", { className: "text-slate-400 text-sm leading-relaxed", children: "These allow us to remember choices you make. We do not use these to track your browsing activity on other websites." })] }), y.jsxs("div", { className: "p-6 rounded-2xl bg-black border border-white/5", children: [y.jsx("h3", { className: "font-bold text-white mb-2 text-lg", children: "Analytics" }), y.jsx("p", { className: "text-slate-400 text-sm leading-relaxed", children: "We may use privacy-focused analytics (non-identifiable) to understand how users interact with our documentation and landing pages to improve the user experience." })] })] })] }), y.jsxs("section", { children: [y.jsxs("div", { className: "flex items-center gap-3 mb-6", children: [y.jsx("div", { className: "w-10 h-10 rounded-xl bg-rose-500/10 flex items-center justify-center text-rose-500", children: y.jsx(Lu, { size: 20 }) }), y.jsx("h2", { className: "text-2xl font-bold text-white", children: "3. Third-Party Technologies" })] }), y.jsx("p", { className: "text-slate-300 leading-relaxed mb-4", children: "We may use third-party services that set their own cookies:" }), y.jsxs("ul", { className: "list-disc pl-6 space-y-2 text-slate-300", children: [y.jsxs("li", { children: [y.jsx("strong", { children: "Stripe / LemonSqueezy:" }), " Used during the checkout process to securely handle payments and prevent fraud."] }), y.jsxs("li", { children: [y.jsx("strong", { children: "Google Gemini API:" }), " When you generate prompts, data is transmitted to Google's servers, but no tracking cookies are set by us for this interaction."] })] })] }), y.jsxs("section", { children: [y.jsxs("div", { className: "flex items-center gap-3 mb-6", children: [y.jsx("div", { className: "w-10 h-10 rounded-xl bg-green-500/10 flex items-center justify-center text-green-500", children: y.jsx(xx, { size: 20 }) }), y.jsx("h2", { className: "text-2xl font-bold text-white", children: "4. Managing Cookies" })] }), y.jsx("p", { className: "text-slate-300 leading-relaxed mb-4", children: "You can control and/or delete cookies as you wish. You can delete all cookies that are already on your computer and you can set most browsers to prevent them from being placed. If you do this, however, you may have to manually adjust some preferences every time you visit a site and some services and functionalities may not work." }), y.jsxs("p", { className: "text-slate-300 leading-relaxed", children: [`To clear MetaAi Automator data, simply uninstall the extension or clear your browser's "Local Storage" for `, y.jsx("code", { children: "metaaiautomator.com" }), "."] })] }), y.jsxs("section", { className: "pt-8 border-t border-white/10", children: [y.jsx("h2", { className: "text-2xl font-bold text-white mb-4", children: "5. Questions?" }), y.jsx("p", { className: "text-slate-300 leading-relaxed mb-4", children: "If you have any questions about our Cookie Policy, please contact us." }), y.jsx("a", { href: "mailto:privacy@metaaiautomator.com", className: "text-primary font-bold hover:underline", children: "privacy@metaaiautomator.com" })] })] })] }) }), Ib = () => y.jsx("div", { className: "pt-32 pb-24 px-6 min-h-screen flex items-center justify-center", children: y.jsxs("div", { className: "max-w-3xl w-full text-center", children: [y.jsxs("div", { className: "mb-12 relative inline-block", children: [y.jsx("div", { className: "absolute inset-0 bg-primary/20 blur-[50px] rounded-full animate-pulse" }), y.jsx($v, { size: 120, className: "text-primary relative z-10", fill: "black" })] }), y.jsxs("h1", { className: "text-5xl md:text-7xl font-black text-white mb-8 tracking-tighter", children: ["Thank ", y.jsx("span", { className: "text-primary", children: "You!" })] }), y.jsx("p", { className: "text-xl md:text-2xl text-slate-300 mb-12 max-w-2xl mx-auto leading-relaxed", children: "You're all set. Your purchase was successful and you have joined the ranks of power users automating their creativity." }), y.jsxs("div", { className: "bg-surface/30 border border-white/10 rounded-[2.5rem] p-8 md:p-12 mb-12", children: [y.jsx("h2", { className: "text-2xl font-bold text-white mb-8", children: "What happens next?" }), y.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-6", children: [y.jsxs("div", { className: "p-6 rounded-2xl bg-black border border-white/5 hover:border-primary/30 transition-all group cursor-pointer", onClick: () => window.open("https://chromewebstore.google.com/detail/oahcpmhnmcfjciaehfijhfjofjddjjij", "_blank"), children: [y.jsx("div", { className: "w-12 h-12 bg-surface rounded-full flex items-center justify-center text-slate-300 mx-auto mb-4 group-hover:text-primary group-hover:bg-primary/10 transition-colors", children: y.jsx(Kp, { size: 24 }) }), y.jsx("h3", { className: "font-bold text-white mb-2", children: "1. Install" }), y.jsx("p", { className: "text-sm text-slate-400", children: "Get the extension from the Chrome Web Store if you haven't yet." })] }), y.jsxs("div", { className: "p-6 rounded-2xl bg-black border border-white/5 hover:border-primary/30 transition-all group cursor-pointer", onClick: () => window.location.href = "/?view=docs", children: [y.jsx("div", { className: "w-12 h-12 bg-surface rounded-full flex items-center justify-center text-slate-300 mx-auto mb-4 group-hover:text-primary group-hover:bg-primary/10 transition-colors", children: y.jsx(Hv, { size: 24 }) }), y.jsx("h3", { className: "font-bold text-white mb-2", children: "2. Read Docs" }), y.jsx("p", { className: "text-sm text-slate-400", children: "Learn how to setup your API keys and configure the delay timers." })] }), y.jsxs("div", { className: "p-6 rounded-2xl bg-black border border-white/5 hover:border-primary/30 transition-all group cursor-pointer", onClick: () => window.location.href = "mailto:support@metaaiautomator.com", children: [y.jsx("div", { className: "w-12 h-12 bg-surface rounded-full flex items-center justify-center text-slate-300 mx-auto mb-4 group-hover:text-primary group-hover:bg-primary/10 transition-colors", children: y.jsx(Dx, { size: 24 }) }), y.jsx("h3", { className: "font-bold text-white mb-2", children: "3. Support" }), y.jsx("p", { className: "text-sm text-slate-400", children: "Questions? Our support team is ready to help you optimize." })] })] })] }), y.jsx("div", { className: "flex flex-col md:flex-row gap-4 justify-center", children: y.jsx(Ft, { size: "lg", onClick: () => window.location.href = "/?view=home", children: "Back to Home" }) })] }) }), kb = () => y.jsx("div", { className: "pt-32 pb-24 px-6 min-h-screen", children: y.jsxs("div", { className: "max-w-4xl mx-auto", children: [y.jsxs("div", { className: "mb-16", children: [y.jsxs("h1", { className: "text-4xl md:text-5xl font-black text-white mb-6", children: ["Terms of ", y.jsx("span", { className: "text-primary", children: "Service" })] }), y.jsx("p", { className: "text-slate-400 text-lg", children: "Last Updated: May 20, 2025" })] }), y.jsxs("div", { className: "bg-surface/30 border border-white/10 rounded-[2.5rem] p-8 md:p-12 space-y-12", children: [y.jsxs("section", { children: [y.jsxs("div", { className: "flex items-center gap-3 mb-6", children: [y.jsx("div", { className: "w-10 h-10 rounded-xl bg-primary/10 flex items-center justify-center text-primary", children: y.jsx(Xp, { size: 20 }) }), y.jsx("h2", { className: "text-2xl font-bold text-white", children: "1. Agreement to Terms" })] }), y.jsx("p", { className: "text-slate-300 leading-relaxed", children: 'By accessing or using MetaAi Automator (the "Service"), you agree to be bound by these Terms. If you disagree with any part of the terms, then you may not access the Service.' })] }), y.jsxs("section", { children: [y.jsxs("div", { className: "flex items-center gap-3 mb-6", children: [y.jsx("div", { className: "w-10 h-10 rounded-xl bg-blue-500/10 flex items-center justify-center text-blue-500", children: y.jsx(Ox, { size: 20 }) }), y.jsx("h2", { className: "text-2xl font-bold text-white", children: "2. License" })] }), y.jsx("p", { className: "text-slate-300 leading-relaxed mb-4", children: "MetaAi Automator grants you a revocable, non-exclusive, non-transferable, limited license to download, install and use the extension strictly in accordance with the terms of this Agreement." }), y.jsxs("ul", { className: "list-disc pl-6 space-y-2 text-slate-300", children: [y.jsx("li", { children: "You may not reverse engineer, decompile, or disassemble the software." }), y.jsx("li", { children: "You may not modify, adapt, or create derivative works from the software." })] })] }), y.jsxs("section", { children: [y.jsxs("div", { className: "flex items-center gap-3 mb-6", children: [y.jsx("div", { className: "w-10 h-10 rounded-xl bg-rose-500/10 flex items-center justify-center text-rose-500", children: y.jsx(iS, { size: 20 }) }), y.jsx("h2", { className: "text-2xl font-bold text-white", children: "3. Disclaimers" })] }), y.jsx("p", { className: "text-slate-300 leading-relaxed mb-4", children: 'The Service is provided on an "AS IS" and "AS AVAILABLE" basis. MetaAi Automator makes no warranties, expressed or implied, regarding the reliability or availability of the Meta Ai  /Labs platform which this extension interacts with.' }), y.jsx("p", { className: "text-slate-300 leading-relaxed", children: "You are responsible for maintaining the safety of your own Google account. MetaAi Automator is not responsible for bans or suspensions resulting from misuse of the automation features." })] }), y.jsxs("section", { children: [y.jsxs("div", { className: "flex items-center gap-3 mb-6", children: [y.jsx("div", { className: "w-10 h-10 rounded-xl bg-green-500/10 flex items-center justify-center text-green-500", children: y.jsx(Zp, { size: 20 }) }), y.jsx("h2", { className: "text-2xl font-bold text-white", children: "4. Limitation of Liability" })] }), y.jsx("p", { className: "text-slate-300 leading-relaxed", children: "In no event shall MetaAi Automator be liable for any indirect, incidental, special, consequential or punitive damages, including without limitation, loss of profits, data, use, goodwill, or other intangible losses, resulting from your access to or use of or inability to access or use the Service." })] }), y.jsxs("section", { className: "pt-8 border-t border-white/10", children: [y.jsx("h2", { className: "text-2xl font-bold text-white mb-4", children: "Contact" }), y.jsx("p", { className: "text-slate-300 leading-relaxed mb-4", children: "Questions about the Terms of Service should be sent to us at support." }), y.jsx("a", { href: "mailto:support@metaaiautomator.com", className: "text-primary font-bold hover:underline", children: "support@metaaiautomator.com" })] })] })] }) }), Ra = ["en", "zh", "es", "ar", "pt", "de", "ja", "ko", "nl", "vi", "tr", "bn", "th", "pl", "ru"], Op = "https://chromewebstore.google.com/detail/oahcpmhnmcfjciaehfijhfjofjddjjij"; function Db() {
  const [i, t] = ze.useState(!1), [l, a] = ze.useState("home"), [r, d] = ze.useState("en"); ze.useEffect(() => { const x = new URLSearchParams(window.location.search), T = x.get("lang"); if (T && Ra.includes(T)) d(T); else { const U = navigator.language.split("-")[0]; Ra.includes(U) && d(U) } const _ = x.get("view"), A = window.location.pathname.replace(/^\/|\/$/g, ""), k = ["home", "support", "docs", "blog", "about", "privacy_policy", "cookie-policy", "thank-you", "terms-of-service"]; _ && k.includes(_) ? a(_) : A && k.includes(A) && a(A); const G = () => { const V = new URLSearchParams(window.location.search).get("view") || "home"; a(V) }; return window.addEventListener("popstate", G), () => window.removeEventListener("popstate", G) }, []); const m = x => { d(x); const T = new URL(window.location.href); T.searchParams.set("lang", x), window.history.pushState({}, "", T) }, g = r === "ar", v = eg[r]; ze.useEffect(() => { document.documentElement.lang = r, document.documentElement.dir = g ? "rtl" : "ltr"; let x = v.meta.title; l !== "home" && (x = `${l.replace(/_/g, " ").split("-").map(A => A.charAt(0).toUpperCase() + A.slice(1)).join(" ")} - MetaAi Automator`), document.title = x; const T = document.querySelector('meta[name="description"]'); T && T.setAttribute("content", v.meta.description) }, [r, g, v, l]), ze.useEffect(() => { const x = { root: null, rootMargin: "0px", threshold: .1 }, T = new IntersectionObserver(k => { k.forEach(G => { G.isIntersecting && (G.target.classList.add("active"), T.unobserve(G.target)) }) }, x), _ = () => { document.querySelectorAll(".reveal:not(.active)").forEach(G => T.observe(G)) }; _(); const A = new MutationObserver(_); return A.observe(document.body, { childList: !0, subtree: !0 }), () => { T.disconnect(), A.disconnect() } }, []); const p = (x, T) => { if (t(!1), x !== l) { const _ = new URL(window.location.href); _.searchParams.set("view", x), T || (_.hash = ""), window.history.pushState({}, "", _), a(x), window.scrollTo({ top: 0, behavior: "smooth" }) } else T || window.scrollTo({ top: 0, behavior: "smooth" }); T && setTimeout(() => { var _; (_ = document.getElementById(T)) == null || _.scrollIntoView({ behavior: "smooth" }) }, 100) }; return y.jsx(tg.Provider, {
    value: { lang: r, setLang: m, t: v, isRTL: g }, children: y.jsxs("div", {
      className: `min-h-screen bg-background text-slate-100 font-display selection:bg-primary selection:text-black relative overflow-x-hidden ${g ? "rtl" : ""}`, dir: g ? "rtl" : "ltr", children: [y.jsxs("div", {
        className: "fixed inset-0 z-0 pointer-events-none overflow-hidden", children: [y.jsx("div", {
          className: "absolute inset-0 opacity-20", style: {
            backgroundImage: `
                linear-gradient(to right, #808080 1px, transparent 1px),
                linear-gradient(to bottom, #808080 1px, transparent 1px)
              `, backgroundSize: "50px 50px", maskImage: "radial-gradient(circle at center, black 40%, transparent 100%)", WebkitMaskImage: "radial-gradient(circle at center, black 40%, transparent 100%)"
          }
        }), y.jsx("div", { className: "absolute top-0 left-1/4 w-[500px] h-[500px] bg-primary/10 mix-blend-screen filter blur-[100px] animate-liquid" }), y.jsx("div", { className: "absolute top-1/4 right-1/4 w-[450px] h-[450px] bg-rose-500/5 mix-blend-screen filter blur-[100px] animate-liquid animation-delay-2000" }), y.jsx("div", { className: "absolute -bottom-32 left-1/2 w-[600px] h-[600px] bg-primary/5 mix-blend-screen filter blur-[120px] animate-liquid animation-delay-4000" })]
      }), y.jsxs("nav", { className: "fixed top-0 left-0 right-0 z-50 glass-card border-b border-primary/10 px-6 py-4", children: [y.jsxs("div", { className: "max-w-7xl mx-auto flex items-center justify-between", children: [y.jsxs("div", { className: "flex items-center gap-2 cursor-pointer", onClick: () => p("home"), children: [y.jsx("img", { alt: "MetaAi Automator Logo", className: "w-10 h-10 rounded-xl shadow-[0_0_15px_rgba(250,204,21,0.5)] object-cover", src: "/logo.png" }), y.jsxs("span", { className: "font-extrabold text-xl tracking-tight text-white", children: ["Meta Ai   ", y.jsx("span", { className: "text-primary", children: "Automation" })] })] }), y.jsxs("div", { className: "hidden md:flex items-center gap-8 font-medium text-sm", children: [y.jsx("button", { className: `hover:text-primary transition-colors ${l === "home" ? "text-white" : "text-slate-400"}`, onClick: () => p("home"), children: v.nav.home }), y.jsx("button", { className: "hover:text-primary transition-colors text-slate-400", onClick: () => p("home", "features"), children: v.nav.features }), y.jsx("button", { className: "hover:text-primary transition-colors text-slate-400", onClick: () => p("home", "pricing"), children: v.nav.pricing }), y.jsx("button", { className: `hover:text-primary transition-colors ${l === "docs" ? "text-white" : "text-slate-400"}`, onClick: () => p("docs"), children: v.nav.docs }), y.jsx("button", { className: `hover:text-primary transition-colors ${l === "blog" ? "text-white" : "text-slate-400"}`, onClick: () => p("blog"), children: v.nav.blog }), y.jsxs("div", { className: "relative group ml-4", children: [y.jsxs("button", { className: "flex items-center gap-1 text-slate-400 hover:text-white uppercase font-bold text-xs", children: [y.jsx(Qp, { size: 14 }), " ", r] }), y.jsx("div", { className: "absolute top-full right-0 mt-2 bg-surface border border-white/10 rounded-xl p-2 hidden group-hover:block w-32 max-h-64 overflow-y-auto custom-scrollbar shadow-xl", children: Ra.map(x => y.jsxs("button", { onClick: () => m(x), className: `block w-full text-left px-3 py-2 text-sm rounded-lg hover:bg-white/5 ${r === x ? "text-primary font-bold" : "text-slate-400"}`, children: [x === "en" && "English", x === "zh" && "", x === "es" && "Espaol", x === "ar" && "", x === "pt" && "Portugus", x === "de" && "Deutsch", x === "ja" && "", x === "ko" && "", x === "nl" && "Nederlands", x === "vi" && "Ting Vit", x === "tr" && "Trke", x === "bn" && "", x === "th" && "", x === "pl" && "Polski", x === "ru" && ""] }, x)) })] })] }), y.jsx("div", { className: "hidden md:block", children: y.jsx(Ft, { size: "sm", onClick: () => window.open(Op, "_blank"), children: v.nav.install }) }), y.jsx("button", { className: "md:hidden text-white", onClick: () => t(!i), children: i ? y.jsx(ka, {}) : y.jsx(Mx, {}) })] }), i && y.jsxs("div", { className: "md:hidden absolute top-full left-0 right-0 bg-surface border-b border-primary/10 p-4 space-y-4 shadow-2xl max-h-[80vh] overflow-y-auto", children: [y.jsx("button", { className: "block w-full text-left text-slate-300 hover:text-primary p-2", onClick: () => p("home"), children: v.nav.home }), y.jsx("button", { className: "block w-full text-left text-slate-300 hover:text-primary p-2", onClick: () => p("home", "features"), children: v.nav.features }), y.jsx("button", { className: "block w-full text-left text-slate-300 hover:text-primary p-2", onClick: () => p("home", "pricing"), children: v.nav.pricing }), y.jsx("button", { className: "block w-full text-left text-slate-300 hover:text-primary p-2", onClick: () => p("docs"), children: v.nav.docs }), y.jsx("button", { className: "block w-full text-left text-slate-300 hover:text-primary p-2", onClick: () => p("blog"), children: v.nav.blog }), y.jsx("button", { className: "block w-full text-left text-slate-300 hover:text-primary p-2", onClick: () => p("support"), children: v.nav.support }), y.jsx("button", { className: "block w-full text-left text-slate-300 hover:text-primary p-2", onClick: () => p("about"), children: v.nav.about }), y.jsx("button", { className: "block w-full text-left text-slate-300 hover:text-primary p-2", onClick: () => p("privacy_policy"), children: v.nav.privacy }), y.jsx("button", { className: "block w-full text-left text-slate-300 hover:text-primary p-2", onClick: () => p("cookie-policy"), children: "Cookie Policy" }), y.jsx("button", { className: "block w-full text-left text-slate-300 hover:text-primary p-2", onClick: () => p("terms-of-service"), children: "Terms of Service" }), y.jsx("div", { className: "flex gap-2 flex-wrap border-t border-white/10 pt-4 mt-2", children: Ra.map(x => y.jsx("button", { onClick: () => { m(x), t(!1) }, className: `px-3 py-1 rounded border border-white/10 text-xs uppercase ${r === x ? "bg-primary text-black" : "text-slate-400"}`, children: x }, x)) }), y.jsx("div", { className: "pt-2", children: y.jsx(Ft, { className: "w-full", onClick: () => window.open(Op, "_blank"), children: v.nav.install }) })] })] }), y.jsxs("div", { className: "relative z-10 min-h-screen flex flex-col", children: [y.jsxs("main", { className: "flex-grow", children: [l === "home" && y.jsx(Ab, {}), l === "support" && y.jsx(Cb, {}), l === "docs" && y.jsx(bb, {}), l === "blog" && y.jsx(Nb, {}), l === "about" && y.jsx(wb, {}), l === "privacy_policy" && y.jsx(Mb, {}), l === "cookie-policy" && y.jsx(Rb, {}), l === "terms-of-service" && y.jsx(kb, {}), l === "thank-you" && y.jsx(Ib, {})] }), y.jsx("footer", { className: "bg-black/50 backdrop-blur-md border-t border-white/5 pt-20 pb-10 mt-auto", children: y.jsxs("div", { className: "max-w-7xl mx-auto px-6", children: [y.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-4 gap-12 mb-20", children: [y.jsxs("div", { className: "col-span-1 md:col-span-2", children: [y.jsxs("div", { className: "flex items-center gap-2 mb-6 cursor-pointer", onClick: () => p("home"), children: [y.jsx("img", { alt: "MetaAi Automator Logo", className: "w-8 h-8 rounded-lg object-cover", src: "/logo.png" }), y.jsxs("span", { className: "font-extrabold text-xl text-white", children: ["Meta Ai   ", y.jsx("span", { className: "text-primary", children: "Automation" })] })] }), y.jsx("p", { className: "text-slate-500 max-w-sm mb-6", children: v.hero.subtitle })] }), y.jsxs("div", { children: [y.jsx("h4", { className: "font-bold mb-6 text-white uppercase tracking-widest text-sm", children: "Product" }), y.jsxs("ul", { className: "space-y-4 text-slate-500", children: [y.jsx("li", { children: y.jsx("button", { className: "hover:text-primary transition-colors text-left", onClick: () => p("home", "features"), children: v.nav.features }) }), y.jsx("li", { children: y.jsx("button", { className: "hover:text-primary transition-colors text-left", onClick: () => p("home", "generator"), children: "Generator" }) }), y.jsx("li", { children: y.jsx("button", { className: "hover:text-primary transition-colors text-left", onClick: () => p("home", "pricing"), children: v.nav.pricing }) })] })] }), y.jsxs("div", { children: [y.jsx("h4", { className: "font-bold mb-6 text-white uppercase tracking-widest text-sm", children: "Resources" }), y.jsxs("ul", { className: "space-y-4 text-slate-500", children: [y.jsx("li", { children: y.jsx("button", { className: "hover:text-primary transition-colors text-left", onClick: () => p("support"), children: v.nav.support }) }), y.jsx("li", { children: y.jsx("button", { className: "hover:text-primary transition-colors text-left", onClick: () => p("docs"), children: v.nav.docs }) }), y.jsx("li", { children: y.jsx("button", { className: "hover:text-primary transition-colors text-left", onClick: () => p("blog"), children: v.nav.blog }) }), y.jsx("li", { children: y.jsx("button", { className: "hover:text-primary transition-colors text-left", onClick: () => p("about"), children: v.nav.about }) })] })] })] }), y.jsxs("div", { className: "border-t border-white/5 pt-10 flex flex-col md:flex-row justify-between gap-6 text-sm text-slate-500", children: [y.jsxs("div", { className: "flex gap-8", children: [y.jsx("button", { className: "hover:text-white transition-colors", onClick: () => p("privacy_policy"), children: v.nav.privacy }), y.jsx("button", { className: "hover:text-white transition-colors", onClick: () => p("cookie-policy"), children: "Cookie Policy" }), y.jsx("button", { className: "hover:text-white transition-colors", onClick: () => p("terms-of-service"), children: "Terms of Service" })] }), y.jsx("p", { children: " 2026 MetaAi Automator. All rights reserved." })] })] }) })] })]
    })
  })
} const Xg = document.getElementById("root"); if (!Xg) throw new Error("Could not find root element to mount to"); const Ub = Mv.createRoot(Xg); Ub.render(y.jsx(Ia.StrictMode, { children: y.jsx(Db, {}) }));
